<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>数据可视化</title>
      <link href="/posts/9a5c3c2.html"/>
      <url>/posts/9a5c3c2.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-大数据可视化概述"><a href="#1-大数据可视化概述" class="headerlink" title="1. 大数据可视化概述"></a>1. 大数据可视化概述</h2><ol><li>数据可视化是为了帮助用户通过认知数据，进而发现这些数据所反映的实质</li><li>数据可视化的三种<code>类型</code><ul><li>科学可视化</li><li>信息可视化</li><li>可视化分析</li></ul></li><li>数据可视化的<code>标准</code>通常包含：实用性、完整性、真实性、艺术性、交互性</li><li>数据可视化的<code>目标</code><ul><li><strong>应用角度：</strong><ul><li>通过数据可视化有效呈现数据中的重要特征</li><li>通过数据可视化揭示事物内部客观规律以及数据间的内在联系</li><li>通过数据可视化辅助人们理解事物概念和过程</li><li>通过数据可视化对模拟和测量进行质量监控</li><li>通过数据可视化提高科研开发效率</li></ul></li><li><strong>宏观角度：</strong><ul><li>数据可视化的目标主要包含有信息记录、信息分析和信息传播</li></ul></li></ul></li><li>数据可视化的<code>作用</code><ul><li>数据表达</li><li>数据操作</li><li>数据分析</li></ul></li><li>数据可视化的<code>流程</code><ul><li>数据采集 -&gt; 数据处理 -&gt; 可视化映射 -&gt; 用户感知</li></ul></li></ol><h2 id="2-数据预处理概述"><a href="#2-数据预处理概述" class="headerlink" title="2. 数据预处理概述"></a>2. 数据预处理概述</h2><ol><li>数据的类型<ul><li>结构化数据（日期、产品名称）</li><li>半结构化数据（日志文件、HTML、XML、JSON）</li><li>非结构化数据（文档、图片、视频、音频）</li></ul></li><li>数据预处理流程<ul><li>数据清洗 -&gt; 数据集成 -&gt; 数据归约 -&gt; 数据变换</li></ul></li></ol><h2 id="3-数据分析技术"><a href="#3-数据分析技术" class="headerlink" title="3. 数据分析技术"></a>3. 数据分析技术</h2><h3 id="分类（有监督学习）"><a href="#分类（有监督学习）" class="headerlink" title="分类（有监督学习）"></a>分类（有监督学习）</h3><ol><li><p>逻辑回归是一种分类算法（不要被带有回归二字误导了）</p></li><li><p>逻辑回归&#x3D;线性回归+Sigmoid函数</p></li><li><p>Logistic&#x2F;Softmax回归模型一般用于分类问题</p></li><li><p>分类问题当中正类和负类分别指什么</p><ul><li>正类：模型需要检测或<strong>预测的目标</strong>类别（如疾病患者、欺诈交易、垃圾邮件）</li><li>负类：与正类相对的非目标类别（如健康人、正常交易、正常邮件）</li></ul></li><li><p><code>评价指标</code></p><ul><li><p>P-R曲线（横坐标召回率，纵坐标精确率）</p></li><li><p>ROC曲线（横坐标FP，纵坐标是TP）与横坐标围成的面积为AUC值</p><ul><li>我们希望FP越低，TP越高越好，所以ROC曲线越抖效果越好</li></ul></li><li><p>准确率（Accuracy）全局视角，衡量模型整体正确率</p></li><li><p>精确率（Precision）</p><ul><li><strong>预测为正</strong>的样本中，有多少是真的</li><li>TP &#x2F; (TP + FP)</li><li>相当于看一列</li></ul></li><li><p>召回率（Recall）</p><ul><li><strong>真实为正</strong>的样本中，预测对了多少</li><li>TP &#x2F; (TP + FN)</li><li>相当于看一行</li></ul></li><li><p>F1值</p></li><li><p>混淆矩阵</p><ul><li><table><thead><tr><th></th><th><strong>预测为正类</strong></th><th><strong>预测为负类</strong></th></tr></thead><tbody><tr><td><strong>实际为正类</strong></td><td>TP</td><td>FN</td></tr><tr><td><strong>实际为负类</strong></td><td>FP</td><td>TN</td></tr></tbody></table></li></ul></li></ul></li></ol><h3 id="回归预测（有监督学习）"><a href="#回归预测（有监督学习）" class="headerlink" title="回归预测（有监督学习）"></a>回归预测（有监督学习）</h3><ol><li>回归的算法模型：线性回归（Linear）、岭回归（Ridge）、LASSO回归</li><li>最小二乘法是通过最小化平方误差求解线性模型参数的</li><li><code>评价指标</code><ul><li>均方误差（MSE）</li><li>均方根误差（RMSE）</li><li>平均绝对误差（MAE）</li><li>R^2</li></ul></li></ol><h3 id="聚类（无监督学习）"><a href="#聚类（无监督学习）" class="headerlink" title="聚类（无监督学习）"></a>聚类（无监督学习）</h3><ol><li><p>聚类与分类的区别在于聚类不依赖于预先定义的类，没有预定义的类和样本——聚类是一种无监督的数据挖掘任务</p></li><li><p>聚类是把各不相同的个体分割为更多相似性子集合的工作</p></li><li><p>聚类生成的子集称为簇</p></li><li><p>聚类的分类</p><ul><li>基于划分：K-means、K-medoids、K-prototype算法</li><li>基于密度：DBSCAN、DENCLUE、OPTICS算法</li><li>基于层次：BIRCH、CURE、ROCK算法</li></ul></li><li><p>客单价是指每一位顾客平均每次消费的金额</p></li><li><p><code>评价指标</code></p><ul><li><p><strong>外部指标：（需真实标签）</strong></p><ul><li><p>ARI（调整兰德指数）</p></li><li><p>NMI（归一化互信息）</p></li><li><p>Jaccard系数（JC）</p></li><li><p>FM指数</p></li><li><p>Rand指数</p></li></ul></li></ul><p>上述指标结果均在[0, 1]区间，值越大越好</p><ul><li><p><strong>内部指标：（无需真实标签）</strong></p><ul><li><p>DBI（DB指数）：值越小越好</p></li><li><p>DI：值越大越好</p></li><li><p>CH指数：越大越好</p></li><li><p>轮廓系数：-1到1，越大越好</p></li></ul></li></ul></li><li><p>K-means</p><ul><li><p>算法步骤</p><ol><li>随机选取K个样本作为类中心</li><li>计算各样本与各类中心的距离</li><li>将各样本归于最近的类中心点</li><li><strong>求各类样本的均值，作为新的类中心</strong></li><li>判定：若类中心不再发生变动或达到迭代次数，算法结束，否则回到第2步</li></ol></li><li><p>聚类的特点是什么（需要指定聚类数k）</p><p>优点</p><ul><li>算法简单易用</li><li>聚类结果容易解释，适用于高维数据的聚类</li><li>对球形簇样本聚类效果好</li><li>二分k均值等变种算法运行良好，不受初始化问题的影响</li></ul><p>缺点</p><ul><li>不能处理非球形簇、不同尺寸和不同密度的簇</li><li>对离群点、噪声敏感</li><li>贪心策略，容易局部收敛</li></ul></li></ul></li><li><p>K-medoids</p><ul><li><p>算法步骤：</p><ol><li>随机选取K个样本作为类中心</li><li>计算各样本与各类中心的距离</li><li>将各样本归于最近的类中心点</li><li><strong>在各类别内选取到其余样本距离之和最小的样本作为新的类中心</strong></li><li>判定：若类中心不再发生变动或达到迭代次数，算法结束，否则回到第2步</li></ol></li><li><p>算法特点：</p><ul><li>需要指定聚类数k</li><li>克服缺点：K-means算法中异常数据会使聚类结果偏离</li><li>找类距离：不是计算各簇中所有样本点的平均值，而是在各簇中选取到其余样本距离之和最小的样本点</li></ul><p>优点</p><ul><li>算法简单易理解</li><li>对球形簇样本聚类效果好</li><li>对离群点、噪声<strong>不</strong>敏感</li></ul><p>缺点</p><ul><li>不能处理非球形簇，不同尺寸和不同密度的簇</li><li>算法复杂度较高</li></ul></li></ul></li><li><p>层次聚类</p><ul><li><p>凝聚的层次聚类（自底向上）</p></li><li><p>分裂的层次聚类（自顶向下）</p><p>特点：</p><ul><li>不需要事先设定类别数K</li><li>每次迭代过程仅将距离最近的两个样本簇聚为一类</li></ul><p>优点</p><ul><li>在系统发生树，基因芯片应用领域需要层次结构</li><li>研究表面，这种算法能够产生较高质量的聚类</li></ul><p>缺点</p><ul><li>计算量、存储量大</li><li>对噪声、高维数据敏感</li></ul></li></ul></li><li><p>密度聚类</p><ul><li><p>DBSCAN（具有噪声的基于密度的聚类方法）</p></li><li><p>将具有足够密度的区域划分为簇，并在具有噪声的空间数据库中发现任意形状的簇，它将簇定义为密度相连的点的最大集合</p></li><li><p>特点</p><ul><li>对噪声<strong>不</strong>敏感</li><li>可以处理不同形状和大小的簇</li><li>DBSCAN算法有两个参数<ul><li>半径（Eps）</li><li>阈值（MinPts）：圈住点的个数</li></ul></li></ul><p>优点</p><ul><li>基于密度定义，相对抗噪音，能处理任意形状和大小的簇</li><li>当数据集分布为非球形时，使用DBSCAN算法效果好</li></ul><p>缺点</p><ul><li>对两个参数的设置敏感：圈的半径（Eps）、阈值（MinPts）</li><li>DBSCAN使用固定的参数识别聚类。显然，当聚类的稀疏程度不同，聚类效果也有很大的不同。即密度不均匀时，很难使用该算法</li><li>如果数据样本集越大，收敛时间越长</li></ul></li></ul></li></ol><h3 id="推荐算法"><a href="#推荐算法" class="headerlink" title="推荐算法"></a>推荐算法</h3><ol><li>协同过滤算法<ul><li>基于用户的协同过滤算法<ul><li>问题：数据稀疏，计算复杂，人是善变的，冷启动问题</li><li>稀疏：通常商品非常多，用户购买的只是其中极小的一部分</li><li>计算：计算相似度矩阵复杂</li><li>冷启动：新用户来了怎么办<ul><li>引导用户把自己的一些属性表达出来</li><li>利用现有的开放数据平台</li><li>根据用户注册属性</li><li>推荐排行榜单</li></ul></li></ul></li><li>基于物品的协同过滤算法<ul><li>更流行，现阶段各大网站基本都是用户较多，商品（种类）比用户少得多</li><li>商品属性通常比较固定，特征获取容易，而且基本不变</li><li>即使上架了，也会有标签，不会像用户一样是一张白纸</li></ul></li></ul></li><li>相似度计算<ul><li>欧几里得距离</li><li>皮尔逊相关系数</li><li>Cosine相似度</li></ul></li><li>隐语义模型<ul><li>矩阵分解</li><li>评分矩阵 &#x3D; user矩阵 × item矩阵</li></ul></li><li>推荐系统的<strong>难点与挑战</strong><ul><li>需要广泛收集用户标签画像</li><li>人是善变的，随着时间的推移，兴趣也会改变</li><li>根据固定的画像数据，推荐结果不可能固定不变</li><li>特征工程的构建</li><li>商品和用户的冷启动</li></ul></li></ol><h3 id="关联规则"><a href="#关联规则" class="headerlink" title="关联规则"></a>关联规则</h3><ol><li>支持度<ul><li>指某个商品组合出现的次数与总次数之间的比例，支持度越高表示该组合出现的几率越大</li><li>Sup(A, B) &#x3D; freq(A, B) &#x2F; N</li></ul></li><li>置信度<ul><li>表示购买了A商品后，有多大概率会购买B商品（条件概率）</li><li>Con(A -&gt; B) &#x3D; Sup(A, B) &#x2F; Sup(A)</li></ul></li><li>提升度<ul><li>商品A出现，对商品B出现概率提升的程度</li><li>Lift(A -&gt; B) &#x3D; Con(A -&gt; B) &#x2F; Sup(B)</li><li>Lift&#x3D;1：A和B独立，无关联</li><li>Lift&gt;1：A和B正相关，A的出现促进B的出现</li><li>Lift&lt;1：A和B负相关，A的出现抑制B的出现</li></ul></li><li>Apriori算法<ul><li>缺点<ul><li>可能产生大量的候选集，因为采用排列组合的方式，把可能的项集都组合出来了</li><li>每次计算都需要重新扫描数据集，来计算每个项集的支持度</li></ul></li></ul></li></ol><h2 id="4-数据可视化方法"><a href="#4-数据可视化方法" class="headerlink" title="4. 数据可视化方法"></a>4. 数据可视化方法</h2><ol><li>常见的比较类图主要有：柱状图、气泡图、漏斗图、直方图</li><li>常见的分部类图有：热力图、散点图、直方图</li><li>常见的流程类图：漏斗图、桑基图</li><li>常见的占比的图：饼图、环形图、堆叠面积图、堆叠柱状图、矩形树图</li><li>常见的区间类图：仪表盘图、堆叠面积图</li><li>常见的关联类图有：和弦图、桑基图</li><li>常见的时间类图：面积图、K线图、折现图</li><li>常见的趋势类图：面积图、K线图、折线图</li><li>美化方法<ul><li>柱状图<ul><li>宽度和间隙要适当</li><li>排列的时候最后按照规律排列，例如按照数量从多到少进行排列，或者字母顺序</li></ul></li><li>折线图<ul><li>折线的颜色要清晰，尽量不要与背景颜色和坐标轴颜色相近</li></ul></li><li>饼图<ul><li>多数人的视觉习惯是按照顺时针和自上而下的顺序去观察，因此在绘制饼图时候建议从12点开始顺时针右边第一个分块绘制饼图最大的数据分块，可以有效强调其重要性</li></ul></li></ul></li><li>如果需要表达数据之间的关联关系，可以使用散点图和气泡图</li><li>漏斗图可以清晰的看出每个层级的转化，例如日期与工作转换率的关系</li><li>文本可视化<ul><li>基于文本内容的可视化<ul><li>词频可视化，词汇分布可视化，常见的有词云、分布图和Document Cards</li></ul></li><li>基于文本关系的可视化<ul><li>树状图、节点连接的网络图、力导向图、叠式图和Word Tree</li></ul></li></ul></li><li>excel连接外部数据的主要好处是可以在excel定期分析此数据，而不用重复复制数据，复制操作不仅耗时而且容易出错</li><li>Tableau的特点如下：<ul><li>安全性</li><li>易用性</li><li>自助式开发</li><li>有效管控</li></ul></li><li>Tableau实现可视化的步骤<ol><li>导入数据</li><li>添加字段到功能区</li><li>选择图表</li><li>可视化展示</li></ol></li><li>echarts可视化<ul><li>饼图：type:’pie’</li><li>折线图：type:’line’</li></ul></li><li>雷达图一般用来进行多指标体系比较分析，如成绩展示、效果对比量化、多维数据比对</li></ol><h2 id="大总结"><a href="#大总结" class="headerlink" title="大总结"></a>大总结</h2><table><thead><tr><th></th><th>评价指标</th><th>可视化</th></tr></thead><tbody><tr><td>分类</td><td>准确率、精确率、召回率、F1值</td><td>混淆矩阵、ROC曲线、P-R曲线</td></tr><tr><td>回归</td><td>MSE、RMSE、MAE、R^2</td><td>折线图、散点图</td></tr><tr><td>聚类</td><td>外部指标：ARI、NMI； 内部指标：DBI、CH指数、轮廓系数</td><td>散点图、聚类树状图</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 课程学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>数仓面经总结</title>
      <link href="/posts/243bf5a4.html"/>
      <url>/posts/243bf5a4.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="美团"><a href="#美团" class="headerlink" title="美团"></a>美团</h2><h4 id="拉链表的制作，数据量有多少，为什么不用快照表呢"><a href="#拉链表的制作，数据量有多少，为什么不用快照表呢" class="headerlink" title="拉链表的制作，数据量有多少，为什么不用快照表呢"></a>拉链表的制作，数据量有多少，为什么不用快照表呢</h4><ul><li>拉链表会跟踪每个维度的变化，包括每次修改的历史，包含开始时间、结束时间、当前记录标识等字段</li><li>快照表只保留某个特定时刻的维度数据快照，不追踪变更，仅包含某个时间点的数据</li></ul><h4 id="数仓分层有哪些，具体做了什么，数仓分层作用"><a href="#数仓分层有哪些，具体做了什么，数仓分层作用" class="headerlink" title="数仓分层有哪些，具体做了什么，数仓分层作用"></a>数仓分层有哪些，具体做了什么，数仓分层作用</h4><ul><li>数仓分层架构包括ods、dwd、dwm、dws、ads<ul><li>ODS层是接入层，从数据源(api、数据库等)将数据同步到数仓中，中间<strong>不做任何</strong>处理操作</li><li>DWD层是明细层，对ODS层的数据进行<strong>清洗、关联、转换、维度退化、建设主题域</strong>等操作</li><li>DWM层是轻度汇总层，是DWD和DWS层的过渡层次，对DWD层的生产数据进行轻度汇总和汇总统计，<strong>把复杂指标前置处理，提升公共指标的复用性，减少重复加工</strong></li><li>DWS层汇总层，按主题域、颗粒度(如买卖家)划分，按照<strong>周期粒度、维度聚合</strong>，形成字段较多的宽表，用于提供后续的业务查询和应用。更重要的是要在DWS层完成<strong>指标口径统一和沉淀</strong></li><li>ADS层是应用层，按照应用域，颗粒度划分(如买卖家)划分，按照应用主题将对应的数据标签补充至应用层，形成<strong>用户画像或专项应用</strong></li></ul></li><li>价值：分层的核心就是以空间换时间<ul><li>使数据更清晰，简化复杂问题。将复杂需求简单化拆解成多个步骤解决，每层去完成各自对数据的处理</li><li>减少重复开发，提升开发效率。通过大量的预处理，建设数仓中间层，提高数据复用性</li><li>数据血缘追踪，便于定位问题。分层能够清晰表和任务的上下游，知道下游哪个模块在使用，便于排查问题和后期维护</li></ul></li></ul><h4 id="怎么设计表，怎么建模，DIM"><a href="#怎么设计表，怎么建模，DIM" class="headerlink" title="怎么设计表，怎么建模，DIM"></a>怎么设计表，怎么建模，DIM</h4><ul><li>表的设计<ul><li>符合业务需求</li><li>数据冗余与性能优化：数据冗余有时是为了查询性能的优化，比如通过预先计算一些聚合数据，减少实时计算的压力</li><li>规范化与反规范化：在设计时，常常需要权衡规范化（减少冗余，避免数据重复）与反规范化（提高查询效率）之间的平衡</li></ul></li><li>数仓建模<ul><li>星型模型<ul><li>以事实表为中心，所有维度直接关联在事实表上，这里的维表通常是未规范化的，有较大的冗余，这样可以减少表的关联，提高查询效率</li></ul></li><li>雪花模型<ul><li>雪花模型是星型模型的基础之上，维表又关联了其他维表，这里的维表通常是规范化的，减少了冗余，但是维护成本高，性能较差。如果以Hadoop体系来建设数仓，减少join就是减少shuffle</li></ul></li></ul></li><li>DIM表的设计<ul><li>包含业务属性</li><li>历史数据跟踪，可以采用拉链表的方式</li><li>避免过度冗余：虽然维度表可能会进行反规范化，以提高查询效率，但也需要避免过度冗余，影响存储空间和数据更新</li><li>设计唯一标识：每个维度表应该有一个唯一标识符，通常是维度表的主键</li></ul></li></ul><h4 id="什么是数据倾斜，数据倾斜的解决方案"><a href="#什么是数据倾斜，数据倾斜的解决方案" class="headerlink" title="什么是数据倾斜，数据倾斜的解决方案"></a>什么是数据倾斜，数据倾斜的解决方案</h4><ul><li>数据倾斜<ul><li>数据倾斜根本问题存在于key的分布不均，在进行shuffle的时候，必须将各个节点上相同的key拉取到某个节点上的一个task来进行处理，比如按照key进行聚合或join等操作。此时如果某个key对应的数据量特别大的话，就会发生数据倾斜</li></ul></li><li>解决方案<ul><li>设置参数<ul><li>开启map join，合并小文件，设置Map|Reduce内存，用Spark3计算引擎</li></ul></li><li>Map阶段层面<ul><li>剪裁列和剪裁行，减少全表、全字段查询</li><li>查询带分区字段</li><li>distribute by rand()，用来控制map输出结果的分发，保证每个分区的数据量基本一致</li></ul></li><li>Reduce阶段层面<ul><li>将distinct 改成 group by </li><li>笛卡尔积优化</li><li>先过滤在计算</li><li>将大key打上随机值计算，再去除进行重组</li></ul></li><li>map join <ul><li>map join会把小表全部读入内存中，在map阶段直接拿另外一个表的数据和内存中表数据做匹配，由于在map是进行了join操作，省去了reduce运行的效率也会高很多，mapjoin还有一个很大的好处是能够进行不等连接的join操作，如果将不等条件写在where中，那么mapreduce过程中会进行笛卡尔积，运行效率特别低，如果使用mapjoin操作，在map的过程中就完成了不等值的join操作，效率会高很多</li></ul></li><li>小文件优化<ul><li>对于分区较多使用Spark3进行动态分区刷新</li><li>对千分区较少或未分区的表采用重建表，补数据方法回刷</li></ul></li><li>z-order</li><li>Spark3切换使用aqe</li></ul></li></ul><h4 id="Spark的shuffle流程是怎么样的"><a href="#Spark的shuffle流程是怎么样的" class="headerlink" title="Spark的shuffle流程是怎么样的"></a>Spark的shuffle流程是怎么样的</h4><ul><li>Spark 任务在RDD 之间存在宽依赖时，就会触发 Shuffle。这些操作会导致数据需要重新分区，从而在不同的 Executor 之间传输数据，这就是 Shuffle 过程，Spark Shuffle 主要分为两个阶段</li><li>Map端<ul><li>根据 Key 计算目标分区 ID</li><li>数据写入内存缓冲区，当缓冲区满时触发溢写</li><li>溢写时数据进行排序或直接写入</li><li>数据写入磁盘，并为每个 Reduce 任务生成索引文件</li></ul></li><li>Reduce端<ul><li>Reduce 端任务会通过 HTTP 请求，从所有 Map 任务所在的节点上获取对应分区的数据</li><li>合并数据</li><li>如果使用的是 Sort Shuffle，数据会按照 Key 进行排序</li><li>执行后续计算</li></ul></li></ul><h4 id="Shuffle有哪几种类型"><a href="#Shuffle有哪几种类型" class="headerlink" title="Shuffle有哪几种类型"></a>Shuffle有哪几种类型</h4><ul><li>Hash Shuffle<ul><li>适用于小规模数据集，每个 Map 任务会为每个 Reduce 任务创建一个文件</li><li>容易导致小文件过多，影响性能</li><li>大规模数据处理时，磁盘 I&#x2F;O 开销大</li></ul></li><li>Sort Shuffle（默认）<ul><li>适用于大数据量场景，减少 Shuffle 过程中的小文件问题</li><li>Map 端数据在写入磁盘前按照分区 ID 进行排序，并存入单个文件</li></ul></li><li>Bypass Merge Shuffle<ul><li>适用于小规模分区（小于 200 个分区）</li><li>避免排序，提高效率</li></ul></li></ul><h4 id="在shuffle的过程中会进行排序吗，有哪几种排序"><a href="#在shuffle的过程中会进行排序吗，有哪几种排序" class="headerlink" title="在shuffle的过程中会进行排序吗，有哪几种排序"></a>在shuffle的过程中会进行排序吗，有哪几种排序</h4><ul><li><p>Map端</p><ul><li>在 <strong>Sort Shuffle</strong> 过程中，Map 任务在写入数据之前，会按照 <strong>Key 和分区 ID 进行排序</strong><ul><li>内存中的排序：<strong>Tim-Sort</strong>（归并排序优化）</li><li>如果数据量过大，则溢写到磁盘，如果有多个溢写文件，采用 <strong>External Merge Sort</strong> 合并数据，最终生成一个大文件。</li></ul></li></ul></li><li><p>Reduce端</p><ul><li>Reduce 任务在拉取多个 Map 任务的数据后，会<strong>对数据进行合并和排序</strong>，以便进行聚合或 Join 操作<ul><li>归并排序（如果多个 Map 任务的数据块太多，会采用多路归并）</li></ul></li></ul></li></ul><h4 id="什么是快速排序，时间复杂度是多少，手撕快排代码题"><a href="#什么是快速排序，时间复杂度是多少，手撕快排代码题" class="headerlink" title="什么是快速排序，时间复杂度是多少，手撕快排代码题"></a>什么是快速排序，时间复杂度是多少，手撕快排代码题</h4><ul><li>时间复杂度：O(nlog)</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1e6</span>+<span class="number">10</span>;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="type">int</span> q[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> q[],<span class="type">int</span> l,<span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=r)<span class="keyword">return</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> x=q[l], i=l<span class="number">-1</span>,j=r+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i&lt;j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">do</span> i++;<span class="keyword">while</span>(q[i]&lt;x);</span><br><span class="line">        <span class="keyword">do</span> j--;<span class="keyword">while</span>(q[j]&gt;x);</span><br><span class="line">        <span class="keyword">if</span>(i&lt;j)<span class="built_in">swap</span>(q[i],q[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">quick_sort</span>(q,l,j);</span><br><span class="line">    <span class="built_in">quick_sort</span>(q,j+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="built_in">scand</span>(<span class="string">&quot;%d&quot;</span>,&amp;q[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">quick_sort</span>(q,<span class="number">0</span>,n<span class="number">-1</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,q[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="Spark是如何划分stage阶段"><a href="#Spark是如何划分stage阶段" class="headerlink" title="Spark是如何划分stage阶段"></a>Spark是如何划分stage阶段</h4><ol><li>生成DAG有向无环图之后，从最后一个rdd往前推，先创建一个stage，它是最后一个stage</li><li>如果遇到了窄依赖就把该rdd加入到stage中，如果遇到了宽依赖，就从宽依赖切开，最后一个stage也就划分结束了</li><li>后面重新创建一个新的stage，还是按照第二步操作继续往前推，一直推到最开始的rdd，整个划分stage也就结束了</li></ol><h4 id="Spark-SQL的执行流程，如何将一个SQL语句转换为任务"><a href="#Spark-SQL的执行流程，如何将一个SQL语句转换为任务" class="headerlink" title="Spark SQL的执行流程，如何将一个SQL语句转换为任务"></a>Spark SQL的执行流程，如何将一个SQL语句转换为任务</h4><ol><li><p>SQL 查询 → 解析树（解析）</p><ul><li>SQL 字符串被解析成 <strong>抽象语法树</strong></li></ul></li><li><p>解析树 → 逻辑计划（分析）</p><ul><li>对解析树进行语法和语义分析，生成 <strong>逻辑计划</strong></li></ul></li><li><p>逻辑计划 → 优化后的逻辑计划（<strong>逻辑优化</strong>）</p><ul><li>通过应用优化规则，生成优化后的 逻辑计划</li></ul></li><li><p>优化后的逻辑计划 → 物理计划（<strong>物理规划</strong>）</p><ul><li>生成多个物理执行计划，选择最优的执行策略</li></ul></li><li><p>物理计划 → 代码生成（代码生成）</p><ul><li><strong>生成高效的 Java 字节码，减少运行时开销</strong></li></ul></li><li><p>代码生成 → 执行任务（执行）</p><ul><li><strong>将任务分配到 Spark 集群的 Executor，进行并行计算，最终返回结果</strong></li></ul></li></ol><h4 id="宽窄依赖，宽依赖阶段会发生什么"><a href="#宽窄依赖，宽依赖阶段会发生什么" class="headerlink" title="宽窄依赖，宽依赖阶段会发生什么"></a>宽窄依赖，宽依赖阶段会发生什么</h4><ul><li><p><strong>窄依赖</strong>（Narrow Dependency）：每个子RDD的<strong>一个分区</strong>只依赖于<strong>父RDD的一个或少数几个分区</strong>，可以直接在<strong>同一个Stage</strong>内计算，<strong>不会触发Shuffle</strong></p></li><li><p><strong>宽依赖</strong>（Wide Dependency）：子RDD的<strong>一个分区可能依赖多个父RDD的分区</strong>，<strong>需要跨节点拉取数据（Shuffle）</strong>，因此会触发<strong>新的Stage</strong></p></li></ul><h2 id="中科智泓"><a href="#中科智泓" class="headerlink" title="中科智泓"></a>中科智泓</h2><h4 id="如果直接筛，可能导致被锁住，有其他办法么"><a href="#如果直接筛，可能导致被锁住，有其他办法么" class="headerlink" title="如果直接筛，可能导致被锁住，有其他办法么"></a>如果直接筛，可能导致被锁住，有其他办法么</h4><ul><li>insert overwrite</li><li>创建临时表，存储去重后的数据，再将该表覆盖到原表</li><li>如果查询慢，考虑数据倾斜，可以用distribute by rand()，提高并行度，这样做的优势是可以避免reduce任务超载，更均匀的分配数据</li></ul><h4 id="SQL中几种删除方式的区别"><a href="#SQL中几种删除方式的区别" class="headerlink" title="SQL中几种删除方式的区别"></a>SQL中几种删除方式的区别</h4><ul><li>delete，是按条件进行删除适合关系型数据库</li><li>drop，是直接删除表结构+表数据</li><li>insert overwrite，hive不支持delete，不会锁表性能更高</li></ul><h4 id="事实表和维度表有什么区别"><a href="#事实表和维度表有什么区别" class="headerlink" title="事实表和维度表有什么区别"></a>事实表和维度表有什么区别</h4><ul><li>事实表的数据量大，其中包含度量数据（如销售额、库存数量、交易金额等）和外键，这些外键与维度表相连</li><li>维度表的数据量比较小，包含的是描述性属性，例如日期、客户名称、产品类型等</li></ul><h4 id="Hive和Spark有什么区别"><a href="#Hive和Spark有什么区别" class="headerlink" title="Hive和Spark有什么区别"></a>Hive和Spark有什么区别</h4><ul><li>Hive 是一个数据仓库工具，主要用于数据的存储、查询和分析。它建立在 Hadoop 之上，提供一个类似 SQL 的查询语言，用于批处理大数据</li><li>Spark是一个分布式计算框架，它是基于内存计算的，速度比Hive用MapReduce作为计算引擎更快</li></ul>]]></content>
      
      
      <categories>
          
          <category> 面经 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 面经 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数仓开发学习笔记</title>
      <link href="/posts/9662cfff.html"/>
      <url>/posts/9662cfff.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="数仓开发"><a href="#数仓开发" class="headerlink" title="数仓开发"></a>数仓开发</h2><h3 id="ODS层（接入层-贴源层）"><a href="#ODS层（接入层-贴源层）" class="headerlink" title="ODS层（接入层&#x2F;贴源层）"></a>ODS层（接入层&#x2F;贴源层）</h3><p>ods层用来对接数据源，同步用的</p><p>全量（full）——状态</p><p>增量（inc）——行为</p><ul><li><p>业务分两大类：全量表和增量表</p></li><li><p>日志文件</p></li><li><p>业务表</p><ul><li>全量表： DataX， 表结构与业务表保持一致<ul><li>mysql ： column[id, name, age]</li><li>data： 1001    zhangsan     30</li><li>hive： column[id, name, age]</li></ul></li><li>增量表： Maxwell<ul><li>JSON<ul><li>最外层JSON对象的属性作为表的字段</li></ul></li></ul></li></ul></li></ul><h3 id="DIM层"><a href="#DIM层" class="headerlink" title="DIM层"></a>DIM层</h3><p>维度层保存维度表，所以建模理论应该遵循维度建模理论</p><p>维度层中的维度表，主要用于统计分析</p><ol><li>数据存储方式应该为列式存储：orc</li><li>数据压缩效率越高越好（时间短）：snappy</li></ol><ul><li><p>维度模型</p><ul><li>维度（状态）表</li><li>事实（行为）表</li></ul></li></ul><p>事实表是用来做统计的</p><p>维度表是用来做分析的</p><p>全量维度表:以天为单位将数据全部同步到维度表的相同时间分区中</p><img src="https://pencil1024.oss-cn-chengdu.aliyuncs.com/imgs/202502251351977.png" alt="image-20250225135111832" style="zoom:67%;" /><ul><li>补全数据<ul><li>补全行： union</li><li>补全列： join</li></ul></li></ul><p>如果不影响结果用left join， 不用join</p><p>分区覆盖：insert overwrite table dim_sku_full partition (dt&#x3D;’2022-06-08’)</p><p>大部分的维度表都是全量的</p><p>shift+alt+鼠标左键可以多光标选中， shift + ctrl + alt可以矩形选中</p><p>行为是用来做统计的，状态是用来做分析的</p><p>实际生产环境中是用脚本来增加数据，没有事务的概念，所以不能回滚</p><p>拉链表的数据源是ods增量表</p><ul><li>增量表<ul><li>maxwell<ul><li>数据格式：json</li><li>同步方式：<ul><li>首日：bootstrap（select）</li><li>每日：insert, update, delete（binlog）</li></ul></li></ul></li></ul></li></ul><p>首日全量， 每日增量</p><p>拉链表其实就是压缩</p><p>写窗口函数</p><p>row_number() over (partition by id order by start_date desc) rn</p><p>date_sub(‘2022-06-09’, 1)天数减1天</p><p>？动态分区操作</p><ul><li><p>规范化<strong>（雪花模型）</strong></p><ul><li>是指使用一系列范式设计数据库的过程，其目的是减少数据冗余，增强数据的一致性。通常情况下，规范化之后，一张表的字段会拆分到多张表。</li></ul></li><li><p>反规范化<strong>（星型模型）</strong></p><ul><li>是指将多张表的数据冗余到一张表，其目的是减少join操作，提高查询性能。在设计维度表时，如果对其进行规范化，得到的维度模型称为雪花模型，如果对其进行反规范化，得到的模型称为星型模型。</li></ul></li></ul><h3 id="DWD层"><a href="#DWD层" class="headerlink" title="DWD层"></a>DWD层</h3><p>英文全称是Data Warehouse Detail</p><p>对ODS层的数据进行加工，为后续的统计分析做准备</p><p>DIM层的主要功能主要是<strong>分析</strong>数据：面向<strong>状态</strong></p><p>DWD层的主要功能主要是<strong>统计</strong>数据：面向<strong>行为</strong></p><p>DWD层的表主要保存的就是业务行为数据， 表的设计需要遵循维度建模理论， 创建的表成为<strong>事实（行为）表</strong></p><p>数据的存储格式：<strong>orc列式存储</strong></p><p>数据的压缩格式：<strong>snappy</strong></p><ul><li>数仓项目所需的所有业务过程及数据域划分详情</li></ul><img src="https://pencil1024.oss-cn-chengdu.aliyuncs.com/imgs/202502261329561.png" alt="image-20250226132943478" style="zoom:67%;" /><p>事实表分类</p><ul><li>事务事实表（绝大多数）</li><li>周期快照事实表</li><li>累计快照事实表</li></ul><p><strong>行为</strong>描述的详细程度称为<strong>粒度</strong></p><ul><li>维度越多，粒度越细</li><li>维度越少，粒度越粗</li></ul><p>了解时间函数</p><ul><li>from_unixtime(ts, ‘yyyy-MM-dd HH:mm:ss’)</li><li>date_format(from_utc_timestamp(ts*1000, ‘GMT+8’), ‘yyyy-MM-dd HH:mm:ss’)</li></ul><h3 id="ADS层"><a href="#ADS层" class="headerlink" title="ADS层"></a>ADS层</h3><p>统计粒度：分析数据的具体角度，称之为统计粒度（站在哪一个角度统计数据）</p><p>指标：客户想要的一个结果数值</p><p>分组聚合的场合下，那些字段可以出现在select子句中</p><ol><li>常量</li><li>聚合函数内的字段</li><li>参与分组的字段</li></ol><p>多个字段参与分组的时候，统计值的含义</p><ol><li>如果多个字段存在上下级，<strong>所属关系</strong>，那么统计结果和<strong>最下级字段</strong>相关，上级字段参与分组纯粹是用于<strong>补全数据</strong><ul><li>所属：例如省份与城市之间的关系</li></ul></li><li>如果多个字段存在<strong>关联关系</strong>，那么统计结果和具有<strong>唯一性字段</strong>相关，其他字段纯粹是用于<strong>补全数据</strong><ul><li>关联：例如（id, name, …）这种</li></ul></li></ol><h3 id="sql"><a href="#sql" class="headerlink" title="sql"></a>sql</h3><p>数据视图只是保留一个调用（sql）</p><p>distinct是随机去重</p><p>对表起别名不需要用as，对字段取别名最好加上as</p><p>union会去重， union all不会去重</p><p>聚集函数</p><ul><li>sum</li><li>max</li><li>min</li><li>avg</li><li>count</li></ul><p>count(*)和count(1)是一个意思，都会扫全表 </p><p>having用在group by后面（having只用于聚合函数）</p><p>hive sql要对表加别名</p><p>join相当于是求交集</p><p><strong>窗口函数</strong></p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- row_number不能排名并列</span></span><br><span class="line"><span class="built_in">row_number</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> user_id <span class="keyword">order</span> <span class="keyword">by</span> pay_amount <span class="keyword">desc</span>) <span class="keyword">as</span> rn</span><br><span class="line"><span class="comment">-- 可以并列，但是会跳过并列后的排名如 1 2 2 4</span></span><br><span class="line"><span class="built_in">rank</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> user_id <span class="keyword">order</span> <span class="keyword">by</span> pay_amount <span class="keyword">desc</span>) <span class="keyword">as</span> rn</span><br><span class="line"><span class="comment">-- 可以并列，不会跳过如 1 2 2 3</span></span><br><span class="line"><span class="built_in">dense_rank</span>() <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> user_id <span class="keyword">order</span> <span class="keyword">by</span> pay_amount <span class="keyword">desc</span>) rn</span><br><span class="line"></span><br><span class="line"><span class="built_in">lead</span>()取下一条</span><br><span class="line"><span class="built_in">lag</span>()取上一条</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>sql里面的字符串下标索引是从1开始的，而不是从0</p><p>trim()函数去除空格</p><h3 id="力扣SQL高频50"><a href="#力扣SQL高频50" class="headerlink" title="力扣SQL高频50"></a>力扣SQL高频50</h3><ul><li><p>判断null写 <strong>is null</strong>，而不是写 <strong>&#x3D;null</strong></p></li><li><p>对于varchar类型的字符串，求字符串长度的函数为 char_length()</p></li><li><p>左连接left 表 on，条件跟在on后面，如果没有的用null补齐</p></li><li><p>datediff是 SQL 中用于<strong>计算两个日期之间的天数差</strong>的函数，DATEDIFF(结束日期, 开始日期)，如果两个参数有任何一个为null则计算结果为null</p></li><li><p>timestampdiff(unit, start_datetime, end_datetime)这个unit是时间单位（second, hour, day…）</p></li><li><p>cross join就是笛卡尔积</p></li><li><p>join on是默认的innner join内连接，只会匹配满足on条件中的行</p></li><li><p>IFNULL(AVG(c.action &#x3D; ‘confirmed’), 0)的意思是如果AVG(c.action &#x3D; ‘confirmed’)为null，则返回0</p></li><li><p>left on左连接，相同的字段不会合并为一列，还是仍然有两列</p></li><li><p>判断一个日期在某个范围之内可以用<strong>between … and …</strong></p></li><li><p>where 只能用来过滤 join之后的结果，不能用来定义join的连接条件</p></li><li><p>在 MySQL 中，<strong>所有子查询都必须有别名</strong>，否则会报错。</p></li><li><p>date_format(date, ‘%Y-%m’)将日期按照年月输出，例如将2019-01-02转化成2019-01</p></li><li><p>格式化函数会在group之前执行，即使在select语句中</p></li><li><p>有 order by 时，distinct 先去重，再排序</p></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span> <span class="built_in">Max</span>(num) <span class="keyword">as</span> num </span><br><span class="line"><span class="keyword">from</span> MyNumbers</span><br><span class="line"><span class="keyword">group</span> <span class="keyword">by</span> num </span><br><span class="line"><span class="keyword">having</span> <span class="built_in">count</span>(num)<span class="operator">=</span><span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">上面的<span class="keyword">sql</span>会有多条数据，因为对分组后的num来说,<span class="built_in">max</span>(num)作用的就是本身</span><br><span class="line"><span class="comment">----------------------------</span></span><br><span class="line">下面的<span class="keyword">sql</span>只会有一条数据，因为是对子查询的整个数据集来返回<span class="built_in">max</span>(num)</span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> <span class="built_in">max</span>(num) <span class="keyword">as</span> num </span><br><span class="line"><span class="keyword">from</span> (</span><br><span class="line">    <span class="keyword">select</span> num</span><br><span class="line">    <span class="keyword">from</span> MyNumbers</span><br><span class="line">    <span class="keyword">group</span> <span class="keyword">by</span> num</span><br><span class="line">    <span class="keyword">having</span> <span class="built_in">count</span>(num)<span class="operator">=</span><span class="number">1</span></span><br><span class="line">) t;</span><br></pre></td></tr></table></figure><p>四舍五入函数用round</p><p>在select中，不能直接在其他计算中使用同一层的字段别名</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">CASE</span></span><br><span class="line">    <span class="keyword">WHEN</span> 条件<span class="number">1</span> <span class="keyword">THEN</span> 结果<span class="number">1</span></span><br><span class="line">    <span class="keyword">WHEN</span> 条件<span class="number">2</span> <span class="keyword">THEN</span> 结果<span class="number">2</span></span><br><span class="line">    ...</span><br><span class="line">    <span class="keyword">ELSE</span> 结果N  <span class="comment">-- (可选)</span></span><br><span class="line"><span class="keyword">END</span> <span class="keyword">AS</span> 列名</span><br></pre></td></tr></table></figure><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- # Write your MySQL query statement below</span></span><br><span class="line"><span class="keyword">select</span> </span><br><span class="line">    <span class="operator">*</span>,</span><br><span class="line">    if(x<span class="operator">+</span>y<span class="operator">&gt;</span>z <span class="keyword">and</span> x<span class="operator">+</span>z<span class="operator">&gt;</span>y <span class="keyword">and</span> y<span class="operator">+</span>z<span class="operator">&gt;</span>x, <span class="string">&#x27;Yes&#x27;</span>, <span class="string">&#x27;No&#x27;</span>) <span class="keyword">as</span> triangle</span><br><span class="line"><span class="keyword">from</span> Triangle;</span><br><span class="line"></span><br><span class="line"><span class="comment">-- 在多条件下case when then else end 比 if 快很多</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">select</span> </span><br><span class="line">    <span class="operator">*</span>,</span><br><span class="line">    <span class="keyword">case</span> </span><br><span class="line">        <span class="keyword">when</span> x<span class="operator">+</span>y<span class="operator">&gt;</span>z <span class="keyword">and</span> x<span class="operator">+</span>z<span class="operator">&gt;</span>y <span class="keyword">and</span> y<span class="operator">+</span>z<span class="operator">&gt;</span>x <span class="keyword">then</span> <span class="string">&#x27;Yes&#x27;</span></span><br><span class="line">        <span class="keyword">else</span>    <span class="string">&#x27;No&#x27;</span></span><br><span class="line">    <span class="keyword">end</span> <span class="keyword">as</span> <span class="string">&#x27;Triangle&#x27;</span></span><br><span class="line"><span class="keyword">from</span> Triangle </span><br></pre></td></tr></table></figure><p>窗口函数（Window Function）是 SQL 中的一类特殊函数，它用于在查询结果中执行计算，但不会影响查询返回的行数。</p><p>跟group by不同的是， group by要合并行，但是窗口函数不会，仍然保留每行的数据</p><p><strong>常见窗口函数</strong>：</p><ul><li>sum() over()：在窗口内求和</li><li>avg() over()：在窗口内求平均</li><li>row_number() over()：计算当前行在窗口内的编号（编号唯一）</li><li>rank() over()：计算当前行在窗口内的排名（相同值的排名一样，后续排名会跳过）</li><li>dense_rank() over()：无跳跃排名</li><li>lag() over()：获取前一行数据</li><li>lead() over()：获取后一行数据</li></ul><p><strong>窗口函数知识点：</strong></p><ul><li>rows 6 preceding：表示当前行及其前6 行组成窗口<ul><li>preceding表示前</li><li>following表示后</li></ul></li></ul><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> employee_id, department, salary, </span><br><span class="line">       <span class="built_in">AVG</span>(salary) <span class="keyword">OVER</span> (<span class="keyword">PARTITION</span> <span class="keyword">BY</span> department) <span class="keyword">AS</span> avg_salary</span><br><span class="line"><span class="keyword">FROM</span> Employees;</span><br></pre></td></tr></table></figure><p>cast(… as signed) 的作用是将 row_number() 的结果转换为 signed类型（有符号整数）</p><p>DESC排序时，NULL值排在最前面（null相当于无限大）</p><ul><li>desc nulls last可以将null值排在最后</li></ul><p>ASC排序时，NULL值排在最后面</p><ul><li>acs nulls first</li></ul><p>union会自动去重</p><p>在mysql中substr对字符串索引的下标从1开始</p><p>date_sub(date, INTERVAL value unit) 从date日期中减去时间</p><p>union all的效率比union更好，因为union有去重的功能（可能底层用缓存来实现去重的逻辑）</p><p>date()函数，返回提取日期时间值的日期部分（去掉时间部分）</p><h4 id="sql经典题"><a href="#sql经典题" class="headerlink" title="sql经典题"></a>sql经典题</h4><ol><li>查询连续登陆的用户<ul><li>思路就是用lag和lead开窗，如果date(log_time)与前一天的差值为1，与后一天的差值为-1，那么就说明是连续的三天</li></ul></li></ol><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">select</span></span><br><span class="line">    <span class="keyword">distinct</span>(user_id)</span><br><span class="line"><span class="keyword">from</span>(</span><br><span class="line">    <span class="keyword">select</span> </span><br><span class="line">        log.user_id,</span><br><span class="line">        <span class="type">date</span>(log_time) <span class="keyword">as</span> <span class="type">time</span>,</span><br><span class="line">        # 与前一天的差值</span><br><span class="line">        datediff(<span class="type">date</span>(log_time), <span class="built_in">lag</span>(<span class="type">date</span>(log_time)) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> user_id <span class="keyword">order</span> <span class="keyword">by</span> <span class="type">date</span>(log_time))) <span class="keyword">as</span> d1, </span><br><span class="line">        # 与后一天的差值</span><br><span class="line">        datediff(<span class="built_in">lead</span>(<span class="type">date</span>(log_time)) <span class="keyword">over</span>(<span class="keyword">partition</span> <span class="keyword">by</span> user_id <span class="keyword">order</span> <span class="keyword">by</span> <span class="type">date</span>(log_time)), <span class="type">date</span>(log_time)) <span class="keyword">as</span> d2</span><br><span class="line">    <span class="keyword">from</span> login_tb log</span><br><span class="line">    <span class="keyword">inner</span> <span class="keyword">join</span> register_tb reg <span class="keyword">on</span> log.user_id<span class="operator">=</span>reg.user_id</span><br><span class="line">) t</span><br><span class="line"><span class="keyword">where</span> d1<span class="operator">=</span><span class="number">1</span> <span class="keyword">and</span> d2<span class="operator">=</span><span class="number">1</span></span><br><span class="line"><span class="keyword">order</span> <span class="keyword">by</span> user_id</span><br></pre></td></tr></table></figure><h3 id="DWS层"><a href="#DWS层" class="headerlink" title="DWS层"></a>DWS层</h3><p>dws层用来预聚合，保存中间计算结果</p><p>dws层的数据存储格式为<strong>orc列式存储</strong>，+  <strong>snappy压缩</strong></p><p>命名规范为dws _ 数据域 _ 统计粒度 _ 业务过程 _ 统计周期（1d&#x2F;nd&#x2F;td）</p><ul><li>1d表示最近1日，nd表示最近n日，td表示历史至今</li></ul><h2 id="大数据组件"><a href="#大数据组件" class="headerlink" title="大数据组件"></a>大数据组件</h2><h3 id="spark"><a href="#spark" class="headerlink" title="spark"></a>spark</h3><p>Spark + Hive &#x3D;&gt; shark &#x3D;&gt; </p><ul><li>Spark on Hive &#x3D;&gt; SparkSQL</li><li>Hive on Spark &#x3D;&gt; Hive -&gt; SQL -&gt; RDD（数据仓库）</li></ul><h3 id="Hive"><a href="#Hive" class="headerlink" title="Hive"></a>Hive</h3><p>Hive是由Facebook开源，基于Hadoop的一个数据仓库工具，可以将结构化的数据文件映射为一张表，并提供类SQL查询功能</p><p>Hive的本质是一个<strong>hadoop客户端</strong>，用于将HQL（Hive SQL）转化成MapReduce程序</p><p>内部表和外部表的区别：</p><ul><li><strong>内部表（管理表）</strong>：意味着Hive会完全接管该表，包括元数据和HDFS中的数据</li><li><strong>外部表</strong>：意味着Hive只接管元数据，而不完全接管HDFS中的数据</li></ul><p>cast(‘111’ as int)函数可以完成显示类型的转换</p><p>建表有</p><ul><li>create table as select 表（CTAS建表）这种方式不能选择创建外部表，所以默认是内部表</li><li>create table like 表</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 数据仓库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hive</title>
      <link href="/posts/7c5f14c6.html"/>
      <url>/posts/7c5f14c6.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Hive学习"><a href="#Hive学习" class="headerlink" title="Hive学习"></a>Hive学习</h2><h3 id="知识概述"><a href="#知识概述" class="headerlink" title="知识概述"></a>知识概述</h3><p>Hive主要核心组件包含两个，一个是元数据的管理，一个是SQL解析器</p><p>启动Hive MetaStore</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 启动 Hive MetaStore 服务</span><br><span class="line">$HIVE_HOME/bin/hive --service metastore &amp;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> Hive </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ifconfig查看没有ens33连不上网络问题解决</title>
      <link href="/posts/4cc8668a.html"/>
      <url>/posts/4cc8668a.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>ifconfig命令后没显示ens33</p><p>今天开启centos7时，连接不上网络，原先是🆗的，使用ifconfig进行查看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# ifconfig</span><br><span class="line">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class="line">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line">        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;</span><br><span class="line">        loop  txqueuelen 1000  (Local Loopback)</span><br><span class="line">        RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">virbr0: flags=4099&lt;UP,BROADCAST,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 192.168.122.1  netmask 255.255.255.0  broadcast 192.168.122.255</span><br><span class="line">        ether 52:54:00:61:46:71  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure><p>接着想重启下网络，报错</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# service network restart</span><br><span class="line">Restarting network (via systemctl):  Job for network.service failed because the control process exited with error code. See &quot;systemctl status network.service&quot; and &quot;journalctl -xe&quot; for details.</span><br><span class="line">                                                           [失败]</span><br></pre></td></tr></table></figure><p>根据提示可输入systemctl status network.service命令查看错误信息，</p><p>目前解决方法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# systemctl stop NetworkManager</span><br><span class="line">[root@localhost ~]# systemctl disable NetworkManager</span><br><span class="line">Removed symlink /etc/systemd/system/multi-user.target.wants/NetworkManager.service.</span><br><span class="line">Removed symlink /etc/systemd/system/dbus-org.freedesktop.NetworkManager.service.</span><br><span class="line">Removed symlink /etc/systemd/system/dbus-org.freedesktop.nm-dispatcher.service.</span><br><span class="line">[root@localhost ~]# service network restart</span><br><span class="line">Restarting network (via systemctl):                        [  确定  ]</span><br><span class="line">[root@localhost ~]# ifconfig</span><br><span class="line">ens33: flags=4163&lt;UP,BROADCAST,RUNNING,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 192.168.147.129  netmask 255.255.255.0  broadcast 192.168.147.255</span><br><span class="line">        inet6 fe80::20c:29ff:fe80:ab1a  prefixlen 64  scopeid 0x20&lt;link&gt;</span><br><span class="line">        ether 00:0c:29:80:ab:1a  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 17  bytes 3006 (2.9 KiB)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 38  bytes 6005 (5.8 KiB)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">lo: flags=73&lt;UP,LOOPBACK,RUNNING&gt;  mtu 65536</span><br><span class="line">        inet 127.0.0.1  netmask 255.0.0.0</span><br><span class="line">        inet6 ::1  prefixlen 128  scopeid 0x10&lt;host&gt;</span><br><span class="line">        loop  txqueuelen 1000  (Local Loopback)</span><br><span class="line">        RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br><span class="line"></span><br><span class="line">virbr0: flags=4099&lt;UP,BROADCAST,MULTICAST&gt;  mtu 1500</span><br><span class="line">        inet 192.168.122.1  netmask 255.255.255.0  broadcast 192.168.122.255</span><br><span class="line">        ether 52:54:00:61:46:71  txqueuelen 1000  (Ethernet)</span><br><span class="line">        RX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        RX errors 0  dropped 0  overruns 0  frame 0</span><br><span class="line">        TX packets 0  bytes 0 (0.0 B)</span><br><span class="line">        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0</span><br></pre></td></tr></table></figure><p>可以发现成功打开了ens33</p>]]></content>
      
      
      <categories>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>四史（中共党史）期末</title>
      <link href="/posts/83024ea3.html"/>
      <url>/posts/83024ea3.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="自我革命"><a href="#自我革命" class="headerlink" title="*自我革命"></a>*自我革命</h2><ol><li>党的十八大以来，“自我革命”一词最早被用于描述全面深化改革</li><li>庆祝中国共产党成立95周年大会，号召全党“以自我革命的政治勇气，着力解决党内存在的各种问题，正式将“自我革命”这一概念运用到了党建领域</li><li>十九届中央纪委六次全会正式提出了党的自我革命的战略思想</li><li>党的二十大再次强调了党的自我革命的战略思想，并就党在新征程上进一步深入推进自我革命作出了重要战略部署</li><li>自我革命是中国共产党区别于其他政党的显著标志，体现马克思主义政党的鲜明品格，是中国共产党保持先进性和纯洁性的重要途径。党的自我革命是我们党跳出历史周期率的第二个答案，并为民族复兴伟业提供坚强保障。</li><li>自我革命是对马克思主义建党思想的运用和发展</li><li>自我革命是由我们党的崇高理想和光荣使命所决定的</li><li>自我革命是对党百余年奋斗历史经验的总结<ul><li>例如，大革命失败后纠正陈独秀右倾机会主义错误，土地革命战争时期纠正””左”倾盲动错误和”左””倾冒险错误，改革开放初期，邓小平同志提出“铁老虎也要拍皮球”，坚决打击腐败现象，为国家现代化建设奠定了坚实基础。</li></ul></li><li>自我革命是党不断祛杂质、强免疫、壮筋骨的需要</li><li>自我革命是对”建设什么样的长期执政的马克思主义政党、怎样建设长期执政的马克思主义政党”时代课题的回答</li><li>自我革命是党实现第二个百年奋斗目标的现实要求</li></ol><h2 id="坚持人民至上"><a href="#坚持人民至上" class="headerlink" title="*坚持人民至上"></a>*坚持人民至上</h2><ol><li>“历史的活动是群众的事业”。马克思、恩格斯指出，历史的发展不是由少数精英或理性所决定的，而是由广大人民群众的实践活动所推动的。</li><li>马克思主义唯物史观认为，人民群众不仅是物质财富的创造者，还是每个时代精神财富的创造主体。</li><li>人类群众还是社会历史变革的主体，无论是生产关系的变革，还是社会制度的更替都离不开群众</li><li><strong>新民主主义革命时期</strong>：在这一阶段，党主要解决了农民的土地问题，实现了“耕者有其田”，为共同富裕奠定了政治前提。</li><li><strong>社会主义过渡时期</strong>：这一阶段的目标是实现新民主主义社会向社会主义社会的过渡。在这个过程中，中国建立了独立的比较完整的工业体系和国民经济体系，为实现共同富裕提供了制度保障和物质技术支撑。</li><li><strong>改革开放以后</strong>：中国共产党带领全国人民进行了一系列经济体制改革和政治体制改革，释放了社会活力，促进了经济发展和社会进步。这些改革成果让人民群众享受到了更多的发展红利和更好的生活水平。</li><li>中国共产党的初心和使命就是为人民服务</li><li>中国共产党在实践中始终贯彻群众路线，坚持从群众中来、到群众中去</li><li>中国共产党的优秀党员和干部始终以人民为中心开展工作</li><li>我们要始终把人民立场作为根本立场，把为人民谋幸福作为根本使命，坚持全心全意为人民服务的根本宗旨。</li></ol><h2 id="坚持胸怀天下"><a href="#坚持胸怀天下" class="headerlink" title="坚持胸怀天下"></a>坚持胸怀天下</h2><ol><li>马克思主义人类解放思想为中国共产党坚持胸怀天下树立了崇高价值理想</li><li>马克思主义世界历史理论为中国共产党坚持胸怀天下打开了宏阔科学视野</li><li>马克思主义共同体思想为中国共产党坚持胸怀天下作出了正确实践指引</li><li>例如“大道之行，天下为公”、“四海之内皆兄弟”都体现了坚持胸怀天下</li><li><strong>新民主主义革命时期</strong>，中国共产党对外交往体现国际视野和世界情怀</li><li><strong>抗战时期</strong>，中国共产党主动作为，努力打开外交局面，积极开展独立自主的抗日外交，推动建立国际反法西斯统一阵线。</li><li><strong>解放战争时期</strong>，进一步加强对外交往与合作，加速了中国革命走向全国胜利的历史进程。</li><li><strong>社会主义革命和建设时期</strong>，以巩固新生政权、推进社会主义事业为目标的大国胸怀。<ul><li>例如和平共处五项原则，求同存异方针</li></ul></li><li><strong>改革开放和社会主义现代化建设新时期</strong>，以更好融入世界、促进自身发展为目标的开放性叙事。把中国的发展同维护世界和平和促进人类进步事业联系起来</li><li><strong>中国特色社会主义新时代</strong>，以主动引领世界、打造新型中国与世界关系为目标的建构性叙事。<ul><li>例如一带一路和构建人类命运共同体</li></ul></li><li>中国革命实现了国家独立和民族解放,鼓舞了一批落后国家和民族争取独立解放,加速了旧殖民主义的退场。是一百多年来中国共产党领导中国人民进行伟大奋斗所积累的宝贵历史经验</li></ol><h2 id="党的理论创新"><a href="#党的理论创新" class="headerlink" title="党的理论创新"></a>党的理论创新</h2><p>党的理论创新基本经验</p><ol><li>坚持马克思主义、发展马克思主义、以科学态度对待马克思主义是理论创新的根本原则;</li><li>解放思想、实事求是、与时俱进是理论创新的首要前提和基本保证;</li><li>坚持走群众践线、尊重人民群众首创精神是理论创新的基本途径;</li><li>不断从自身经验和国外历史经验中汲取智慧和营养，形成新的理论创造，是中国共产党理论创新的内在要求;</li><li>不断根据实践的要求进行创新，以理论创新的成果不断指导实践,是中国共产党理论创新的根本目的;</li></ol><p>根本要求：</p><ol><li>与时俱进是马克思主义的理论品质，应时而生是马克思主义的显著特征;</li><li>理论是实践的产物，实践是理论的来源</li><li>理论不仅来源于实践, 而且还要反映作为实践主体的最广大人民群众的呼声和要求;</li><li>马克思主义理论具有强大生命力的根本原因就在于它有与时俱进的理论品质;</li></ol>]]></content>
      
      
      <categories>
          
          <category> 课程学习 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>VS Code配置C/C++环境</title>
      <link href="/posts/e222ce2f.html"/>
      <url>/posts/e222ce2f.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="VS-Code配置C-C-环境"><a href="#VS-Code配置C-C-环境" class="headerlink" title="VS Code配置C&#x2F;C++环境"></a>VS Code配置C&#x2F;C++环境</h2><h3 id="MinGW下载与配置"><a href="#MinGW下载与配置" class="headerlink" title="MinGW下载与配置"></a>MinGW下载与配置</h3><p>配置好环境变量之后，用<code>g++ --version</code>来验证是否成功安装</p><h4 id="vscode下4个json文件配置"><a href="#vscode下4个json文件配置" class="headerlink" title=".vscode下4个json文件配置"></a>.vscode下4个json文件配置</h4><p>在.vscode文件夹下创建四个文件，文件名如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">c_cpp_properties.json</span><br><span class="line">launch.json</span><br><span class="line">settings.json</span><br><span class="line">tasks.json</span><br></pre></td></tr></table></figure><p><img src="https://pencil1024.oss-cn-chengdu.aliyuncs.com/imgs/202412031945515.png" alt="image-20241203194528450"></p><p><strong>c_cpp_properties.json</strong></p><p>​    <code>注意事项：</code></p><p>​    1）windowsSdkVersion的查询方法： Win+R组合键打开运行对话框，输入cmd，在终端中输入VER。经查询，本人计算机的windowsSdkVersion为10.0.26100.2454</p><p>​    2）compilerPath需要配置成g++的安装路径。本人的安装路径为C:&#x2F;Program Files (x86)&#x2F;Dev-Cpp&#x2F;MinGW64&#x2F;bin&#x2F;g++.exe</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;configurations&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;name&quot;: &quot;Win64&quot;,</span><br><span class="line">        &quot;includePath&quot;: [&quot;$&#123;workspaceFolder&#125;/**&quot;],</span><br><span class="line">        &quot;defines&quot;: [&quot;_DEBUG&quot;, &quot;UNICODE&quot;, &quot;_UNICODE&quot;],</span><br><span class="line">        &quot;windowsSdkVersion&quot;: &quot;10.0.26100.2454&quot;,//改成自己的</span><br><span class="line">        &quot;compilerPath&quot;: &quot;C:/Program Files (x86)/Dev-Cpp/MinGW64/bin/g++.exe&quot;,   //改成自己的路径</span><br><span class="line">        &quot;cStandard&quot;: &quot;c11&quot;,</span><br><span class="line">        &quot;cppStandard&quot;: &quot;c++11&quot;,</span><br><span class="line">        &quot;intelliSenseMode&quot;: &quot;gcc-x64&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;version&quot;: 4</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>launch.json</strong></p><p>​    <code>注意事项：</code></p><p>​    miDebuggerPath需要配置成gdb的安装路径。本人的安装路径为C:&#x2F;Program Files (x86)&#x2F;Dev-Cpp&#x2F;MinGW64&#x2F;bin&#x2F;gdb.exe</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;version&quot;: &quot;0.2.0&quot;,</span><br><span class="line">    &quot;configurations&quot;: [</span><br><span class="line">      &#123;</span><br><span class="line">        &quot;name&quot;: &quot;(gdb) Launch&quot;, </span><br><span class="line">        &quot;type&quot;: &quot;cppdbg&quot;, </span><br><span class="line">        &quot;request&quot;: &quot;launch&quot;, </span><br><span class="line">        &quot;program&quot;: &quot;$&#123;fileDirname&#125;\\$&#123;fileBasenameNoExtension&#125;.exe&quot;, </span><br><span class="line">        &quot;args&quot;: [], </span><br><span class="line">        &quot;stopAtEntry&quot;: false,</span><br><span class="line">        &quot;cwd&quot;: &quot;$&#123;workspaceRoot&#125;&quot;,</span><br><span class="line">        &quot;environment&quot;: [],</span><br><span class="line">        &quot;externalConsole&quot;: true, </span><br><span class="line">        &quot;MIMode&quot;: &quot;gdb&quot;,</span><br><span class="line">        &quot;miDebuggerPath&quot;: &quot;C:/Program Files (x86)/Dev-Cpp/MinGW64/bin/gdb.exe&quot;,//改成自己的路径</span><br><span class="line">        &quot;preLaunchTask&quot;: &quot;g++&quot;,</span><br><span class="line">        &quot;setupCommands&quot;: [</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;description&quot;: &quot;Enable pretty-printing for gdb&quot;,</span><br><span class="line">            &quot;text&quot;: &quot;-enable-pretty-printing&quot;,</span><br><span class="line">            &quot;ignoreFailures&quot;: true</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>settings.json</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;files.associations&quot;: &#123;</span><br><span class="line">      &quot;*.py&quot;: &quot;python&quot;,</span><br><span class="line">      &quot;iostream&quot;: &quot;cpp&quot;,</span><br><span class="line">      &quot;*.tcc&quot;: &quot;cpp&quot;,</span><br><span class="line">      &quot;string&quot;: &quot;cpp&quot;,</span><br><span class="line">      &quot;unordered_map&quot;: &quot;cpp&quot;,</span><br><span class="line">      &quot;vector&quot;: &quot;cpp&quot;,</span><br><span class="line">      &quot;ostream&quot;: &quot;cpp&quot;,</span><br><span class="line">      &quot;new&quot;: &quot;cpp&quot;,</span><br><span class="line">      &quot;typeinfo&quot;: &quot;cpp&quot;,</span><br><span class="line">      &quot;deque&quot;: &quot;cpp&quot;,</span><br><span class="line">      &quot;initializer_list&quot;: &quot;cpp&quot;,</span><br><span class="line">      &quot;iosfwd&quot;: &quot;cpp&quot;,</span><br><span class="line">      &quot;fstream&quot;: &quot;cpp&quot;,</span><br><span class="line">      &quot;sstream&quot;: &quot;cpp&quot;,</span><br><span class="line">      &quot;map&quot;: &quot;c&quot;,</span><br><span class="line">      &quot;stdio.h&quot;: &quot;c&quot;,</span><br><span class="line">      &quot;algorithm&quot;: &quot;cpp&quot;,</span><br><span class="line">      &quot;atomic&quot;: &quot;cpp&quot;,</span><br><span class="line">      &quot;bit&quot;: &quot;cpp&quot;,</span><br><span class="line">      &quot;cctype&quot;: &quot;cpp&quot;,</span><br><span class="line">      &quot;clocale&quot;: &quot;cpp&quot;,</span><br><span class="line">      &quot;cmath&quot;: &quot;cpp&quot;,</span><br><span class="line">      &quot;compare&quot;: &quot;cpp&quot;,</span><br><span class="line">      &quot;concepts&quot;: &quot;cpp&quot;,</span><br><span class="line">      &quot;cstddef&quot;: &quot;cpp&quot;,</span><br><span class="line">      &quot;cstdint&quot;: &quot;cpp&quot;,</span><br><span class="line">      &quot;cstdio&quot;: &quot;cpp&quot;,</span><br><span class="line">      &quot;cstdlib&quot;: &quot;cpp&quot;,</span><br><span class="line">      &quot;cstring&quot;: &quot;cpp&quot;,</span><br><span class="line">      &quot;ctime&quot;: &quot;cpp&quot;,</span><br><span class="line">      &quot;cwchar&quot;: &quot;cpp&quot;,</span><br><span class="line">      &quot;exception&quot;: &quot;cpp&quot;,</span><br><span class="line">      &quot;ios&quot;: &quot;cpp&quot;,</span><br><span class="line">      &quot;istream&quot;: &quot;cpp&quot;,</span><br><span class="line">      &quot;iterator&quot;: &quot;cpp&quot;,</span><br><span class="line">      &quot;limits&quot;: &quot;cpp&quot;,</span><br><span class="line">      &quot;memory&quot;: &quot;cpp&quot;,</span><br><span class="line">      &quot;random&quot;: &quot;cpp&quot;,</span><br><span class="line">      &quot;set&quot;: &quot;cpp&quot;,</span><br><span class="line">      &quot;stack&quot;: &quot;cpp&quot;,</span><br><span class="line">      &quot;stdexcept&quot;: &quot;cpp&quot;,</span><br><span class="line">      &quot;streambuf&quot;: &quot;cpp&quot;,</span><br><span class="line">      &quot;system_error&quot;: &quot;cpp&quot;,</span><br><span class="line">      &quot;tuple&quot;: &quot;cpp&quot;,</span><br><span class="line">      &quot;type_traits&quot;: &quot;cpp&quot;,</span><br><span class="line">      &quot;utility&quot;: &quot;cpp&quot;,</span><br><span class="line">      &quot;xfacet&quot;: &quot;cpp&quot;,</span><br><span class="line">      &quot;xiosbase&quot;: &quot;cpp&quot;,</span><br><span class="line">      &quot;xlocale&quot;: &quot;cpp&quot;,</span><br><span class="line">      &quot;xlocinfo&quot;: &quot;cpp&quot;,</span><br><span class="line">      &quot;xlocnum&quot;: &quot;cpp&quot;,</span><br><span class="line">      &quot;xmemory&quot;: &quot;cpp&quot;,</span><br><span class="line">      &quot;xstddef&quot;: &quot;cpp&quot;,</span><br><span class="line">      &quot;xstring&quot;: &quot;cpp&quot;,</span><br><span class="line">      &quot;xtr1common&quot;: &quot;cpp&quot;,</span><br><span class="line">      &quot;xtree&quot;: &quot;cpp&quot;,</span><br><span class="line">      &quot;xutility&quot;: &quot;cpp&quot;,</span><br><span class="line">      &quot;stdlib.h&quot;: &quot;c&quot;,</span><br><span class="line">      &quot;string.h&quot;: &quot;c&quot;</span><br><span class="line">    &#125;,</span><br><span class="line">    &quot;editor.suggest.snippetsPreventQuickSuggestions&quot;: false,</span><br><span class="line">    &quot;aiXcoder.showTrayIcon&quot;: true</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p><strong>tasks.json</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;tasks&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;type&quot;: &quot;cppbuild&quot;,</span><br><span class="line">            &quot;label&quot;: &quot;C/C++: g++.exe 生成活动文件&quot;,</span><br><span class="line">            &quot;command&quot;: &quot;C:\\Program Files (x86)\\Dev-Cpp\\MinGW64\\bin\\g++.exe&quot;,//改成自己的路径</span><br><span class="line">            &quot;args&quot;: [</span><br><span class="line">                &quot;-std=c++11&quot;,//记得加</span><br><span class="line">&quot;-stdlib=libc++&quot;,//记得加</span><br><span class="line">                &quot;-fdiagnostics-color=always&quot;,</span><br><span class="line">                &quot;-g&quot;,</span><br><span class="line">                &quot;$&#123;file&#125;&quot;,</span><br><span class="line">                &quot;-o&quot;,</span><br><span class="line">                &quot;$&#123;fileDirname&#125;\\$&#123;fileBasenameNoExtension&#125;.exe&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;options&quot;: &#123;</span><br><span class="line">                &quot;cwd&quot;: &quot;$&#123;fileDirname&#125;&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;problemMatcher&quot;: [</span><br><span class="line">                &quot;$gcc&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;group&quot;: &#123;</span><br><span class="line">                &quot;kind&quot;: &quot;build&quot;,</span><br><span class="line">                &quot;isDefault&quot;: true</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;detail&quot;: &quot;调试器生成的任务。&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ],</span><br><span class="line">    &quot;version&quot;: &quot;2.0.0&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="VScode编写C-之解决cin输入问题"><a href="#VScode编写C-之解决cin输入问题" class="headerlink" title="VScode编写C++之解决cin输入问题"></a>VScode编写C++之解决cin输入问题</h3><p>找到左下角齿轮，选择设置</p><img src="https://pencil1024.oss-cn-chengdu.aliyuncs.com/imgs/202412031958559.png" alt="image-20241203195802521" style="zoom:80%;" /><p>输入<code>run in terminal</code>，将下图的地方打钩</p><img src="https://pencil1024.oss-cn-chengdu.aliyuncs.com/imgs/202412031959386.png" alt="image-20241203195900353" style="zoom:80%;" /><h3 id="在vscode中添加c-11标准"><a href="#在vscode中添加c-11标准" class="headerlink" title="在vscode中添加c++11标准"></a>在vscode中添加c++11标准</h3><ol><li><p>点击文件-首选项-设置</p></li><li><p>设置中搜code-runner，左侧扩展中找到Run Code configuration，右侧找到Code-runner：Executor Map，打开该项下的在setting.json中编辑</p></li></ol><img src="https://pencil1024.oss-cn-chengdu.aliyuncs.com/imgs/202412032004649.png" alt="image-20241203200424607" style="zoom:80%;" /><ol start="3"><li>在图示位置添加-std&#x3D;c++11，保存</li></ol><img src="https://pencil1024.oss-cn-chengdu.aliyuncs.com/imgs/202412032006058.png" alt="image-20241203200624018" style="zoom:80%;" /><ol start="4"><li>找到vscode配置c++环境时的task.json，并在图示位置添加-std&#x3D;c++11，这里刚刚已经配置过了</li></ol><img src="https://pencil1024.oss-cn-chengdu.aliyuncs.com/imgs/202412032007057.png" alt="image-20241203200753026" style="zoom:80%;" /><h3 id="vscode隐藏-class-exe等不必要的文件"><a href="#vscode隐藏-class-exe等不必要的文件" class="headerlink" title="vscode隐藏.class .exe等不必要的文件"></a>vscode隐藏.class .exe等不必要的文件</h3><ol><li>打开vscode并且依次打开<code>文件</code>&#x3D;&gt;<code>首选项</code>&#x3D;&#x3D;&gt;<code>设置</code></li><li>输入<code>files.exclude</code></li><li>添加自己想要隐藏的文件类型</li></ol><img src="https://pencil1024.oss-cn-chengdu.aliyuncs.com/imgs/202412032010990.png" alt="image-20241203201007956" style="zoom:80%;" /><p>参考博客：</p><p>[1]  <a href="https://blog.csdn.net/real86/article/details/143817763">Visual Studio Code(VS Code)配置C&#x2F;C++环境_vscode-CSDN博客</a></p><p>[2]  <a href="https://blog.csdn.net/weixin_44915520/article/details/123369846">一句话 | VScode编写C++之解决cin输入问题_vscode cin怎么输入-CSDN博客</a></p><p>[3]  <a href="https://blog.csdn.net/bihhammer/article/details/129425044">【c&#x2F;c++】在vscode中添加c++11标准（利用code-runner扩展）_vscode c++11-CSDN博客</a></p><p>[4]  <a href="https://blog.csdn.net/qq_51714354/article/details/121011685">vscode隐藏.class .exe等不必要的文件_vscode隐藏exe-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>软件设计师备考</title>
      <link href="/posts/421d5156.html"/>
      <url>/posts/421d5156.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="软考知识概括"><a href="#软考知识概括" class="headerlink" title="软考知识概括"></a>软考知识概括</h2><ol><li><p>在冯诺依曼结构体系中，程序指令和数据存在同一个存储器中</p></li><li><p>存储器分类：</p><ul><li>DRAM集成率相对较高，功耗相对较小，需要动态刷新</li><li>SRAM集成率相对较低，功耗相对较大，不需要动态刷新</li></ul></li><li><p>CPU内部的子部件</p><ul><li>通用寄存器</li><li>累加器</li><li>程序计数器</li></ul></li><li><p>CISC普遍采用<strong>微程序控制器</strong>，RISC普遍采用<strong>硬布线控制器</strong></p></li><li><p>I&#x2F;O接口与打印机交换信息采用基于缓存池的<strong>异步方式</strong></p><ul><li>FTP是可靠但不安全的文件传输协议，TFTP是不可靠且不安全的文件传输协议</li><li>ICMP是Internet控制报文协议，与文件传输无关</li><li>SFTP是SSH文件传输协议</li><li>TLS是安全传输层协议</li><li>TCP是消息传输协议</li></ul></li><li><p>DDOS是一种分布式拒绝服务攻击，这种攻击<strong>不属于</strong>计算机病毒</p><ul><li>永恒之蓝、蠕虫、特洛伊木马都是计算机病毒</li><li>杀毒软件不能有效防止网站信息被篡改</li></ul></li><li><p>在出口防火墙上配置ACL（访问控制列表）可以阻止外部未授权用户访问内部网络</p></li><li><p>入侵检测系统防护不了SQL注入</p></li><li><p><strong>商标权</strong>的保护期是可以延长的</p></li><li><p>软件许可使用分为三种</p><ul><li>独占：软件著作人<strong>不得</strong>将软件使用权授予第三方，且软件著作人不能使用该软件</li><li>独家：<strong>不可</strong>授予第三方，自己<strong>可以</strong>使用该软件</li><li>普通：<strong>可以</strong>授予第三方，自己<strong>可以</strong>使用该软件</li></ul></li><li><p>风险控制的四种方法</p><ul><li>风险回避</li><li>损失控制</li><li>风险转移</li><li>风险保留</li><li><strong>没有消除风险</strong></li></ul></li><li><p>前中后缀表达式求值</p><ul><li>前缀表达式：从后往前，后入栈的先算</li><li>后缀表达式：从前往后，先入栈的先算</li></ul></li><li><p>网络互联设备中：</p><ul><li>中继器（物理层）：作用是对接受的信号进行再生放大，以延长传输的距离</li><li>网桥（数据链路层）：可以识别MAC地址，进行帧转发</li><li>交换机（数据链路层）：由硬件构成的多端口网桥</li><li>路由器（网络层）：可以识别IP地址，进行数据包的转发</li></ul></li><li><p>层次化局域网模型中，核心层的主要功能是将分组从一个区域高速地转发到另一个区域</p></li><li><p>数据库安全机制中，通过提供<strong>存储过程</strong>供第三方开发人员调用进行数据更新，从而保证数据库的关系模式不被第三方所获取</p></li><li><p>采用循环队列的优点是：<strong>入队和出队操作都不需要移动队列中的其他元素</strong></p></li><li><p>以编译方式翻译C&#x2F;C++源程序的过程中，类型检查在<strong>语义分析</strong>阶段处理</p></li><li><p>高速缓存（Cache）与主存间的地址映射由硬件自动完成</p></li><li><p>RIP（路由信息协议），内部网关协议</p><ul><li>OSPF（开放式最短路径优先），内部网关协议</li><li>BGP（边界网关协议），外部网关协议</li><li>UDP，传输层协议</li></ul></li><li><p>著作权中，修改权、署名权、保护作品完整权都是<strong>永久保护</strong>的</p></li><li><p>数据字典会对数据流图中的元素进行定义说明</p></li><li><p>C&#x2F;C++语言为某个应用编写的程序，经过 预处理-&gt;编译-&gt;汇编-&gt;链接 后形成可执行程序 </p></li><li><p>通信内聚：所有处理元素集中在一个数据结构的区域上</p></li><li><p>二分查找的前提条件是：顺序存储，且有序排列</p></li><li><p>PCI总线是<strong>并行内总线</strong>，SCSI总线是<strong>并行外总线</strong></p></li><li><p>中断方式与DMA方式都可实现外设与CPU之间的并行工作</p></li><li><p><strong>DRAM</strong>是一种需要通过周期性刷新来保持数据的存储器件</p></li><li><p>IGMP用来进行组播组成员信息的交互</p><ul><li>SSH、Telent、RFB都能用于远程登录或控制</li></ul></li><li><p>数据流图表现的是<strong>数据流</strong>，而不是控制流</p></li><li><p>算术表达式采用<strong>中序遍历</strong>（左、根、右）</p></li><li><p>系统测试阶段的测试目标来自于<strong>需求分析</strong></p></li><li><p>采用三级模式结构的数据库系统中，如果对一个表创建聚簇索引，那么改变的是数据库的<strong>内模式</strong></p></li><li><p>采用DMA传送数据时，每传送一个数据都需要占用一个<strong>存储周期</strong></p></li><li><p>DMA传送结束为<strong>中断</strong>、除运算除数为0为<strong>异常</strong></p></li><li><p>SQL注入攻击的首要目标是<strong>获得数据库的权限</strong></p></li><li><p>IPSec对IP数据报文进行加密</p></li><li><p>内容耦合：一个模块直接使用另一个模块的内部数据，或通过非正常入口而转入另一个模块内部</p></li><li><p>接口设计是在<strong>概要设计阶段</strong></p></li><li><p>面向对象分析执行的活动顺序：认定对象、组织对象、描述对象间的相互作用、确定对象的操作、定义对象内部信息</p></li><li><p>根据ER图转换规则，<strong>多对多</strong>的联系需要转换成独立的关系模式，重新建类</p></li><li><p>对稀疏矩阵压缩的三种方法：三元组顺序表、行逻辑连接的顺序表、十字链表</p></li><li><p>第一趟排序结束后，一定能将序列中的某个元素在最终有序序列中的位置确定下来</p><ul><li>冒泡排序</li><li>简单选择排序</li><li>堆排序</li><li>快速排序</li></ul></li><li><p>IPv6的地址长度为128位、IPv4的地址长度为32位，IPV6的地址空间是IPV4的2^96倍</p></li><li><p>浏览器默认的应用层协议是HTTP</p></li><li><p>在电子邮件服务协议中，smtp是发信服务器的协议，pop3是收信服务器的协议</p></li><li><p>资源有限的情况下优先保障<strong>高优先级</strong>的目标</p></li><li><p>采用二维表格结构表达实体类型及实体间联系的数据模型是<strong>关系模型</strong></p></li><li><p>数据库系统采用三级模式结构：外模式、模式、内模式，分别代表视图、基本表、存储文件</p></li><li><p>数据的物理独立性和逻辑独立性分别是通过修改模式与内模式之间的映像、外模式与模式之间的映像</p></li><li><p>面向对象<strong>分析</strong>，执行的活动顺序是：认定对象、组织对象、描述对象间的相互作用、确定对象的操作</p></li><li><p>面向对象<strong>设计</strong>，包含的主要活动是：识别类及对象、定义属性、定义服务、识别关系、识别包</p></li><li><p>采用设计模式以复用成功的设计</p></li><li><p>公钥（非对称加密算法）</p><ul><li>RSA、ECC（椭圆曲线加密算法）、DSA（公钥数字签名）</li></ul></li><li><p>私钥（对称加密）</p><ul><li>DES、3DES、RC-5、IDEA、AES、RC4</li></ul></li><li><p>kerberos系统中可通过在报文中加入<strong>时间戳</strong>来防止重放攻击</p></li><li><p>用户获取网站的数字证书后通过<strong>CA的公钥</strong>验证<strong>CA的签名</strong>，从而确认证书的有效性，然后验证网站的真伪、</p></li><li><p>外部实体一般为组织机构、人员、第三方系统</p></li><li><p>词法分析的输出是<strong>记号流</strong>，也是语法分析的<strong>输入</strong>，词法分析的任务是把源程序的字符串转换成单词符号序列  </p></li><li><p>在磁盘调度管理中通常先进行<strong>移臂调度</strong>，再进行<strong>旋转调度</strong></p></li><li><p>敏捷开发方法scrum的步骤<strong>不</strong>包括Refactoring</p></li><li><p>在需求分析阶段就要测试设计</p></li><li><p>软件实体可以扩展但是不可修改属于<strong>开放封闭</strong>设计原则</p></li><li><p>建立连接进行可靠通信在TCP&#x2F;IP和OSI&#x2F;RM中都是<strong>传输层</strong></p></li><li><p>MIME协议扩展了电子邮件标准，能够支持多媒体数据</p></li><li><p>硬盘所属的存储类别是<strong>辅存</strong></p></li><li><p>管理键盘最适合采用的I&#x2F;O控制方式是<strong>中断</strong></p></li><li><p>常见的Hash算法的是MD5、SHA、SM3</p></li><li><p>直接主存存取（DMA）是指数据在主存与外设之间直接建立数据通路</p></li><li><p>循环冗余检验（CRC）采用的是模二除法运算</p></li><li><p>RISC的寻址方式比较单一，多寄存器寻址</p></li><li><p>数据流图建模应遵循自顶向下、从抽象到具体</p></li><li><p>PV操作可以实现资源的互斥使用</p></li><li><p>在UML图中，<strong>部署图</strong>用于展示所交付系统中软件组件和硬件之间的物理关系</p></li><li><p>TCP和UDP协议均提供了端口寻址的能力</p></li><li><p>在微机系统重，BIOS（基本输入输出系统）保存在主板上的ROM中</p></li><li><p>MD5是摘要算法，对任意得到的结果长度为128位</p></li><li><p>有可能无限期拥有的知识产权是<strong>商标权</strong></p></li><li><p>软件维护工具<strong>不</strong>包括：配置管理</p></li><li><p>设计模式</p><ul><li><p><strong>工厂方法（创建型类）</strong>：定义一个用于创建对象的接口，让子类决定实例化哪一个类</p><p>​适用于：</p><ul><li>当一个类不知道它所必须创建的对象的类的时候</li><li><code>当一个类希望由它的子类来指定它所创建的对象的时候</code></li></ul></li><li><p><strong>抽象工厂（创建型对象）</strong>：提供一个创建一系列相关或相互依赖对象的接口，而无须指定它们具体的类</p><p>​适用于：</p><ul><li>一个系统要独立于它的产品的创建、<strong>组合</strong>和表示时</li><li>一个系统要由多个产品系列中的一个来配置时</li><li><code>当要强调一系列相关的产品对象的设计以便进行联合使用时</code></li><li>当提供一个产品类库，只想显示它们的接口而不是实现时</li></ul></li><li><p><strong>生成器（创建型对象）</strong>：将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示</p><p>​适用于：</p><ul><li>当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时</li><li><code>当构造过程必须允许被构造的对象有不同的表示时</code></li></ul></li><li><p><strong>原型（创建型对象）</strong>：用原型实例指定创建对象的种类，并且通过<strong>复制</strong>这些原型创建新的对象</p><p>​适用于：</p><ul><li>当一个系统应该独立于它的产品创建、<strong>构成</strong>和表示时</li><li>当要实例化的类是在运行时刻指定时，例如通过动态装载</li><li>为了避免创建一个与产品类层次平行的工厂类层次时</li><li>当一个类的实例只能有几个不同状态组合中的一种时。建立相应数目的原型并克隆它们，可能比每次用合适的状态手工实例化该类更方便一些。</li></ul></li><li><p><strong>适配器（结构型）</strong>：将一个类的接口<strong>转换</strong>成客户希望的另外一个接口。Adapter模式使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p><p>​适用于：</p><ul><li>想使用一个已经存在的类，而它的接口不符合要求</li><li>(仅适用于对象Adapter)想使用一个已经存在的子类，但是不可能对每一个都进行子类化以匹配它们的接口。对象适配器可以适配它的父类接口。</li></ul></li><li><p><strong>桥接（结构型对象）</strong>：将抽象部分与其实现部分<strong>分离</strong>,使它们都可以<strong>独立地</strong>变化</p><p>​适用于：</p><ul><li>不希望在抽象和它的实现部分之间有一个固定的绑定关系。例如，这种情况可能是因为，在程序运行时刻实现部分应可以被选择或者切换。</li><li><code>对一个抽象的实现部分的修改应对客户不产生影响，即客户代码不必重新编译</code></li><li>想在多个对象间共享实现（可能使用引用计数)，但同时要求客户并不知道这一点</li><li>类的抽象以及它的实现都应该可以通过生成子类的方法加以扩充。这是 Bridge模式使得开发者可以对不同的抽象接口和实现部分进行组合，并分别对它们进行扩充。</li></ul></li><li><p><strong>组合（结构型对象）</strong>：将对象组合成树型结构以表示“<strong>部分-整体</strong>”的层次结构。Composite使得用户对单个对象和组合对象的使用具有一致性。</p><p>​适用于：</p><ul><li>想表示对象的部分-整体层次结构</li><li>希望用户忽略组合对象与单个对象的不同,用户将统一地使用组合结构中的所有对象</li></ul></li><li><p><strong>装饰器（结构型对象）</strong>：动态地给一个对象添加一些<strong>额外的职责</strong>。就增加功能而言，Decorator模式比生成子类更加灵活。</p><p>​适用于：</p><ul><li>在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责</li><li>处理那些可以撤销的职责</li><li>当不能采用生成子类的方式进行扩充时。一种情况是，可能有大量独立的扩展，为支持每一种组合将产生大量的子类，使得子类数目呈爆炸性增长。另一种情况可能是，由于类定义被隐藏，或类定义不能用于生成子类。</li></ul></li><li><p><strong>享元（结构型对象）</strong>：运用共享技术有效地支持<strong>大量细粒度</strong>的对象</p><p>​适用于：</p><ul><li>一个应用程序使用了大量的对象</li><li>完全由于使用大量的对象，造成很大的存储开销</li><li>对象的大多数状态都可变为外部状态</li></ul></li><li><p><strong>外观（结构型对象）</strong>：为子系统中的一组接口提供一个一致的界面，Facade模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。</p><p>​适用于：</p><ul><li>客户程序与抽象类的实现部分之间存在着<strong>很大的依赖性</strong></li><li>当需要构建一个层次结构的子系统时，使用Facade模式定义子系统中每层的入口点</li></ul></li><li><p><strong>责任链（行为型对象）</strong>：使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链传递该请求，<strong>直到有一个对象处理它为止</strong>。</p><p>​适用于：</p><ul><li>有多个的对象可以处理一个请求，哪个对象处理该请求运行时刻自动确定</li><li>向在不明确指定接收者的情况下向多个对象中的一个提交一个请求</li><li>可处理一个请求的对象集合应被动态指定</li></ul></li><li><p><strong>命令（行为型对象）</strong>：将一个<strong>请求</strong>封装为一个对象，从而使得可以用不同的请求对客户进行参数化;对请求排队或记录请求日志，以及支持可撤销的操作。</p><p>​适用于：</p><ul><li>抽象出待执行的动作以参数化某对象</li><li>在不同的时刻指定、排列和执行请求</li><li>支持取消操作</li><li>支持修改日志</li></ul></li><li><p><strong>迭代器（行为型对象）</strong>：提供一种方法<strong>顺序访问</strong>一个聚合对象中的各个元素，且<strong>不</strong>需要暴露该对象的<strong>内部</strong>表示</p><p>​适用于：</p><ul><li>访问一个聚合对象的内容而无须暴露它的内部表示</li><li>支持对聚合对象的多种遍历</li><li>为遍历不同的聚合结构提供一个统一的接口</li></ul></li><li><p><strong>备忘录（行为型对象）</strong>：在<strong>不破坏封装性</strong>的前提下捕获一个对象的内部状态，并在对象之外保存这个状态。这样以后就可以将对象<strong>恢复</strong>到原先保存的状态。</p><p>​适用于：</p><ul><li>必须保存一个对象在某一个时刻的（部分）状态，这样以后需要时它才能恢复到先前的状态。</li><li>如果一个用接口来让其他对象直接得到这些状态，将会暴露对象的实现细节并破坏对象的封装性</li></ul></li><li><p><strong>观察者（行为型对象）</strong>：定义对象间的一种<strong>一对多</strong>的依赖关系，当<strong>一个</strong>对象的状态发生<strong>改变</strong>时，<strong>所有依赖于它的对象</strong>都得到通知并<strong>被自动更新</strong>。</p><p>​适用于：</p><ul><li>当一个抽象模型有两个方面，其中一个方面依赖于另一个方面，将这两者封装在独立的对象中以使它们可以各自独立地改变和复用。</li><li>当对一个对象的改变需要同时改变其他对象，而不知道具体有多少对象有待改变时</li><li><code>当一个对象必须通知其他对象，而它又不能假定其他对象是谁，即不希望这些对象是紧耦合的。</code></li></ul></li><li><p><strong>状态（行为型对象）</strong>：允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类</p><p>​适用于：</p><ul><li>一个对象的行为决定于它的<strong>状态</strong>，并且它必须在运行时刻根据状态改变它的行为</li><li>一个操作中含有庞大的多分支的条件语句，且这些分支依赖于该对象的状态。这个状态常用一个或多个枚举常量表示。通常，有多个操作包含这一相同的条件结构。State模式将每一个条件分支放入一个独立的类中。这使得开发者可以根据对象自身的情况将对象的状态作为一个对象，这一对象可以不依赖于其他对象独立变化。</li></ul></li><li><p><strong>策略（行为型对象）</strong>：定义一系列的算法，把它们一个个<strong>封装</strong>起来，并且使它们可以<strong>相互替换</strong>。此模式使得算法可以<strong>独立于</strong>使用它们的客户而变化。</p><p>​适用于：</p><ul><li>许多相关的类仅仅是行为有异</li><li>需要使用一个算法的不同变体</li><li><code>算法使用客户不应该知道的数据。可使用策略模式以避免暴露复杂的、与算法相关的数据结构。</code></li><li>一个类定义了多种行为,并且这些行为在这个类的操作中以多个条件语句的形式出现,将相关的条件分支移入它们各自的Strategy类中，以代替这些条件语句。</li></ul></li><li><p><strong>访问者（行为型对象）</strong>：表示一个作用于某对象结构中的各元素的操作。它允许在<strong>不改变各元素的类</strong>的前提下定义作用于这些元素的<strong>新操作</strong>。</p><p>​适用于：</p><ul><li>一个对象结构包含很多类对象，它们有不同的接口，而用户想对这些对象实施一些依赖于其具体类的操作。</li><li>需要对一个对象结构中的对象进行很多<strong>不同的并且不相关</strong>的操作，而又想要避免这些操作“污染”这些对象的类。</li><li>定义对象结构的类很少改变，但经常需要在此结构上定义<strong>新的操作</strong></li></ul></li><li><p><strong>中介者（行为型对象）</strong>：用一个<strong>中介对象</strong>来封装一系列的对象交互。中介者使各对象<strong>不需要显式地相互引用</strong>，从而使其耦合松散，而且可以<strong>独立地</strong>改变它们之间的<strong>交互</strong>。</p><p>​适用于：</p><ul><li><code>一组对象以定义良好但是复杂的方式进行通信，产生的相互依赖关系结构混乱且难以理解。</code></li><li>一个对象引用其他很多对象并且直接与这些对象通信，导致难以复用该对象</li><li>想定制一个分布在多个类中的行为，而又不想生成太多的子类</li></ul></li></ul></li></ol><hr><p>更新！！！ </p><p>2024.12.11上午出分啦，上午题51，下午题48，低分飘过~</p><img src="https://pencil1024.oss-cn-chengdu.aliyuncs.com/imgs/202412111502023.png" alt="image-20241211150238871" style="zoom:80%;" />]]></content>
      
      
      <categories>
          
          <category> 软考 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 软件设计师 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hadoop</title>
      <link href="/posts/b3349d42.html"/>
      <url>/posts/b3349d42.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="前置"><a href="#前置" class="headerlink" title="前置"></a>前置</h2><h3 id="知识概括"><a href="#知识概括" class="headerlink" title="知识概括"></a>知识概括</h3><p>大数据就是：使用分布式技术完成海量数据的处理，得到数据背后蕴含的价值</p><p>2008年<strong>Apache Hadoop</strong>开源了</p><p>在VMware的虚拟网络编辑器中，将VMnet8虚拟网卡的:</p><ul><li>网段设置为:192.168.88.0</li><li>网关设置为:192.168.88.2</li></ul><p>前置环境配置准备：</p><ol><li>设置三台Linux虚拟机的主机名和固定IP</li><li>在Linux系统以及本机系统中配置了主机名映射</li><li>配置了三台服务器之间root用户的SSH免密互通</li><li>安装配置了JDK环境</li><li>关闭了防火墙和SELinux</li><li>更新了时区和同步了时间</li><li>拍摄快照保存状态</li></ol><p>Hadoop可以提供：</p><ul><li>分布式数据存储（HDFS）</li><li>分布式数据计算（MapReduce）</li><li>分布式资源调度（Yarn）</li></ul><h2 id="环境配置"><a href="#环境配置" class="headerlink" title="环境配置"></a>环境配置</h2><p>已经完成服务器创建、固定IP、防火墙关闭、Hadoop用户创建、SSH免密、JDK部署</p><h3 id="HDFS集群配置"><a href="#HDFS集群配置" class="headerlink" title="HDFS集群配置"></a>HDFS集群配置</h3><p>配置HDFS集群，主要涉及如下文件的修改：</p><ul><li>workers：配置从节点（DataNode）有哪些</li><li>hadoop-env.sh            配置Hadoop的相关环境变量</li><li>core-site.xml                Hadoop核心配置文件</li><li>hdfs-site.xml                HDFS核心配置文件</li></ul><p>这些文件均在$HADOOP_HOME&#x2F;etc&#x2F;hadoop文件中</p><p>具体配置如下：</p><h3 id="四文件配置"><a href="#四文件配置" class="headerlink" title="四文件配置"></a>四文件配置</h3><ul><li>workers：</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">vim workers</span><br><span class="line">-----------</span><br><span class="line">node1</span><br><span class="line">node2</span><br><span class="line">node3</span><br></pre></td></tr></table></figure><ul><li>hadoop-env.sh</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">export JAVA_HOME=/export/server/jdk</span><br><span class="line">export HADOOP_HOME=/export/server/hadoop</span><br><span class="line">export HADOOP_CONF_DIR=$HADOOP_HOME/etc/hadoop</span><br><span class="line">export HADOOP_LOG_DIR=$HADOOP_HOME/logs</span><br></pre></td></tr></table></figure><ul><li>core-site.xml</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;fs.defaultFS&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;hdfs://node1:8020&lt;/value&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line"></span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;io.file.buffer.size&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;131072&lt;/value&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br></pre></td></tr></table></figure><ul><li>hdfs-site.xml</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">&lt;configuration&gt;</span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;dfs.datanode.data.dir.perm&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;700&lt;/value&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line"></span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;dfs.namenode.name.dir&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;/data/nn&lt;/value&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line"></span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;dfs.namenode.hosts&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;node1,node2,node3&lt;/value&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line"></span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;dfs.blocksize&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;268435456&lt;/value&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line"></span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;dfs.namenode.handler.count&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;100&lt;/value&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line"></span><br><span class="line">  &lt;property&gt;</span><br><span class="line">    &lt;name&gt;dfs.datanode.data.dir&lt;/name&gt;</span><br><span class="line">    &lt;value&gt;/data/dn&lt;/value&gt;</span><br><span class="line">  &lt;/property&gt;</span><br><span class="line">&lt;/configuration&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="准备数据目录"><a href="#准备数据目录" class="headerlink" title="准备数据目录"></a>准备数据目录</h3><p>在node1节点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /data/nn</span><br><span class="line">mkdir /data/dn</span><br></pre></td></tr></table></figure><p>在node2和node3节点：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p /data/dn</span><br></pre></td></tr></table></figure><h3 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h3><p>在Hadoop文件夹中的bin、sbin两个文件夹内有许多的脚本和程序，在环境变量中添加如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">export HADOOP_HOME=/export/server/hadoop</span><br><span class="line">export PATH=$HADOOP_HOME/bin:$HADOOP_HOME/sbin</span><br></pre></td></tr></table></figure><h3 id="hadoop用户授权"><a href="#hadoop用户授权" class="headerlink" title="hadoop用户授权"></a>hadoop用户授权</h3><p>接下来以<strong>root</strong>身份为hadoop用户授权，在node1、node2、node3分别执行</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chown -R hadoop:hadoop /data</span><br><span class="line">chown -R hadoop:hadoop /export</span><br></pre></td></tr></table></figure><h3 id="格式化整个文件系统"><a href="#格式化整个文件系统" class="headerlink" title="格式化整个文件系统"></a>格式化整个文件系统</h3><ul><li>格式化namenode</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">su hadoop</span><br><span class="line">hadoop namenode -format</span><br></pre></td></tr></table></figure><ul><li>启动</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 一键启动hdfs集群</span><br><span class="line">start-dfs.sh</span><br><span class="line"># 一键关闭hdfs集群</span><br><span class="line">stop-dfs.sh</span><br></pre></td></tr></table></figure><h3 id="环境配置问题"><a href="#环境配置问题" class="headerlink" title="环境配置问题"></a>环境配置问题</h3><p>启动start-dfs.sh出现报错Permission denied的原因是<strong>授权</strong>没到位，仔细观察前面的-rw-r–r–这一坨</p><ol><li>第一个字符<strong>（文件类型）</strong><ul><li>-：表示这是一个普通文件（如果是目录，则是 d，如果是符号链接，则是 l，等等）</li></ul></li><li>第 2 到第 4 个字符：表示文件所有者<strong>（owner）</strong>的权限</li><li>第 5 到第 7 个字符：表示文件所在组<strong>（group）</strong>的权限</li><li>第 8 到第 10 个字符：表示其他用户<strong>（others）</strong>的权限</li></ol><ul><li>r：读取权限，允许查看文件内容</li><li>w：写入权限，允许修改文件内容</li><li>x：执行权限，允许执行文件或进入目录</li><li>-：表示文件所有者没有 执行 权限</li></ul><p>解决方法可以是：为该目录下的所有文件和子目录都具有适当的<strong>执行</strong>权限</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod -R +x /export/server/hadoop/bin/</span><br></pre></td></tr></table></figure><h2 id="相关命令"><a href="#相关命令" class="headerlink" title="相关命令"></a>相关命令</h2><h3 id="单进程启停操作"><a href="#单进程启停操作" class="headerlink" title="单进程启停操作"></a>单进程启停操作</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hdfs --daemon (start|stop|) (namenode|secondarynamenode)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 大数据开发前置知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hadoop </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL</title>
      <link href="/posts/c24675b4.html"/>
      <url>/posts/c24675b4.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="基础篇"><a href="#基础篇" class="headerlink" title="基础篇"></a>基础篇</h2><h3 id="知识概括"><a href="#知识概括" class="headerlink" title="知识概括"></a>知识概括</h3><p>windows查看mysql版本(三种方法)：<a href="https://blog.csdn.net/maoziyang1996/article/details/85334935">windows查看mysql版本(三种方法)_cmd查看mysql版本-CSDN博客</a></p><p>用MySQL之前记得先启动MySQL</p><p>客户端连接（win+cmd）之前记得先配置mysql\bin目录到环境变量中</p><ul><li>语法：mysql -u root -p</li><li>如果出现版本号说明连接成功</li></ul><p>DBMS：数据库管理系统</p><p>关系型数据库（RDBMS）</p><ul><li>概念：建立在关系模型基础上，由多张相互连接的二维表组成的数据库</li></ul><p>char(10)：<strong>定长</strong>字符串(其余位置用空格来填充)      varchar(10)：<strong>变长</strong>字符串</p><p>图形界面化工具：Datagrip</p><ul><li>注意：连接MySQL时需要<strong>启动</strong>MySQL，且密码和MySQL当时设置的密码一致</li></ul><blockquote><p>sql</p></blockquote><p>sql语句不区分大小写，但关键词建议用大写</p><p>注释</p><ol><li>单行注释：用”–”  或  “#”</li><li>多行注释：用&#x2F;* *&#x2F;</li></ol><p>SQL分类</p><ol><li><p>DDL：数据定义语言，用来定义数据库对象(<strong>数据库，表，字段</strong>)</p><ul><li>查询所有数据库show databases;  查询当前数据库select database();</li><li>查询表结构<ul><li>语法：<strong>desc</strong> 表名；</li></ul></li><li>查询指定表的建表语句<ul><li>语法：SHOW CREATE TABLE 表名;</li></ul></li><li>创建表<ul><li>语法：<strong>create</strong> table 表名{字段 字段类型;······}</li></ul></li><li>删除表<ul><li>语法：<strong>drop</strong> table 表名</li></ul></li><li>使用表<ul><li>语法：<strong>use</strong> table 表名</li></ul></li><li>添加字段<ul><li>语法：ALTER TABLE 表名 <strong>add</strong> 字段名 类型(长度) [COMMENT注释] [约束];</li></ul></li><li>修改数据类型<ul><li>语法：ALTER TABLE 表名 <strong>modify</strong> 字段名 新数据类型(长度);</li></ul></li><li>修改字段名和字段类型<ul><li>语法：ALTER TABIE 表名 <strong>change</strong> 旧字段名 新字段名 类型(长度) [COMIMENT注释] [约束];</li></ul></li><li>删除字段<ul><li>语法：ALTER TABLF 表名 <strong>drop</strong> 字段名;</li></ul></li><li>修改表名<ul><li>语法：ALTER TABLE 表名 <strong>rename to</strong> 新表名;</li></ul></li><li>删除表<ul><li>语法：<strong>drop</strong> TABLE [ IF EXISTS] 表名;</li></ul></li><li>删除指定表，并重新创建该表<ul><li>语法：<strong>runcate</strong> TABLE 表名;</li></ul></li></ul></li><li><p>DML：数据操作语言，用来对数据库表中的<strong>数据</strong>进行增删改</p><ul><li><p>添加数据：insert</p><ul><li><p>给指定字段添加数据</p><ul><li>语法：insert into 表名 (字段名1,字段名2,…) values (值1,值2,.…);</li></ul></li><li><p>给全部字段添加数据</p><ul><li>语法：insert into 表名 values (值1,值2,…);</li></ul></li></ul></li><li><p>修改数据：update</p><ul><li>语法：<strong>update</strong> 表名 <strong>SET</strong> 字段名1&#x3D;值1,字段名2&#x3D;值2,…[ <strong>where</strong>条件];<ul><li><code>注意：</code>修改语句的条件可以有，也可以没有，如果没有条件，则会修改整张表该字段名下的所有数据</li></ul></li></ul></li><li><p>删除数据：delete</p><ul><li>语法：<strong>delete from</strong> 表名 [<strong>where</strong>条件];<ul><li><code>注意：</code>delete语句的条件可以有，也可以没有，如果没有条件，则会删除整张表的所有数据</li><li><code>注意：</code>delete语句不能删除某一个字段的值(可以使用<strong>update</strong>，用NULL)，要删就是删一整行</li></ul></li></ul></li></ul></li><li><p>DQL：数据查询语言，用来查询数据库中表的记录</p><ul><li><p>查询多个字段</p><ul><li><strong>select</strong> 字段1,字段2，字段3… <strong>from</strong> 表名;</li><li><strong>select * from</strong> 表名</li></ul></li><li><p>去除重复记录</p><ul><li><strong>select distinct</strong> 字段列表 <strong>from</strong> 表名;</li></ul></li><li><p>条件查询的各种关键词</p><ul><li>注意：where 字段名 <strong>like</strong> ‘_’(‘%’)，模糊匹配</li></ul></li><li><p>聚合函数</p><ul><li>语法：<strong>select</strong> 聚合函数(字段列表) <strong>from</strong> 表名;<ul><li><code>注意：</code>所有的null值不参与聚合运算</li></ul></li></ul></li><li><p>分组查询</p><ul><li>语法：<strong>select</strong> 字段列表 <strong>from</strong> 表名 [ where条件] <strong>group by</strong> 分组字段名〔<strong>having</strong>分组后过滤条件];<ul><li><code>注意：</code>where是分组之前进行过滤，不满足where条件，不参与分组;而having是分组之后对结果进行过滤</li><li><code>注意：</code>where不能对聚合函数进行判断，而having可以</li></ul></li></ul></li><li><p>排序查询</p><ul><li><p>语法：<strong>select</strong> 字段列表 <strong>from</strong> 表名 <strong>order by</strong> 字段1 排序方式1，字段2 排序方式2;</p><p>排序方式：</p><ul><li>ASC：升序（默认）</li><li>DESC：降序</li></ul></li></ul></li><li><p>分页查询</p><ul><li>语法：<strong>select</strong> 字段列表 <strong>from</strong> 表名 <strong>limit</strong> 起始索引,查询记录数;</li></ul></li></ul></li><li><p>DCL：数据控制语言,用来创建数据库用户、控制数据库的访问权限</p><ul><li><p>查询用户</p><ul><li>use mysql;select * from user;</li></ul></li><li><p>创建用户</p><ul><li>语法：create user ‘用户名‘@‘主机名’ identified by ‘密码’；</li></ul></li><li><p>修改用户密码</p><ul><li>语法：alert user ‘用户名‘@’主机名’ indentified with mysql_native_password by ‘新密码’;</li></ul></li><li><p>删除用户</p><ul><li>语法：drop user ‘用户名‘@’主机名’;</li></ul></li><li><p><code>注意：</code>主机名可以使用**%**通配</p></li></ul></li></ol><blockquote><p>函数</p></blockquote><p>1、字符串函数</p><p><img src="https://pencil1024.oss-cn-chengdu.aliyuncs.com/imgs/202410221059003.png" alt="image-20241022105910857"></p><p>2、数值函数</p><p><img src="https://pencil1024.oss-cn-chengdu.aliyuncs.com/imgs/202410221107855.png" alt="image-20241022110709779"></p><p>3、日期函数</p><p><img src="https://pencil1024.oss-cn-chengdu.aliyuncs.com/imgs/202410221112488.png" alt="image-20241022111258383"></p><p>4、流程函数</p><p><img src="https://pencil1024.oss-cn-chengdu.aliyuncs.com/imgs/202410221115944.png" alt="image-20241022111528852"></p><blockquote><p>约束</p></blockquote><p>1、概念：约束是作用于表中<strong>字段</strong>上的规则，用于限制存储在表中的数据</p><p>2、分类</p><table><thead><tr><th align="center">约束</th><th align="center">描述</th><th align="center">关键字</th></tr></thead><tbody><tr><td align="center">非空约束</td><td align="center">限制改字段的数据不能为null</td><td align="center">not null</td></tr><tr><td align="center">唯一约束</td><td align="center">保证该字段的所有数据都是唯一、不重复的</td><td align="center">unique</td></tr><tr><td align="center">主键约束</td><td align="center">主键是一行数据的唯一标识</td><td align="center">primary key</td></tr><tr><td align="center">默认约束</td><td align="center">保存数据时，如果未指定该字段的值，则采用默认值</td><td align="center">default</td></tr><tr><td align="center">检查约束</td><td align="center">保证字段值满足某一个条件</td><td align="center">check</td></tr><tr><td align="center">外键约束</td><td align="center">用来让两张表的数据之间建立连接，保证数据的一致性和完整性</td><td align="center">foreign key</td></tr></tbody></table><p>外键约束</p><ul><li><p>添加外键</p><ul><li>语法：alert table 表名 add <strong>constraint</strong> 外键名称 foreign key (外键字段名）references 主表(主表列名);</li></ul></li><li><p>删除外键</p><ul><li>语法：alert table 表名 drop foreign key 外键名称;</li></ul></li></ul><blockquote><p>多表查询</p></blockquote><ol><li>一对多（多对一）<ul><li>实现：在多的一方建立外键，指向 <code>一</code> 一方的主键</li></ul></li><li>多对多<ul><li>实现：建立第三张<strong>中间表</strong>，中间表至少包含两个外键，分别关联两方主键</li></ul></li><li>一对一<ul><li>实现：在任意一方加入外键，关联另外一方的主键，并且设置外键为唯一的(unique)</li></ul></li></ol><blockquote><p>事务</p></blockquote><p>1.概念：事务是一组操作的集合，它是一个不可分割的工作单位，事务会把所有的操作作为一个整体一起向系统提交或撤销操作请求，即这些操作要么同时成功，要么同时失败。</p><ul><li><p>查看&#x2F;设置事务提交方式</p><ul><li>select @@autocommit</li><li>set @@autocommit &#x3D; 0;     #设置事务提交为手动提交</li></ul></li><li><p>开启事务</p><ul><li>语法：start transaction 或 begin;</li></ul></li><li><p>提交事务</p><ul><li>commit;</li></ul></li><li><p>回滚事务</p><ul><li>rollback;</li></ul></li></ul><p></p><p>2.事务的四大特性（ACID）</p><ul><li>原子性<ul><li>事务是不可分割的最小操作单元，要么全部成功，要么全部失败。</li></ul></li><li>一致性<ul><li>事务完成时，必须使所有的数据都保持一致状态。</li></ul></li><li>隔离性<ul><li>数据库系统提供的隔离机制，保证事务在不受外部并发操作影响的独立环境下运行。</li></ul></li><li>持久性<ul><li>事务一旦提交或回滚，它对数据库中的数据的改变就是永久的。</li></ul></li></ul><p>3.并发事务问题</p><ul><li>脏读</li><li>不可重复读</li><li>幻读</li></ul><h2 id="进阶篇"><a href="#进阶篇" class="headerlink" title="进阶篇"></a>进阶篇</h2><h3 id="知识概括-1"><a href="#知识概括-1" class="headerlink" title="知识概括"></a>知识概括</h3><p>1.MySQL的体系结构</p><ul><li>连接层<ul><li>最上层是一些客户端和链接服务，主要完成一些类似于连接处理、授权认证、及相关的安全方案。服务器也会为安全接入的每个客户端验证它所具有的操作权限。</li></ul></li><li>服务层<ul><li>第二层架构主要完成大多数的核心服务功能，如SQL接口，并完成缓存的查询，SQL的分析和优化，部分内置函数的执行。所有跨存储引擎的功能也在这一层实现，如过程、函数等。</li></ul></li><li>引擎层<ul><li>存储引擎真正的负责了MySQL中数据的存储和提取，服务器通过API和存储引擎进行通信。不同的存储引擎具有不同的功能，这样我们可以根据自己的需要，来选取合适的存储引擎。</li></ul></li><li>存储层<ul><li>主要是将数据存储在文件系统之上，并完成与存储引擎的交互。</li></ul></li></ul><p>2.存储引擎的选择</p><ul><li>InnoDB:是Mysql的默认存储引擎，支持<strong>事务</strong>、外键。如果应用对事务的完整性有比较高的要求，<strong>在并发条件下要求数据的一致性</strong>，数据操作除了插入和查询之外，还包含很多的更新、删除操作，那么InnoDB存储引擎是比较合适的选择。</li><li>MyISAM: 如果应用是<strong>以读操作和插入操作为主</strong>，只有很少的更新和删除操作，并且对事务的完整性、并发性要求不是很高，那么选择这个存储引擎是非常合适的。</li><li>MEMORY:将所有数据保存在内存中，<strong>访问速度快</strong>，通常用于<strong>临时表及缓存</strong>。MEMORY的缺陷就是对表的大小有限制，太大的表无法缓存在内存中，而且无法保障数据的安全性。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 大数据开发前置知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux操作系统</title>
      <link href="/posts/6f6343c5.html"/>
      <url>/posts/6f6343c5.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><h3 id="知识概括"><a href="#知识概括" class="headerlink" title="知识概括"></a>知识概括</h3><p>VMware是一个提供虚拟化环境的软件,可以将Ubuntu Linux安装在里面</p><p><strong>Ubuntu系统中找不到ifconfig命令：</strong><a href="https://blog.csdn.net/qq_36938617/article/details/95013583">Ubuntu系统中找不到ifconfig命令_找不到命令 “ifconfig”,但可以通过以下软件包安装它: sudo apt install n-CSDN博客</a></p><p>输入ifconfig查看ip地址</p><p>快照功能</p><h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><h3 id="知识点概括"><a href="#知识点概括" class="headerlink" title="知识点概括"></a>知识点概括</h3><p>Linux没有盘符这个概念,只有一个根目录&#x2F;,所有文件都在它下面</p><ul><li><p>在<strong>Linux系统</strong>中，路径之间的层级关系，使用**:&#x2F;**来表示</p></li><li><p>在<strong>Windows系统</strong>中，路径之间的层级关系，使用**:\**来表示</p></li></ul><blockquote><p>无论是什么命令，用于什么用途，在Linux中，命令有其通用的格式:command [-options] [parameter]</p></blockquote><p> command：<strong>命令</strong>本身</p><p> -options：[可选,非必填]命令的一些<strong>选项</strong>,可以通过选项控制命令的行为细节 </p><p>parameter：[可选,非必填]命令的<strong>参数</strong>，多数用于命令的指向目标等</p><p><strong>ctrl+l</strong>可以清空findshell的屏幕</p><p>切换到root用户获得管理员权限 <code>su - root</code></p><h3 id="相对路径和绝对路径"><a href="#相对路径和绝对路径" class="headerlink" title="相对路径和绝对路径"></a>相对路径和绝对路径</h3><p>绝对路径：以根目录为起点，描述路径的一种写法，路径描述以&#x2F;开头</p><p>相对路径:以当前目录为起点，描述路径的一种写法，路径描述无需以&#x2F;开头</p><h3 id="特殊路径符"><a href="#特殊路径符" class="headerlink" title="特殊路径符"></a>特殊路径符</h3><ul><li><code>.</code>  表示当前目录，比如cd .&#x2F;Desktop表示切换到当前目录下的Desktop目录内，和cd Desktop效果一致</li><li><code>..</code>表示上一级目录，比如: cd .. 即可切换到上一级目录，cd ..&#x2F;..切换到上二级的目录</li><li><code>~</code>          表示HOME目录，比如: cd～即可切换到HOME目录 或 cd ~&#x2F;Desktop，切换到HOME内的Desktop目录</li></ul><h3 id="命令介绍"><a href="#命令介绍" class="headerlink" title="命令介绍"></a>命令介绍</h3><blockquote><p>ls命令</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">语法：ls [-a -l -h] [Linux路径]展示当前的工作目录，linux默认是home目录</span><br><span class="line">-a选项是指全部展示出来包括隐藏的文件</span><br><span class="line">-l选项是以列表的形式展现</span><br><span class="line">-h选项是展示文件的大小单位</span><br></pre></td></tr></table></figure><blockquote><p>cd命令</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">语法：cd [Linux路径]改变当前工作目录为[Linux路径]</span><br><span class="line">cd命令无需选项，只有参数，表示要切换到哪个目录下</span><br><span class="line">cd命令直接执行，不写参数，表示回到用户的HOME目录</span><br></pre></td></tr></table></figure><blockquote><p> pwd命令</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">语法：pwd输出当前的工作目录</span><br><span class="line">pwd命令，无选项，无参数，直接输入</span><br></pre></td></tr></table></figure><blockquote><p>mkdir命令</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">语法：mkdir [-p] Linux路径创建新的目录（文件夹），路径是必填的</span><br><span class="line">-p选项是创建多个层级的目录</span><br><span class="line">注意：创建文件夹需要修改权限﹐请确保操作均在HOME目录内，不要在HOME外操作，会涉及到权限问题，HOME外无法成功</span><br></pre></td></tr></table></figure><blockquote><p>-touch-cat-more命令</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">touch命令</span><br><span class="line">语法：touch Linux路径创建文件如test.txt</span><br><span class="line">cat命令</span><br><span class="line">语法：cat Linux路径查看文件的内容</span><br><span class="line">more命令</span><br><span class="line">语法：more Linux路径查看文件的内容</span><br><span class="line">与cat不同的是：</span><br><span class="line">1、cat是直接将内容全部显示出来</span><br><span class="line">2、more支持翻页，如果文件内容过多，可以一页页的展示(空格键翻页，q键直接退出来)</span><br></pre></td></tr></table></figure><blockquote><p>-cp-mv-rm命令</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">cp命令</span><br><span class="line">语法：cp [-r] 参数1 参数2复制文件或文件夹</span><br><span class="line">-r选项，可选，用于复制文件夹使用，表示递归</span><br><span class="line">参数1, Linux路径, 表示被复制的文件或文件夹</span><br><span class="line">参数2，Linux路径, 表示要复制去的地方</span><br><span class="line">mv命令</span><br><span class="line">语法：mv 参数1 参数2移动文件或文件夹</span><br><span class="line">rm命令</span><br><span class="line">语法：rm [-r -f] 参数1 参数2 ...... 参数N删除文件或文件夹</span><br><span class="line">-r选项用于删除文件夹</span><br><span class="line">-f选项表示强制删除，不提示，对root管理员用户使用</span><br><span class="line">注意：rm命令支持通配符*，用来做模糊匹配，符号*表示通配符，即匹配任意内容(包含空)</span><br><span class="line">1、test*，表示匹配任何以test开头的内容</span><br><span class="line">2、*test,表示匹配任何以test结尾的内容</span><br><span class="line">3、*test*，表示匹配任何包含test的内容</span><br></pre></td></tr></table></figure><blockquote><p>-which-find命令</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">which命令</span><br><span class="line">语法：which 要查找的命令如which cd</span><br><span class="line">find命令</span><br><span class="line">按文件名查找:</span><br><span class="line">语法：find 起始路径 -name &quot;被查找文件名&quot;按文件名查找文件</span><br><span class="line">也适用模糊匹配的规则</span><br><span class="line">按文件大小查找:</span><br><span class="line">语法：find 起始路径 -size +|-n[kMG]</span><br><span class="line">+、-表示大于或小于</span><br><span class="line">n表示数字大小</span><br><span class="line">kMG表示大小单位，k(小写字母)表示kb，M表示MB，G表示GB</span><br></pre></td></tr></table></figure><blockquote><p>grep命令</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">语法：grep [-n] &quot;关键字&quot; 文件路径从文件中通过关键字过滤文件行</span><br><span class="line">-n选项用于显示匹配的行的行号</span><br></pre></td></tr></table></figure><blockquote><p>wc命令</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">语法：wc [-c -m -l -w] 文件路径统计文件的行数、单词数量等</span><br><span class="line">-c，统计bytes数量</span><br><span class="line">-m，统计字符数量</span><br><span class="line">-l，统计行数</span><br><span class="line">-w，统计单词数量</span><br></pre></td></tr></table></figure><blockquote><p>echo命令</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">语法：echo 输出的内容打印输出</span><br><span class="line">覆写是&gt;   ehco &quot;内容&quot; &gt; 文件</span><br><span class="line">追加是&gt;&gt;  echo &quot;内容&quot; &gt;&gt; 文件</span><br></pre></td></tr></table></figure><blockquote><p>tail命令</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">语法：tail [-f -num] Linux路径</span><br><span class="line">-f表示持续跟踪</span><br><span class="line">-num表示从后往前数多少行，默认是10，这里写具体数字比如说-5</span><br></pre></td></tr></table></figure><blockquote><p>常用vim快捷键</p></blockquote><p>yy 复制当前行</p><p>p   粘贴内容</p><p>dd     删除当前行</p><p>u   撤销修改</p><p>ctrl+r    反向撤销修改</p><p>dG            从当前行开始，向下全部删除</p><p>dgg           从当前行开始，向上全部删除</p><p>&#x2F;        进入搜索模式（n向下继续搜索，N向上继续搜索）</p><p>:set nu     显示行号</p><h2 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h2><h3 id="知识概括-1"><a href="#知识概括-1" class="headerlink" title="知识概括"></a>知识概括</h3><p>Ubuntu系统输入<code>su - root</code>弹认证失败：<a href="https://blog.csdn.net/qq_45875853/article/details/136299744#">Linux输入“su”进入root时，提示“认证失败”的解决办法_su: 认证失败-CSDN博客</a></p><p>用户、用户组相关命令操作</p><p>权限信息的解读，如drwxr-xr-x，理解的时候应该分开来看：d rwx r-x r-x</p><ul><li>d代表文件夹（-代表文件）</li><li>然后每三个部分代表一个权限</li><li>r代表读， w代表写， x代表执行（针对文件夹则代表进入工作目录， 即cd命令）</li></ul><img src="https://pencil1024.oss-cn-chengdu.aliyuncs.com/imgs/202410191359691.png" alt="image-20241019135926655" style="zoom: 80%;" /><blockquote><p>chmod</p></blockquote><p>chmod命令可以修改文件、文件夹的权限信息。<strong>注意，只有文件、文件夹的所属用户或root用户可以修改。</strong></p><p>语法：chmod [-R] 权限文件或文件夹， 如chmod u&#x3D;rwx,g&#x3D;rx,o&#x3D;x hello.txt</p><ul><li><p>选项:-R，对文件夹内的全部内容应用同样的操作</p></li><li><p>这里的u代表用户， g代表用户组， o代表其他用户</p></li></ul><blockquote><p>chown</p></blockquote><p>chown命令可以修改所属用户和用户组，<strong>注意普通用户无法使用，只能root用户</strong></p><p>语法：chown [-R]  [用户] [:] [用户组] 文件或文件夹</p><h2 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h2><h3 id="知识概括-2"><a href="#知识概括-2" class="headerlink" title="知识概括"></a>知识概括</h3><p>ctrl+d可以退出或登出某些特定程序的专属页面</p><p>history可以查看历史输过的所有命令</p><p>ctrl+a跳到命令的最前面， ctrl+e跳到命令的最后面， ctrl+左键跳到上一个单词， 右键同理</p><p>CentOS：.rpm  yum；</p><p>Ubuntu：    .deb  apt</p><p>语法：apt [-y] [install | remove | search] 软件名称</p><blockquote><p>systemctl</p></blockquote><p><strong>systemctl</strong>命令控制:启动、停止、开机自启，能够被systemctl管理的软件，一般也称之为：<strong>服务</strong></p><p>语法：systemctl start | stop | status | enable | disable 服务名</p><blockquote><p>ln</p></blockquote><p>该命令可以创建软链接，类似于windows系统中的《快捷方式》</p><p>语法：ln  -s  参数1 参数2</p><p>域名解析的过程就是把ip地址变成我们好记的字符串就比如说baidu.com</p><ul><li>先查看本机的记录（私人地址本)</li><li>再联网去DNS服务器</li></ul><blockquote><p>ping</p></blockquote><p>ping命令可以检查指定的网络服务器是否是可联通状态</p><ul><li>-c选项是指检查的次数</li></ul><blockquote><p>wget</p></blockquote><p>wget是非交互式的文件下载器，可以在命令行内下载网络文件</p><p>语法：wget  [-b]  url</p><ul><li>-b选项，后台下载</li></ul><blockquote><p>curl</p></blockquote><p>curl可以发送http网络请求，可用于下载文件、获取信息等</p><p>语法：curl  [-O]  url</p><ul><li>-O选项用于下载文件</li><li>若只需要获取网络请求的话就不需要-O的选项</li></ul><p>Linux系统是一个超大号小区,可以支持65535个端口，这6万多个端口分为3类进行使用:</p><ul><li>公认端口：1~1023，通常用于一些系统内置或知名程序的预留使用，如SSH服务的22端口，HTTPS服务的443端口非特殊需要，不要占用这个范围的端口</li><li>注册端口:1024~49151,通常可以随意使用，用于松散的绑定一些程序\服务</li><li>动态端口:49152~65535,通常不会固定绑定程序,而是当程序对外进行网络链接时，用于临时使用。</li></ul><blockquote><p>ps</p></blockquote><p>ps命令可以查看进程</p><p>语法：ps  [-e -f]</p><ul><li>-e选项，显示出全部的进程</li><li>-f选项，以完全格式化的形式展示信息（展示全部信息）</li><li>一般来说固定用法就是ps  -ef</li></ul><blockquote><p>top</p></blockquote><p>查看系统的资源占用</p><p>选项和一些常用的交互式选项</p><blockquote><p>df</p></blockquote><p>查看硬盘的使用情况</p><p>语法：df  [-h]</p><ul><li>-h选项是将内存显示成看得懂的单位</li></ul><blockquote><p>iostat</p></blockquote><p>查看磁盘速率</p><blockquote><p>sar -n DEV</p></blockquote><p>查看网络情况</p><p>环境变量是一组信息记录</p><p>可以使用<code>$</code>符去获得环境变量的值</p><ul><li>echo $PATH    （这样会直接输出路径，echo是输出命令）</li></ul><blockquote><p>export</p></blockquote><p>自行设置环境变量</p><p>语法：export 变量名&#x3D;变量值</p><ul><li>在<strong>当前用户</strong>生效的话，配置当前用户的：~&#x2F;.bashrc文件中</li><li>针对<strong>所有用户</strong>生效，配置在系统的：                &#x2F;etc&#x2F;profile文件中</li><li>用source配置文件，进行立刻生效</li></ul><h2 id="vim编辑器中常用快捷键"><a href="#vim编辑器中常用快捷键" class="headerlink" title="vim编辑器中常用快捷键"></a>vim编辑器中常用快捷键</h2><ul><li><p>在esc模式下，<strong>按o</strong> 可以直接在下面开启一新行，并且转换为插入模式</p></li><li><p>在esc模式下，<strong>按0</strong> 可以调到行首</p></li><li><p>在esc模式下，<strong>按j</strong> 可以换行，其实跟按下没区别</p></li><li><p>在esc模式下，<strong>按A</strong> 可以将指针跳转到行末进入插入模式</p></li><li><p>在esc模式下，<strong>按G</strong> 可以跳到直接到文档末尾</p></li><li><p>在esc模式下，**输q! **可以强制退出不保存</p></li></ul><h2 id="解决ubuntu-ifconfig只有lo没有ens33的问题"><a href="#解决ubuntu-ifconfig只有lo没有ens33的问题" class="headerlink" title="解决ubuntu ifconfig只有lo没有ens33的问题"></a>解决ubuntu ifconfig只有lo没有ens33的问题</h2><ol><li>通过<code>ifconfig</code>只能看到lo本地回环网卡</li><li>通过<code>ifconfig -a</code>能正常ens33网卡,但是无法上网问题</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">service network-manager stop  # 先停止服务</span><br><span class="line"># 删除文件</span><br><span class="line">sudo rm -rf /var/lib/NetworkManager/NetworkManager.state </span><br><span class="line">#重启服务器</span><br><span class="line">service network-manager start</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 大数据开发前置知识 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>移除桌面快捷左下箭头</title>
      <link href="/posts/ce3dfaf1.html"/>
      <url>/posts/ce3dfaf1.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="去除箭头"><a href="#去除箭头" class="headerlink" title="去除箭头"></a>去除箭头</h2><ol><li>新建一个文本文件（如不显示.txt后缀电脑要在文件夹里设置“显示已知文件扩展名”）</li><li>复制下面代码粘贴后保存</li><li>修改扩展名为 <strong>.bat</strong> 文件</li><li>右键以管理员身份打开</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">reg add &quot;HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Shell Icons&quot; /v 29 /d &quot;%systemroot%\system32\imageres.dll,197&quot; /t reg_sz /f</span><br><span class="line">taskkill /f /im explorer.exe</span><br><span class="line">attrib -s -r -h &quot;%userprofile%\AppData\Local\iconcache.db&quot;</span><br><span class="line">del &quot;%userprofile%\AppData\Local\iconcache.db&quot; /f /q</span><br><span class="line">start explorer</span><br><span class="line">pause</span><br></pre></td></tr></table></figure><h2 id="恢复箭头"><a href="#恢复箭头" class="headerlink" title="恢复箭头"></a>恢复箭头</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">reg delete &quot;HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Shell Icons&quot; /v 29 /f</span><br><span class="line">taskkill /f /im explorer.exe</span><br><span class="line">start explorer</span><br><span class="line">pause</span><br></pre></td></tr></table></figure><p>献上参考博客：</p><p><a href="https://blog.csdn.net/EleganceJiaBao/article/details/137630255">【Windows】Windows11、Windows10完美去除快捷方式小箭头的方法_win11去除桌面小箭头-CSDN博客</a></p><p><a href="https://blog.csdn.net/weixin_44407238/article/details/113620229">Win10怎么去除桌面快捷方式图标左下角的小箭头_win10桌面文件左下角夹小箭头-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 实用技巧 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>加减乘除高精度</title>
      <link href="/posts/cedaecd5.html"/>
      <url>/posts/cedaecd5.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="高精度加法"><a href="#高精度加法" class="headerlink" title="高精度加法"></a>高精度加法</h2><blockquote><p><a href="https://www.acwing.com/problem/content/793/">791. 高精度加法 - AcWing题库</a></p></blockquote><p>给定两个正整数（不含前导 00），计算它们的和。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>共两行，每行包含一个整数。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>共一行，包含所求的和。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤整数长度≤1000001≤整数长度≤100000</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">12</span><br><span class="line">23</span><br></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">35</span><br></pre></td></tr></table></figure><p>思路：模拟加法的过程，从末尾开始，逐步进位相加取模</p><p>ps：<strong>需要注意</strong>if(i&gt;&#x3D;a.size()) t1&#x3D;0;        if(i&gt;&#x3D;b.size()) t2&#x3D;0;这两步，<strong>因为’’-‘0’不为0</strong></p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">string a,b,x;</span><br><span class="line"><span class="type">int</span> t1, t2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    <span class="built_in">reverse</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>()), <span class="built_in">reverse</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>());   <span class="comment">//逆序</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> t=<span class="number">0</span>;    <span class="comment">//存进位</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;a.<span class="built_in">size</span>() || i&lt;b.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        t1=a[i]-<span class="string">&#x27;0&#x27;</span>, t2=b[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=a.<span class="built_in">size</span>()) t1=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=b.<span class="built_in">size</span>()) t2=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> mo=(t1+t2+t)%<span class="number">10</span>;    </span><br><span class="line">        x+=<span class="built_in">to_string</span>(mo);</span><br><span class="line">        t=(t1+t2+t)/<span class="number">10</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(t==<span class="number">1</span>)    x+=<span class="string">&quot;1&quot;</span>; <span class="comment">//如果最后还有一次进位</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">reverse</span>(x.<span class="built_in">begin</span>(),x.<span class="built_in">end</span>()); <span class="comment">//逆序即为结果</span></span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;x&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="高精度减法"><a href="#高精度减法" class="headerlink" title="高精度减法"></a>高精度减法</h2><blockquote><p><a href="https://www.acwing.com/problem/content/794/">792. 高精度减法 - AcWing题库</a></p></blockquote><p>给定两个正整数（不含前导 00），计算它们的差，计算结果可能为负数。</p><h4 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h4><p>共两行，每行包含一个整数。</p><h4 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h4><p>共一行，包含所求的差。</p><h4 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤整数长度≤1051≤整数长度≤105</p><h4 id="输入样例：-1"><a href="#输入样例：-1" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">32</span><br><span class="line">11</span><br></pre></td></tr></table></figure><h4 id="输出样例：-1"><a href="#输出样例：-1" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">21</span><br></pre></td></tr></table></figure><p>思路：先实现cmp()比数的大小，小减大要添“-”，在末尾模拟减法操作</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">string a,b;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(string a,string b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.<span class="built_in">size</span>()!=b.<span class="built_in">size</span>())  <span class="keyword">return</span> a.<span class="built_in">size</span>()&gt;b.<span class="built_in">size</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;a.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]!=b[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> a[i]&gt;b[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(string a,string b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">reverse</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">reverse</span>(b.<span class="built_in">begin</span>(),b.<span class="built_in">end</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> t=<span class="number">0</span>,t1,t2;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;a.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;b.<span class="built_in">size</span>())  t2=b[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span>    t2=<span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        t1=a[i]-<span class="string">&#x27;0&#x27;</span>-t;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(t1&lt;t2)</span><br><span class="line">        &#123;</span><br><span class="line">            t=<span class="number">1</span>;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(t1+<span class="number">10</span>-t2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            t=<span class="number">0</span>;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(t1-t2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//去前导零</span></span><br><span class="line">    <span class="keyword">while</span>(ans.<span class="built_in">size</span>()&gt;<span class="number">1</span> &amp;&amp; ans.<span class="built_in">back</span>()==<span class="number">0</span>)  ans.<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// a比b大</span></span><br><span class="line">    <span class="keyword">if</span>(a==b)    <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">cmp</span>(a,b))    <span class="built_in">solve</span>(a,b);</span><br><span class="line">    <span class="keyword">else</span>    <span class="comment">// a比b小</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;-&quot;</span>;</span><br><span class="line">        <span class="built_in">solve</span>(b,a);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=ans.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)    cout&lt;&lt;ans[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="高精度乘法"><a href="#高精度乘法" class="headerlink" title="高精度乘法"></a>高精度乘法</h2><blockquote><p><a href="https://www.acwing.com/problem/content/795/">793. 高精度乘法 - AcWing题库</a></p></blockquote><p>给定两个非负整数（不含前导 00） <em>A</em>A 和 <em>B</em>B，请你计算 <em>A</em>×<em>B</em>A×B 的值。</p><h4 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h4><p>共两行，第一行包含整数 <em>A</em>A，第二行包含整数 <em>B</em>B。</p><h4 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h4><p>共一行，包含 <em>A</em>×<em>B</em>A×B 的值。</p><h4 id="数据范围-2"><a href="#数据范围-2" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤<em>A</em>的长度≤1000001≤A的长度≤100000,<br>0≤<em>B</em>≤100000≤B≤10000</p><h4 id="输入样例：-2"><a href="#输入样例：-2" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure><h4 id="输出样例：-2"><a href="#输出样例：-2" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure><p>操作：记住 *<em>if(i&lt;A.size())  t+&#x3D;A[i]<em>b;</em></em></p><p>ps：注意条件判断是   <strong>(i&lt;A.size() || t)</strong></p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">string a;</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; A, ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;A.<span class="built_in">size</span>() || t;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;A.<span class="built_in">size</span>())  t+=A[i]*b;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(t%<span class="number">10</span>);</span><br><span class="line">        t/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(ans.<span class="built_in">size</span>()&gt;<span class="number">1</span> &amp;&amp; ans.<span class="built_in">back</span>()==<span class="number">0</span>)  ans.<span class="built_in">pop_back</span>();<span class="comment">// 一个数乘以</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=a.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)  A.<span class="built_in">push_back</span>(a[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=ans.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)    cout&lt;&lt;ans[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="高精度除法"><a href="#高精度除法" class="headerlink" title="高精度除法"></a>高精度除法</h2><blockquote><p><a href="https://www.acwing.com/problem/content/796/">794. 高精度除法 - AcWing题库</a></p></blockquote><p>给定两个非负整数（不含前导 00） <em>A</em>，<em>B</em>A，B，请你计算 <em>A</em>&#x2F;<em>B</em>A&#x2F;B 的商和余数。</p><h4 id="输入格式-3"><a href="#输入格式-3" class="headerlink" title="输入格式"></a>输入格式</h4><p>共两行，第一行包含整数 <em>A</em>A，第二行包含整数 <em>B</em>B。</p><h4 id="输出格式-3"><a href="#输出格式-3" class="headerlink" title="输出格式"></a>输出格式</h4><p>共两行，第一行输出所求的商，第二行输出所求余数。</p><h4 id="数据范围-3"><a href="#数据范围-3" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤<em>A</em>的长度≤1000001≤A的长度≤100000,<br>1≤<em>B</em>≤100001≤B≤10000,<br><em>B</em>B 一定不为 00</p><h4 id="输入样例：-3"><a href="#输入样例：-3" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">7</span><br><span class="line">2</span><br></pre></td></tr></table></figure><h4 id="输出样例：-3"><a href="#输出样例：-3" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>思路：核心记住  <strong>t&#x3D;t*10+A[i];</strong></p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">string a;</span><br><span class="line"><span class="type">int</span> b,t;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; A,C;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;A.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        t=t*<span class="number">10</span>+A[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>(t/b);</span><br><span class="line">        t%=b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(C.<span class="built_in">begin</span>(),C.<span class="built_in">end</span>()); <span class="comment">// 去前导零如100 / 100 会得到001 逆序删去前导零</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(C.<span class="built_in">size</span>()&gt;<span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>()==<span class="number">0</span>)    C.<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;a.<span class="built_in">size</span>();i++)     A.<span class="built_in">push_back</span>(a[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=C.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)  cout&lt;&lt;C[i];</span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;endl&lt;&lt;t&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多元统计分析及R语言建模</title>
      <link href="/posts/7aae9fe2.html"/>
      <url>/posts/7aae9fe2.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="22级期末考试题型"><a href="#22级期末考试题型" class="headerlink" title="22级期末考试题型"></a>22级期末考试题型</h3><hr><h4 id="一、选择题（10小题，20分）"><a href="#一、选择题（10小题，20分）" class="headerlink" title="一、选择题（10小题，20分）"></a>一、选择题（10小题，20分）</h4><h4 id="二、简答题（4小题，20分）"><a href="#二、简答题（4小题，20分）" class="headerlink" title="二、简答题（4小题，20分）"></a>二、简答题（4小题，20分）</h4><p>描述某个方法的核心步骤以及R程序、某个方法有何用途</p><h4 id="三、计算题（2小题，10分）"><a href="#三、计算题（2小题，10分）" class="headerlink" title="三、计算题（2小题，10分）"></a>三、计算题（2小题，10分）</h4><p>计算量简单</p><h4 id="四、案例分析题（4小题，40分）"><a href="#四、案例分析题（4小题，40分）" class="headerlink" title="四、案例分析题（4小题，40分）"></a>四、案例分析题（4小题，40分）</h4><p>对代码及运行结果解读，这个函数是什么功能？每个参数的解读</p><p>分别对应四章内容</p><h4 id="五、综合题（1题，10分）"><a href="#五、综合题（1题，10分）" class="headerlink" title="五、综合题（1题，10分）"></a>五、综合题（1题，10分）</h4><h3 id="期末复习"><a href="#期末复习" class="headerlink" title="期末复习"></a>期末复习</h3><hr><ul><li><p>在R语言中a[1]就代表着输出第一个元素</p></li><li><p>a &lt;- c(0,1,2)   a[c(1,3)]就代表着访问第一个和第三个元素</p></li><li><p>散点图数目与数据维度平方成正比</p></li><li><p>方差分析又称F检验 (F test)，用于推断多个总体均值有无显著差异</p></li><li><p><strong>F统计量中</strong> F&#x3D;组间方差（离差平方和&#x2F;自由度）&#x2F;组内方差，F值大说明变量之间存在关系</p></li><li><p>在统计学中，两个分类变量的列联表中的期望频数可以通过以下公式计算：</p><ul><li>(行合计)*(列合计)&#x2F;总样本量</li></ul></li><li><p>卡方独立性检验看p值</p></li><li><p>研究者通常会对因子载荷矩阵进行旋转，如正交旋转（varimax）或斜交旋转（oblimin），这样可以使得<strong>载荷在某个因子上集中</strong>，而在其他因子上接近零，从而使得因子的解释更加清晰和易于理解。</p></li><li><p>单因素方差分析（ANOVA）主要用来比较三个或者更多个样本组的总体均值是否存在显著差异。其基本假设是各组数据来自正态分布，且具有相同的方差。方差分析的核心在于分析组间差异是否显著大于组内差异。</p></li><li><p><strong>当 p 值小于 0.05 时，意味着我们拒绝零假设（null hypothesis）。</strong>在单因素方差分析中，零假设是指所有组的总体均值相等。因此，拒绝这一假设意味着至少有两组的总体均值存在显著差异，但并不意味着所有组的总体均值都不相等。</p></li><li><p>factor()函数用于<strong>创建因子变量</strong>，非数值型变量（类别变量和顺序变量）在R语言中称为因子，因子型变量内的所有为非重复值</p></li><li><p><code>glm()</code> 函数是R语言中用于拟合广义线性模型（Generalized Linear Models, GLMs）的函数。广义线性模型是线性模型的一种扩展，适用于不满足正态分布假设的数据，比如二项分布（逻辑回归）、泊松分布（泊松回归）</p></li><li><p>考虑到“Survived”是一个二分类变量，我们可以使用<strong>逻辑回归</strong>（Logistic Regression）来建立模型。<strong>逻辑回归</strong>适用于预测二元结果（是&#x2F;否，生还&#x2F;未生还）。</p></li><li><p>逻辑回归是一种用于处理二元结果的统计方法，通常用于预测某事件发生的概率。在R语言中，逻辑回归可以使用<code>glm</code>函数来实现，其中<code>family = binomial</code>表示二项分布。</p></li><li><p>泊松逻辑回归通常用于处理计数数据，比如事件发生的次数。</p></li><li><p>协方差矩阵的用途：</p><ul><li>刻画数据整体离散型</li><li>定义统计距离</li></ul></li><li><p><strong>rossTable( )—gmodels包</strong></p><ul><li><p>计算（行、列、单元格）的百分比</p></li><li><p>指定小数位数</p></li><li><p>进行卡方、Fisher和McNemar独立性检验</p></li><li><p>计算期望和（皮尔逊、标准化、调整的标准化）残差</p></li><li><p>将缺失值作为一种有效值</p></li><li><p>进行行和列标题的标注</p></li><li><p>生成SAS或SPSS风格的输出</p></li></ul></li><li><p><strong>chisq.test( )</strong></p><ul><li>检验列联表行列变量间是否存在显著性差异，或者用于检验变量之间是否独立</li></ul></li><li><p><strong>setwd()</strong></p><ul><li>查看文件属性，找出路径</li></ul></li></ul><h2 id="判别分析"><a href="#判别分析" class="headerlink" title="判别分析"></a>判别分析</h2><p>寻找一个投影方向，把两个群体分得最开的一种方法</p><p>样本均值投影的标准化距离最大</p><p>√ Fisher ‘s LDA对分布没有要求，但要求不同群体有相同协方差矩阵。</p><p>√Fisher ‘s LDA为线性判别方法，还有很多（非线性）判别函数的构造方式。</p><p>Fisher分类实际是在比较新观测对象yo与y1、y2间的马氏距离</p><h2 id="主成分分析"><a href="#主成分分析" class="headerlink" title="主成分分析"></a>主成分分析</h2><p>Standard deviation：标准差，其平方为方差&#x3D;特征值<br>Proportoin of Variance：方差贡献率<br>Cumulative Proportion：累积方差贡献率</p><ul><li>PCA &#x3D; prcomp(data_num , center &#x3D; T , scale. &#x3D; T)<ul><li>中心化和归一化所有数值变量，从而平等地考虑各个数值变量的影响</li></ul></li></ul><h4 id="主成分分析函数princomp-的用法："><a href="#主成分分析函数princomp-的用法：" class="headerlink" title="主成分分析函数princomp()的用法："></a>主成分分析函数princomp()的用法：</h4><p>princomp(x,cor&#x3D;FALSE,scores&#x3D;TRUE,…)</p><table><thead><tr><th>x</th><th>数据矩阵或数据框</th></tr></thead><tbody><tr><td>cor</td><td>是否用相关阵，默认为协差阵</td></tr><tr><td>scores</td><td>是否输出成分得分</td></tr></tbody></table><h2 id="各大分析方法的基本步骤"><a href="#各大分析方法的基本步骤" class="headerlink" title="各大分析方法的基本步骤"></a>各大分析方法的基本步骤</h2><h3 id="回归分析的基本步骤："><a href="#回归分析的基本步骤：" class="headerlink" title="回归分析的基本步骤："></a>回归分析的基本步骤：</h3><p>1、确定自变量和因变量</p><p>2、从样本数据出发确定变量之间的数学关系式,并对回归方程的各个参数进行估计</p><p>3、对回归方程进行各种统计检验</p><p>4、利用回归方程进行预测</p><h3 id="基本思想："><a href="#基本思想：" class="headerlink" title="基本思想："></a>基本思想：</h3><p>采集样本信息-&gt;回归分析（散点图）-&gt;回归方程-&gt;回归方程的显著性检验-&gt;对现实进行预测与控制</p><h3 id="自变量筛选："><a href="#自变量筛选：" class="headerlink" title="自变量筛选："></a>自变量筛选：</h3><img src="https://pencil1024.oss-cn-chengdu.aliyuncs.com/imgs/202407161440209.png" style="zoom:50%;" /><hr><img src="https://pencil1024.oss-cn-chengdu.aliyuncs.com/imgs/202407161442482.png" style="zoom:50%;" /><hr><img src="https://pencil1024.oss-cn-chengdu.aliyuncs.com/imgs/202407161442256.png" style="zoom:50%;" /><h2 id="Logistic"><a href="#Logistic" class="headerlink" title="Logistic"></a>Logistic</h2><p><code>family = binomial</code> 指定了使用二项逻辑回归模型来拟合数据</p><h3 id="D-W检验："><a href="#D-W检验：" class="headerlink" title="D-W检验："></a>D-W检验：</h3><p>一种检验序列自相关的方法</p><h3 id="多重共线性检验："><a href="#多重共线性检验：" class="headerlink" title="多重共线性检验："></a>多重共线性检验：</h3><p>VIF&gt;5，多重共线</p><p>​     hp    wt </p><p>1.766625 1.766625   </p><p><strong>分析：方差膨胀因子较小，无多重共线性。</strong>      </p><hr><p>期末考试题型大多都是作业上的（难受至极，因为通宵复习了一晚上的ppt……选择&gt;&gt;努力）</p><p>我来简单的复盘一下：</p><ul><li><p>一个 r*c 列联表，进行卡方独立性检验时检验统计量的自由度为？</p></li><li><p>单因素方差分析中，当 p 值小于 0.05 时，可认为？</p></li><li><p>Q 型聚类统计量是（ ），R 型聚类统计量是（ ）</p></li><li><p>请简述对线性回归系数进行标准化有何用处？</p></li><li><p>聚类分析的三步核心步骤与核心代码</p></li><li><p>主成分分析中主成分如何选择</p></li><li><p>箱型图的解释</p></li><li><p>SSA、SSB、SST…相关的计算</p></li><li><p>计算欧式距离与什么距离（忘了）</p></li><li><p>Fisher判别分析给出混淆矩阵分析（请记得算出判对率和判错率）</p></li><li><p>相关分析（记得从上到下，从左往右的分析）</p></li><li><p>最后一道是给出很多数据的的excel文件，请选择部分数据进行研究，给出多元统计分析方法和核心代码</p></li></ul><p>剩下的就记不到了。。祝各位好运！</p>]]></content>
      
      
      <categories>
          
          <category> 课程学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> R语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>马原期末复习</title>
      <link href="/posts/2a87fde6.html"/>
      <url>/posts/2a87fde6.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><h3 id="物质与意识的关系"><a href="#物质与意识的关系" class="headerlink" title="物质与意识的关系"></a>物质与意识的关系</h3><p>​基于辩证唯物主义的物质与意识的辩证关系理论，物质是意识产生的基础和前提，意识是物质世界在人脑中的反映，并且对物质具有能动的反作用。<br>1、首先，人工智能作为物质存在，是人类智能的延伸和扩展。它的产生和发展依赖于物质技术的进步，如计算机硬件、传感器、网络通信等。人工智能的智能活动是人类智能的物化，是对人脑组织结构与思维运行机制的模仿。(本质是物质)<br>2、其次，人工智能的发展受到人类社会实践活动的制约和指导。人类通过科学文化实践，创造和发展了人工智能技术。同时，人类也通过法律、伦理和社会规范等形式对人工智能的发展进行调控和引导,确保其符合人类社会的价值观和利益。(受物质实践的制约)<br>3、再次，人工智能作为一种新的物质力量，对人类社会和意识产生了深远的影响。它不仅改变了人类生产和生活方式，还拓展了人类认知的广度和思维的深度。同时，人工智能也对人类的意识形态、价值观和社会结构产生了挑战和冲击。(作为新的物质力量对人类社会的影响)<br>4、最后，尽管人工智能可以模拟和扩展人脑的某些活动，但是也不能达到人类智能的层级，不能真正具有人的意识，不能取代或超越人类智能。(但是超越不了人类意识)<br><strong>原因为：</strong><br>1、人工智能缺乏人类意识的核心要素，包括情感、信念和意志。人工智能的决策过程通常基于预设算法和数据分析，而非人类的情感驱动和道德考量。(不具备知情意)<br>2、人工智能虽然可以在一定程度上模拟人类的社交行为,但它不具备真正的社会属性。它不能像人类一样具有自我意识、自主性和社会责任感。(不具备社会属性)<br>3、人类的自然语言承载着文化和情感，是意识的现实形式。人工智能虽然可以处理和生成语言，但它难以真正理解语言背后的深层含义和情感色彩。(不能理解自然语言)<br>4、人工智能无法触及人类意识中那些无法量化为数字信号的部分，如潜意识和直觉，这些元素超出了人工智能当前的处理范围。(人脑中很多东西不能化约数字)<br>​综上所述，在人工智能飞速发展的条件下，我们应当坚持物质与意识的辩证关系理论，认识到人工智能作为物质存在和意识延伸的双重性质。同时，根据斯蒂芬 霍金的观点，人工智能的发展可能带来潜在的威胁，我们也应当关注人工智能对人类社会和意识的影响和挑战，积极应对和引导其发展，确保人工智能技术的发展符合人类社会的整体利益和长远发展。</p><h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><h3 id="实践与认识的辩证关系"><a href="#实践与认识的辩证关系" class="headerlink" title="实践与认识的辩证关系"></a>实践与认识的辩证关系</h3><p>一、实践决定认识</p><p>1、实践是认识的来源。认识只能在实践的基础上产生，正如毛泽东所说“要想知道梨子的味道，就得亲口尝一尝”，“不入虎穴焉得虎子”等，均说明了实践是认识的来源，而且是唯一来源。</p><p>2、实践是认识发展的动力。①农民种田推动了农学的产生，建筑业的需求推动了数学、建筑学等学科的发展，在实践中科技不断进步。②实践为认识发展提供必要的条件。比如显微镜的发明、我国最大的球面射电望远镜FAST的出现等促进了认识的发展，生产力进步。③实践锻炼和提高了主体的认识能力。</p><p>3、实践是认识的目的。我国发展科技创新目的就是增进民生福祉</p><p>4、实践是检验认识真理性的唯一标准。就像伽利略质疑亚里士多德提出两个铁球同时着地，只有通过实践才能检验。</p><p>二、认识对实践的指导作用</p><p>认识对实践反作用具有两重性：</p><p>1、正确的认识对实践起着积极的促进作用</p><p>2、错误的认识则对实践起消极的阻碍作用，甚至导致实践的失败</p><h3 id="真理与价值的辩证统一关系"><a href="#真理与价值的辩证统一关系" class="headerlink" title="真理与价值的辩证统一关系"></a>真理与价值的辩证统一关系</h3><p>1、人们的实践活动总是受着真理尺度和价值尺度的制约。在实践中，真理既是制约实践的客观尺度，又是实践追求的价值目标之一;而价值则是实践追求的根本目标，又是制约实践的主体尺度，真理和价值在实践基础上是辩证统一的</p><p>2、任何成功的实践必然是以真理和价值的辩证统一为前提，是合规律性和合目的性的统一</p><p>3、真理与价值是紧密联系、不可分割的辩证统一 关系，价值的形成和实现以坚持真理为前提，而真理又必然是具有价值的。</p><p>4、新时代中国特色社会主义的伟大实践，充分体现了真理尺度与价值尺 度的辩证统一。</p><p>5、真理和价值在实践和认识活动中是相互制约、相互引导、相互促进的。中国共产党人的理想信念，建立在马克思主义科学真理的基础之上，建立在马克思主义揭示的人类社会发展规律的基础之上，建立在为最广大人民谋利益的崇高价值的基础之上。</p><h2 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h2><h3 id="人民群众是历史创造者的原理"><a href="#人民群众是历史创造者的原理" class="headerlink" title="人民群众是历史创造者的原理"></a>人民群众是历史创造者的原理</h3><p>1、人民群众是社会历史的主体，是历史的创造者；</p><p>2、在社会历史发展过程中，人民群众起着决定性的作用；</p><p>3、人民群众是社会物质财富的创造者；</p><p>4、人民群众是社会精神财富的创造者；</p><p>5、人民群众是社会变革的决定力量；</p><p>6、人民群众创造历史的活动要受到一定社会历史条件的制约</p><h3 id="社会意识对社会存在的反作用原理"><a href="#社会意识对社会存在的反作用原理" class="headerlink" title="社会意识对社会存在的反作用原理"></a>社会意识对社会存在的反作用原理</h3><p>社会存在和社会意识是辩证统一的。</p><p>社会存在决定社会意识；社会意识是社会存在的反映</p><p>社会意识具有相对独立性：</p><p>1、社会意识与社会存在发展具有不完全同步性和不平衡性。进步的 社会意识可以在一定程度上预见、推断未来，指导人们的实践活动；落后于社会存在的社会意识则阻碍社会的发展。</p><p>2、社会意识内部各种形式之间存在相互影响且各自具有历史继承性。社会生活的内在联系及其统一性，决定了社会意识诸形式之间也必然是相互影响、相互作用的。</p><p>3、社会意识对社会存在具有能动的反作用，这是社会意识相对独立性的突出表现。任何社会意识都不会凭空出现，只能是适应一定社会物质 生活发展的要求而产生的，因而它必然具有满足这些要求的功能和价值, 在一定条件下会转化为物质力量并作用于社会存在，影响历史的发展。先进的社会意识反映了社会发展的趋势和要求，对社会发展起着积极的促进 作用；落后的社会意识不符合社会发展的趋势和要求，对社会发展起着消极的阻碍作用。</p><p><strong>脱贫攻坚精神（精神文化）在社会发展中的作用</strong></p><p>为实现全体人民共同富裕提供精神力量；推进乡村振兴；有利于国家的长治久安；有利于巩固党的执政；有利于全面建设小康社会。 </p><p>1、文化为社会发展提供思想指引。</p><p>2、文化为社会发展提供精神动力。</p><p>3、文化为社会发展提供凝聚力量。</p><h2 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h2><h3 id="剩余价值量的计算"><a href="#剩余价值量的计算" class="headerlink" title="剩余价值量的计算"></a>剩余价值量的计算</h3><p><a href="https://www.bilibili.com/video/BV1q34y1H78x/?spm_id_from=333.337.search-card.all.click&vd_source=c1c4128300770265cb4dc28a7adf6788">十分钟通透政经计算题（剩余价值率、有机构成）_哔哩哔哩_bilibili</a></p><h3 id="剩余价值理论的认识"><a href="#剩余价值理论的认识" class="headerlink" title="剩余价值理论的认识"></a>剩余价值理论的认识</h3><p>剩余价值既不是由全部资本创造的，也不是由不变资本创造的, 而是由可变资本雇佣的劳动者创造的。就应该用剩余价值 和雇佣劳动者的可变资本相比，而不应该把它去同全部资本相比，用公式表示m’&#x3D;m&#x2F;v (m’ 为剩余价值率，m为剩余价值，v为可变资本)资本家提高对工人剥削程度的方法是多种多样的，其中最基本的为绝对剩余价值的生产和相对剩余价值的生产。资本主义生产的唯一动机和直接目的就是追求剩余价值，但客观上也会促进生产力的发展和社会进步。把剩余价值转化为资本就是资本积累，资本积累不但是社会财富占有两极分化的重要原因，而且是资本主义社会失业现象产生的根源（追求更高利益，提高技术和效率，减少成本）。 影响资本周转快慢关键的因素有两个：一是资本周转的时间，二是生产资本的固定资本和流动资本构成。要加快资本周转速度，获得更多剩余价值，就要缩短资本周转时间，加快流动资本的周转速度。在资本主义制度下，工人的工资是劳动力的价值或价格，这是资本主义工资的本质。剩余价值率是剩余价值与可变资本的比率，反映的是资本家对工人的剥削程度；利润率则是剩余价值与全部预付资本的比率，反映的是 预付总资本的增殖程度，掩盖了资本家对工人的剥削。剩余价值理论深刻 揭露了资本主义生产关系的剥削本质，阐明了资产阶级与无产阶级之间阶级斗争的经济根源，指出了无产阶级革命的历史必然性。剩余价值理论是 马克思经济学说的核心内容和基石，是无产阶级反对资产阶级、揭示资本 主义制度剥削本质的锐利武器。由于唯物史观和剩余价值理论的发现，社 会主义由空想变为科学。</p><hr><p>好消息，上面精心准备的都没考！！！</p><p>22级马原的期末考了大致如下：</p><p>一、谈谈如何理解马克思主义物质观及其现代意义（没考物质与意识）</p><p>二、真理与价值的辩证统一关系（没考实践与认识的关系）</p><p>三、请结合人民群众是历史创造者的原理，谈谈对“江山就是人民，人民就是江山”的理解。（没考社会意识与社会存在的关系）</p><p>四、这不用说了先（1）20分的计算题，然后（2）20分的500字的八股文，默写对剩余价值理论的认识</p>]]></content>
      
      
      <categories>
          
          <category> 课程学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 马原 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式计算系统</title>
      <link href="/posts/56a171cd.html"/>
      <url>/posts/56a171cd.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Hadoop"><a href="#Hadoop" class="headerlink" title="Hadoop"></a>Hadoop</h2><h3 id="HDFS的存储思想"><a href="#HDFS的存储思想" class="headerlink" title="HDFS的存储思想"></a>HDFS的存储思想</h3><ul><li>文件分块存储：将大文件分成块，块的大小设置为128mb，这些文件块可以分布到集群中不同的节点上，令多个节点对逻辑层面的大文件在物理层面进行分布式存储</li><li>分块冗余存储：HDFS将大文件切分成块，每个小块同时进行冗余备份</li><li>简化文件读写：一次写入，多次读取，可避免读写冲突</li></ul><h3 id="NameNode是如何备份的"><a href="#NameNode是如何备份的" class="headerlink" title="NameNode是如何备份的"></a>NameNode是如何备份的</h3><ul><li><p>edits、fsimage</p></li><li><p>Secondary NameNode来做定期的元数据的合并，让edits文件的部分合并到fsimage中去，保证内存比较小</p></li><li><p>HA高可用</p></li></ul><h3 id="文件的读写"><a href="#文件的读写" class="headerlink" title="文件的读写"></a>文件的读写</h3><p>block的拆分是在客户端中进行的</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>hadoop fs || hdfs dfs</p><h2 id="MapReduce（批处理）"><a href="#MapReduce（批处理）" class="headerlink" title="MapReduce（批处理）"></a>MapReduce（批处理）</h2><img src="https://pencil1024.oss-cn-chengdu.aliyuncs.com/imgs/202407161150799.png" alt="MapReduce" style="zoom: 50%;" /><ul><li><p>Map(&lt;k,v&gt;键值对) -&gt; Reduce中间有Shuffle阶段如何将相同的k值合并到同一个reduce就用<strong>哈希取模</strong>将k值进行数字编码然后模上个数</p></li><li><p>每个block块会启动一个Map任务</p></li><li><p>每个reduce任务会输出一个结果文件，存放在一个数据目录下</p></li><li><p><strong>combine方法</strong>是一种“局部”的reduce操作，<strong>好处：</strong>不仅能降低Map和Reduce任务消耗的存储空间，还能够有利于降低Shuffle过程中传输的数据量</p></li><li><p>关系表自然连接</p><ul><li>map和reduce</li><li>如果一张表非常大一张表非常小怎么处理：通过MapReduce提供的<strong>分布式缓存机制</strong>对较小的关系表进行广播来解决，可以避免Shuffle过程，为整个关系表的连接带来了性能的提升</li></ul></li></ul><h2 id="Spark（批处理）"><a href="#Spark（批处理）" class="headerlink" title="Spark（批处理）"></a>Spark（批处理）</h2><ul><li>Spark基于<strong>RDD（弹性分布式数据集）</strong>进行计算</li><li>RDD是<strong>只读</strong>的，对原RDD进行修改之后要用新的RDD来保存</li><li>RDD的操作算子（<strong>创建</strong>操作算子、<strong>转换</strong>操作算子、<strong>行动</strong>操作算子）</li></ul><img src="https://pencil1024.oss-cn-chengdu.aliyuncs.com/imgs/202407161150423.png" alt="Spark" style="zoom:50%;" /><ul><li>主从结构</li></ul><img src="https://pencil1024.oss-cn-chengdu.aliyuncs.com/imgs/202407161150193.png" alt="Spark" style="zoom:50%;" /><ul><li>Spark可分为Standalone和Yarn两种模式</li><li>Standalone集群管理器包含Master和Worker</li><li>Yarn集群管理器包含ResourceManager和NodeManager</li><li>集群管理器负责集群资源管理，而驱动器负责作业管理</li><li>RDD之间存在依赖关系，窄依赖是<strong>一对一</strong>，宽依赖是<strong>多对一</strong></li><li>RDD的<strong>持久化</strong>：<ul><li>原因：因为计算过程会不断产生新的RDD，因此系统无法将所有的RDD均存储于内存中，内存是有限的，所以要持久化</li><li>调用RDD的<strong>persist(Storagelevel)方法</strong>或<strong>cache()方法</strong>实现持久化</li></ul></li><li>在Lineage较长尤其存在<strong>宽依赖</strong>时，需要在适当的时机设置<strong>数据检查点</strong><ul><li>检查点机制将RDD写入可靠的外部分布式文件系统，例如HDFS。如果用户指定某些RDD需要设置检查点，则系统将在作业结束之后启动一个独立的作业进行写检查点操作</li><li>检查点机制作用：防止因<strong>RDD Lineage</strong>过长而导致恢复过程中重计算的开销过大</li></ul></li><li>关系表自然连接中，Spark提供<strong>广播变量机制</strong>，将较小的关系表作为广播变量进行广播</li></ul><h2 id="Yarn（资源管理系统）"><a href="#Yarn（资源管理系统）" class="headerlink" title="Yarn（资源管理系统）"></a>Yarn（资源管理系统）</h2><ul><li><p><strong>FIFO（先进先出调度器）</strong></p><ul><li>调度策略：将所有任务放入一个队列，先进队列的先获得资源，排在后面的任务只有等待</li><li>缺点：资源利用率低，无法交叉运行任务，一个应用独占所有资源而其他应用需要不断等待，以及灵活性差，如紧急任务无法插队，耗时长的任务拖慢耗时短的任务</li></ul></li><li><p><strong>capacity（容量调度器）</strong></p><ul><li>调度策略：集群资源由多个队列分享，每个队列都要预设资源分配的比例，空闲资源优先分配给“实际资源&#x2F;预算资源”比值最低的队列，队列内部采用FIFO调度策略</li><li>特点：<ul><li>层次化的队列设计:子队列可使用父队列资源</li><li>容量保证:每个队列都要预设资源占比，防止资源独占，</li><li>弹性分配:空闲资源可以分配给任何队列，当多个队列争用时，会按比例进行平衡</li><li>支持动态管理:可以动态调整队列的容量、权限等参数，也可动态增加、暂停队列</li><li>访问控制:用户只能向自己的队列中提交任务，不能访问其他队列</li><li>多租户:多用户共享集群资源</li></ul></li></ul></li><li><p><strong>Fair（公平调度器）</strong></p><ul><li>调度策略:多队列公平共享集群资源，通过平分的方式，动态分配资源，无需预先设定资源分配比例，队列内部可配置调度策略:FIFO、Fair（默认）</li><li>特点：<ul><li>资源抢占：终止其他队列的任务，使其让出所占资源，然后将资源分配给占用资源量少于最小资源量限制的队列</li><li>队列权重：当队列中有任务等待，并且集群中有空闲资源时，每个队列可以根据权重获得不同比例的空闲资源</li></ul></li></ul></li></ul><h2 id="Storm（流计算系统）"><a href="#Storm（流计算系统）" class="headerlink" title="Storm（流计算系统）"></a>Storm（流计算系统）</h2><ul><li>数据模型：将流数据看作一个无界的、连续的<strong>元组序列</strong></li><li>Storm使用<strong>拓扑抽象</strong>描述计算过程，拓扑是由<strong>Spout</strong>和<strong>Bolt</strong>组成的网格</li><li>Bolt中可执行过滤、聚合、查询数据库等操作对元组进行转换，并将处理后的元组作为新的流数据发送给其他Bolt</li><li>Storm以Executor作为工作线程而在Task中仅实现任务代码</li><li>Storm的<strong>ACK机制</strong>用于确保消息处理的可靠性，保证每个消息都会被至少处理一次</li><li>词频统计中的ShuffleGrouping和FieldsGrouping</li></ul><h2 id="Spark-Streaming（实时流计算系统）"><a href="#Spark-Streaming（实时流计算系统）" class="headerlink" title="Spark Streaming（实时流计算系统）"></a>Spark Streaming（实时流计算系统）</h2><ul><li>Spark Streaming采用<strong>微批</strong>处理方式，将连续的流数据进行切片（按时间间隔离散化），生成一系列小块数据</li><li>增量式是避免重复计算</li><li><strong>数据检查点</strong>旨在加快<strong>执行器</strong>发生故障后的恢复过程</li><li><strong>元数据检查点</strong>旨在保证驱动器能够从故障中恢复到正常状态</li></ul><h2 id="Flink（批流融合系统）"><a href="#Flink（批流融合系统）" class="headerlink" title="Flink（批流融合系统）"></a>Flink（批流融合系统）</h2><ul><li>Flink程序使用DataStream类表示<strong>无界</strong>数据，其为一个可以包含重复项的<strong>不可变</strong>数据集合</li><li><strong>DataSet</strong>和<strong>DataStream</strong>的区别<ul><li>相同：记录是不可变的</li><li>不同：DataSet是<strong>有界</strong>的，而DataStream是<strong>无界</strong>的</li></ul></li><li>在Standalone模式下，除客户端外，Flink系统仅具有<strong>JobManager</strong>和<strong>TaskManager</strong></li><li>在Standalone模式下，当用户使用客户端提交Flink应用程序时，可以选择<strong>Attached方式</strong>或者<strong>Detached方式</strong><ul><li>Attached提交方式下客户端与<strong>JobManager</strong>保持连接，可以获取关于应用程序执行的信息</li><li>Dettached提交方式下客户端与<strong>JobManager</strong>断开连接，无法获取关于应用程序执行的信息</li></ul></li><li>Flink使用<strong>Chaining机制</strong>进行优化，将部分算子合并为一个”大“的算子，可以避免数据在不同<strong>TaskManager</strong>之间的非必要传输</li><li>状态管理<ul><li>原因：在个别节点发生故障的情况下自定义于内存中的数据结构将会丢失，故障恢复需要将过去所有数据重新计算</li><li>状态：状态可以看作操作算子的记忆能力，可以保留已处理记录的结果，并对后续记录的处理造成影响</li><li>map是一种典型的<strong>无状态</strong>算子，sum、window为<strong>有状态</strong>算子</li></ul></li><li>非迭代计算过程的容错<ul><li>异步屏障快照算法：通过在输入数据中注入屏障并异步地保存快照，达到和在同一时刻保存所有算子状态到检查点相同的目的</li></ul></li></ul><hr><p>​sb分布式Teacher（点名yqe），平时只有签到啥都没，一次作业没布置过，平时分给85。。期末第一次做题。期末画重点把整本书都画了但是只考了一部分 。（Yarn和Storm没考）最后一周期末周安排实验课，整整上了两天上午8点到下午5点，最开始布置了50个实验，因为太多，有同学去反应砍了一些，但还是很多，巨多。没法只能通宵！肝了两整天90多页word吧（唉，早知道不花这么多时间写这些傻逼报告了，准备期末不好嘛。。选择&gt;&gt;努力）这学期活的真窝囊啊，一直连着写了20多天的报告。刚刚好马原考前一天结束了大部分报告（最后剩了一门计网的大作业报告）。最后一天开始复习，看来马原居然还是复习得最久的！（仅一天罢了）。果不其然这学期炸了，没好好复习的结果，数据结构连基数排序是啥都不知道，直接送了15分~</p><p>​扯远了，我还记得一些些，来简单复盘一下：</p><p>​考的大致如下，全是一些画流程图的，一次没做过咋画()G</p><ul><li>每个大题好像都有两个小问， 第一问是八股文，背书就行，就例如请写出HDFS上传文件的过程，什么是宽依赖什么是窄依赖等</li><li>每个大题的第二问都是类似画出流程图的，因为每个题都是个实际的问题，就例如请用MapReduce来处理、Spark来处理…等</li><li>依稀记得我们考了HDFS文件的读取操作</li><li>MapReduce操作+分析画图</li><li>Spark操作+分析画图</li><li>Spark Streaming操作+分析画图</li><li>Flink操作+分析画图</li><li>每个题好像20分？记不太清了反正（1）好像都是5分</li><li>然后（1）我记得的考了HDFS读文件操作，简述什么是宽依赖什么是窄依赖，简述Chaining机制，Flink中的状态管理是什么。我记得的只有这些了</li></ul>]]></content>
      
      
      <categories>
          
          <category> 课程学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统简述</title>
      <link href="/posts/7a81549d.html"/>
      <url>/posts/7a81549d.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><h3 id="第一章操作系统引论"><a href="#第一章操作系统引论" class="headerlink" title="第一章操作系统引论"></a>第一章操作系统引论</h3><p><strong>操作系统：</strong>是<code>一组</code>控制和管理计算机硬件和软件资源，合理地组织计算工作流程，以及方便用户使用的<code>程序集合</code></p><h4 id="一、操作系统系统目的、目标"><a href="#一、操作系统系统目的、目标" class="headerlink" title="一、操作系统系统目的、目标"></a>一、操作系统系统目的、目标</h4><ul><li>使计算机系统更易于使用（方便性）</li><li>以一种效率的方式使用资源（有效性）</li><li>采用模块化结构，已与增、删、改（可扩充性）</li><li>要求统一开放环境，能通过网络集成化并正确、有效地协同工作，实现应用程序的移植（开放性）</li></ul><h4 id="二、计算机系统组成"><a href="#二、计算机系统组成" class="headerlink" title="二、计算机系统组成"></a>二、计算机系统组成</h4><img src="https://pencil1024.oss-cn-chengdu.aliyuncs.com/imgs/202407161340062.png" alt="image-20240527103841941" style="zoom: 67%;" /><p><strong>操作系统的的地位：</strong>紧贴系统硬件之上，所有其他软件之下（是其他软件的共同环境）</p><h4 id="三、操作系统的作用"><a href="#三、操作系统的作用" class="headerlink" title="三、操作系统的作用"></a>三、操作系统的作用</h4><ul><li>Os作为用于与计算机硬件系统之间的接口</li><li>Os作为计算机系统资源的管理者</li><li>Os作为扩充机器</li></ul><h4 id="四、操作系统的基本特征"><a href="#四、操作系统的基本特征" class="headerlink" title="四、操作系统的基本特征"></a>四、操作系统的基本特征</h4><ul><li>并发</li><li>共享</li><li>虚拟</li><li>异步性</li></ul><p><strong>并发：</strong>指在计算机系统中同时存在着多道运行的程序（进程）宏观上：多道程序同时在执行；微观上：任何时刻只有一道程序在执行，即微观上多道程序在CPU上轮流（交替）执行（单机）</p><p><strong>并行：</strong>与并发相似，指多道程序在同一时刻执行，但需多个硬件支持。</p><blockquote><p>并发是操作系统最重要的特征，其它特征均以并发为前提。                </p></blockquote><p><strong>共享：</strong>指系统中的资源不再为某道程序所独占，而是供多道程序共同使用。</p><p>资源共享方式：互斥共享式、同时访问式</p><p><strong>虚拟：</strong>把一个<code>物理实体</code>映射为若干个对应的<code>逻辑实体</code>——分时或分空间</p><blockquote><p>虚拟是操作系统管理系统资源的重要手段，可提高资源利用率</p></blockquote><p>如：虚拟处理机、虚拟存储器、虚拟设备</p><p><strong>异步性：</strong>也称不确定性，指进程在执行中，其执行时间、顺序、向前推进的速度和完成的时间等都是不可预知的。</p><h4 id="五、操作系统的功能"><a href="#五、操作系统的功能" class="headerlink" title="五、操作系统的功能"></a>五、操作系统的功能</h4><ul><li>处理机管理</li><li>存储器管理</li><li>设备管理</li><li>文件管理</li><li>用户接口</li></ul><h5 id="（1）处理机管理的功能"><a href="#（1）处理机管理的功能" class="headerlink" title="（1）处理机管理的功能"></a>（1）处理机管理的功能</h5><ul><li><p>处理机管理的主要任务</p><ul><li><p>是对处理机进行<code>分配</code></p></li><li><p>对处理机<code>运行进行有效的控制和管理</code></p></li></ul></li></ul><p>​注：处理机的分配和运行以进程为基本单位，因此对处理机的管理可归结于对进程的管理</p><ul><li>处理机管理的功能<ul><li>进程管理</li><li>进程同步</li><li>进程通信</li><li>调度</li></ul></li></ul><h5 id="（2）存储器管理的功能"><a href="#（2）存储器管理的功能" class="headerlink" title="（2）存储器管理的功能"></a>（2）存储器管理的功能</h5><ul><li>主要任务<ul><li>为多道程序的运行提供良好的环境</li><li>方便用户使用存储器</li><li>提高存储器的利用率</li><li>从逻辑上扩充内存</li></ul></li><li>功能<ul><li>内存分配</li><li>内存保护</li><li>地址映射</li><li>内存扩充</li></ul></li></ul><h5 id="（3）设备管理的功能"><a href="#（3）设备管理的功能" class="headerlink" title="（3）设备管理的功能"></a>（3）设备管理的功能</h5><ul><li>主要任务<ul><li>完成用户提出的I&#x2F;O请求</li><li>为用户分配I&#x2F;O设备</li><li>提高I&#x2F;O设备的利用率及速度</li><li>方便用户使用I&#x2F;O设备</li></ul></li><li>功能<ul><li>缓冲管理</li><li>设备分配</li><li>设备处理</li><li>虚拟设备</li></ul></li></ul><h5 id="（4）文件管理的功能"><a href="#（4）文件管理的功能" class="headerlink" title="（4）文件管理的功能"></a>（4）文件管理的功能</h5><ul><li>主要任务<ul><li>对用户文件和系统文件进行管理</li><li>方便用户使用文件</li><li>保证文件的安全性</li></ul></li><li>功能<ul><li>文件存储空间的管理</li><li>目录管理</li><li>文件的读、写管理</li><li>文件的共享与保护</li></ul></li></ul><h5 id="（5）用户接口管理的功能"><a href="#（5）用户接口管理的功能" class="headerlink" title="（5）用户接口管理的功能"></a>（5）用户接口管理的功能</h5><ul><li>主要任务<ul><li>方便用户使用操作系统</li></ul></li><li>功能<ul><li>命令接口</li><li>程序接口（系统调用）</li><li>图形接口</li></ul></li></ul><h3 id="第二章进程管理"><a href="#第二章进程管理" class="headerlink" title="第二章进程管理"></a>第二章进程管理</h3><h4 id="一、进程（process）的概念"><a href="#一、进程（process）的概念" class="headerlink" title="一、进程（process）的概念"></a>一、进程（process）的概念</h4><h5 id="1、进程的定义"><a href="#1、进程的定义" class="headerlink" title="1、进程的定义"></a>1、进程的定义</h5><p>（1）进程是程序的一次执行</p><p>（2）进程是一个程序及其数据在处理机上顺序执行时所发生的活动</p><p>（3）进程是程序在一个数据集合上的运行过程，<strong>它是系统进行资源分配和调度的一个独立单位</strong></p><h5 id="2、进程与程序的区别"><a href="#2、进程与程序的区别" class="headerlink" title="2、进程与程序的区别"></a>2、进程与程序的区别</h5><p>（1）程序是指令的有序集合，其本身没有任何运行的含义，它是一个<strong>静态</strong>的概念。而进程是程序在处理机上的一次执行过程，它是一个<strong>动态</strong>概念。</p><p>（2）程序的<strong>存在是永久</strong>的。而<strong>进程则是有生命期</strong>的，它因创建而产生，因调度而执行，因得不到资源而暂停，因撤消而消亡。</p><p>（3）程序仅是<strong>指令的有序集合</strong>。而进程则由<strong>程序段、相关数据段和进程控制块（PCB）</strong>组成。</p><p>（4）<strong>进程与程序之间不是一一对应</strong>。</p><h5 id="3、进程的特征"><a href="#3、进程的特征" class="headerlink" title="3、进程的特征"></a>3、进程的特征</h5><p>（1）<strong>结构特征</strong>：为了描述和记录进程的运动变化过程，并使之能正确运行，每个进程都应配置了一个进程PCB。所以，从结构上看，每个进程（进程实体）都是由<strong>程序段、相关数据段及进程控制块（PCB）</strong>组成。</p><p>（2）<strong>动态性</strong>：进程的实质是<strong>程序在处理机上的一次执行过程</strong>，因此是动态性的。所以动态性是进程的最基本的特征。同时动态性还表现在 <strong>进程则是有生命期</strong>的，它因创建而产生，因调度而执行，因得不到资源而暂停，因撤消而消亡。</p><p>（3）<strong>并发性</strong>：指多个进程实体同时存在于内存中，能在一段时间内同时运行。引入进程的目的就是为了使进程能并发执行，以提高资源利用率，所以并发性是进程的重要特征，也是OS的重要特征。</p><p>（4）<strong>独立性</strong>：指进程是一个能独立运行的基本单位，也是系统进行资源分配和调度的独立单位。</p><p>（5）<strong>异步性</strong>：指进程以各自独立的、不可预知的速度向前推进。</p><h4 id="二、进程的状态"><a href="#二、进程的状态" class="headerlink" title="二、进程的状态"></a>二、进程的状态</h4><h5 id="1、三种基本状态"><a href="#1、三种基本状态" class="headerlink" title="1、三种基本状态"></a>1、三种基本状态</h5><ul><li><strong>就绪态</strong>：进程已获得了除<code>处理机</code>以外的所有资源，等待分配处理机执行的等待状态。</li><li><strong>执行态</strong>：当一个进程获得必要的资源并正在处理机上执行的状态。</li><li><strong>阻塞态</strong>：正在执行的进程由于发生某事件而暂时无法执行下去，此时进程所处的状态。</li></ul><p>进程在运行期间并非固定处于某个状态，而是不断从一个状态转换到另一个状态。</p><h5 id="2、状态转换"><a href="#2、状态转换" class="headerlink" title="2、状态转换"></a>2、状态转换</h5><img src="https://pencil1024.oss-cn-chengdu.aliyuncs.com/imgs/202407161342258.png" style="zoom:67%;" /><h5 id="3、进程的挂起-静止状态"><a href="#3、进程的挂起-静止状态" class="headerlink" title="3、进程的挂起&#x2F;静止状态"></a>3、进程的挂起&#x2F;静止状态</h5><p>程序在运行期间，由于某种需要，往往要将进程暂停执行，使其静止下来，以满足其需要。这种静止状态就称为进程的挂起状态。</p><h5 id="4、引起挂起状态的原因"><a href="#4、引起挂起状态的原因" class="headerlink" title="4、引起挂起状态的原因"></a>4、引起挂起状态的原因</h5><ul><li><p><strong>终端用户的需要</strong>：终端用户在自己程序运行中发现问题要求使正在执行的进程暂停执行而使进程处于挂起状态。</p></li><li><p><strong>父进程的需要：</strong>父进程为了考查和修改某个子进程，或者协调各子进程间的活动，需要将该子进程挂起。</p></li><li><p><strong>操作系统的需要：</strong>操作系统为了检查运行中的资源使用情况或进行记 帐，而将某些进程挂起。</p></li><li><p><strong>对换的需要：</strong>为了提高内存的利用率，而将内存中某些进程挂起，以调进其它程序运行。</p></li><li><p><strong>负荷调节的需要：</strong>由于工作负荷较重，而将一些不重要的进程挂起，以保证系统能正常运行（实时操作系统）</p></li></ul><h5 id="5、具有挂起状态的进程状态"><a href="#5、具有挂起状态的进程状态" class="headerlink" title="5、具有挂起状态的进程状态"></a>5、具有挂起状态的进程状态</h5><img src="https://pencil1024.oss-cn-chengdu.aliyuncs.com/imgs/202407161340067.png" alt="image-20240527114851073" style="zoom:67%;" /><h4 id="三、进程控制块（Process-Control-Block-PCB）"><a href="#三、进程控制块（Process-Control-Block-PCB）" class="headerlink" title="三、进程控制块（Process Control Block PCB）"></a>三、进程控制块（Process Control Block PCB）</h4><h5 id="1、进程控制块的概念"><a href="#1、进程控制块的概念" class="headerlink" title="1、进程控制块的概念"></a>1、进程控制块的概念</h5><p>是操作系统为了管理和控制进程的运行而为每一个进程定义的一个<code>数据结构</code>，它记录了系统管理进程所需的全部信息。系统根据PCB而感知进程的存在，PCB是进程存在的<code>唯一</code>标志。</p><h5 id="2、作用"><a href="#2、作用" class="headerlink" title="2、作用"></a>2、作用</h5><p>（1）是OS对并发执行的进程进行控制和管理的根据。</p><p>（2）也是系统用来感知进程存在的根据，即PCB是进程存在的唯一标志。</p><h5 id="3、进程控制块PCB中的信息"><a href="#3、进程控制块PCB中的信息" class="headerlink" title="3、进程控制块PCB中的信息"></a>3、进程控制块PCB中的信息</h5><p>根据操作系统的要求不同，PCB所包含信息有些不同，但通常包含以下信息：</p><p>（1）<strong>进程标志符</strong>：由系统创建进程时分配给进程的唯一标识号，通常为一整数，称为进程号，用于区分不同的进程。其所属用户通常也为一整数，称为用户号。</p><p>（2）<strong>处理机状态（断点信息）</strong>：即处理机中各种寄存器（通用寄存器、PC、PSW等）的内容</p><p>（3）<strong>进程调度</strong>：记录了进程调度的相关信息（状态、优先级、事件等）。</p><p>（4）<strong>进程控制</strong>：记录了系统对进程控制的信息（程序和数据的地址、同步机制、资源清单、链接指针）</p><h5 id="4、进程控制块PCB的组织方式"><a href="#4、进程控制块PCB的组织方式" class="headerlink" title="4、进程控制块PCB的组织方式"></a>4、进程控制块PCB的组织方式</h5><p>（1）链接方式</p><p>（2）索引方式</p><hr><p>未完待续…….（因为期末变成大作业了，开摆！）</p><h3 id="专有名词解释"><a href="#专有名词解释" class="headerlink" title="专有名词解释"></a>专有名词解释</h3><h5 id="1-批处理"><a href="#1-批处理" class="headerlink" title="[1]批处理"></a><strong>[1]批处理</strong></h5><p>程序或作业在计算机上执行过程中不必人工干预的任务处理方式</p><h5 id="2-优先级调度"><a href="#2-优先级调度" class="headerlink" title="[2]优先级调度"></a><strong>[2]优先级调度</strong></h5><p>一种进程调度策略，根据进程优先级选择下一个要占用处理器的就绪进程</p><h5 id="3-死锁"><a href="#3-死锁" class="headerlink" title="[3]死锁"></a><strong>[3]死锁</strong></h5><p>多个事物竞争共享的数据对象而处于永远等待的状态</p><h5 id="4-系统资源"><a href="#4-系统资源" class="headerlink" title="[4]系统资源"></a><strong>[4]系统资源</strong></h5><p>一个计算机系统能被单独分配给计算任务的软件和硬件的总称，例如运算处理部件、存储器、输入&#x2F;输出设备、程序库、数据库等</p><h5 id="5-信号量"><a href="#5-信号量" class="headerlink" title="[5]信号量"></a><strong>[5]信号量</strong></h5><p>一种取值为整数的变量，表示可用的临界资源数目或等待资源的进程数，进程调用PV原语改变该变量的值，用来实现进程间同步或互斥</p><h5 id="6-控制块"><a href="#6-控制块" class="headerlink" title="[6]控制块"></a><strong>[6]控制块</strong></h5><p>唯一标识操作系统内核对象并保存其属性的专用数据结构、用于管理控制该内核对象，如进程控制块、文件控制块等</p><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><h4 id="并发和并行的区别"><a href="#并发和并行的区别" class="headerlink" title="并发和并行的区别"></a>并发和并行的区别</h4><p><strong>并发：</strong>指一个处理器同时处理多个任务（在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行）</p><p><strong>并行：</strong>指在同一时刻，有多条指令在多个处理器上同时执行（无论从微观还是从宏观来看，二者都是一起执行的）</p><h4 id="创建一个新的进程时的步骤是"><a href="#创建一个新的进程时的步骤是" class="headerlink" title="创建一个新的进程时的步骤是"></a>创建一个新的进程时的步骤是</h4><p>（1）需要申请一个空白PCB</p><p>（2）为新进程分配资源</p><p>（3）初始化PCB</p><p>（4）将新进程插入就绪队列</p><p>选择实时调度算法的重要准则是<strong>截止时间的保证</strong></p><h4 id="死锁的四个必要条件"><a href="#死锁的四个必要条件" class="headerlink" title="死锁的四个必要条件"></a>死锁的四个必要条件</h4><p>（1）互斥条件（资源互斥是资源使用的固有特性是无法改变、破坏的）</p><p>（2）请求和保持条件</p><p>（3）非剥夺条件</p><p>（4）循环等待条件（资源有序分配策略可以限制循环等待条件的发生）</p><p>死锁的避免是根据<strong>防止系统进入不安全状态</strong>采取措施实现的、</p><p>银行家算法是一种最具有代表性的避免死锁的算法</p><p>银行家算法是需要（每个本身有点+空闲的）都大于等于需求的eg（2,2,2）&gt;(1,1,1)可以，但是(7,2,3)和（1,5,3）则不行，因为2不大于5</p><h4 id="同步应遵循的原则有："><a href="#同步应遵循的原则有：" class="headerlink" title="同步应遵循的原则有："></a>同步应遵循的原则有：</h4><p>1、空闲让进</p><p>2、忙则等待</p><p>3、有限等待</p><p>4、让权等待</p><h4 id="那信号量上面值n代表什么意思呢？"><a href="#那信号量上面值n代表什么意思呢？" class="headerlink" title="那信号量上面值n代表什么意思呢？"></a>那信号量上面值n代表什么意思呢？</h4><p>n&gt;0：当前有可用资源，可用资源数量为n<br>n&#x3D;0：资源都被占用，可用资源数量为0<br>n&lt;0：资源都被占用，并且还有n个进程正在排队</p><p>信号量的<strong>初值</strong>可以是：</p><p>1、大于0的数</p><p>2、等于0</p><p><del>3、小于0的数</del>（<strong>初值不能为负</strong>）</p><h4 id="进程的挂起状态可以分为："><a href="#进程的挂起状态可以分为：" class="headerlink" title="进程的挂起状态可以分为："></a>进程的挂起状态可以分为：</h4><p>1、挂起就绪</p><p>2、挂起阻塞</p><h4 id="进程控制的作用："><a href="#进程控制的作用：" class="headerlink" title="进程控制的作用："></a>进程控制的作用：</h4><p>1、创建新进程</p><p>2、终止已完成进程</p><p>3、终止由于某事件而无法运行下去的进程</p><p>4、负责进程的各状态间的转换</p><h4 id="引起阻塞的事件"><a href="#引起阻塞的事件" class="headerlink" title="引起阻塞的事件"></a>引起阻塞的事件</h4><p>1、请求系统服务</p><p>2、数据尚未到达</p><p>3、无新工作可做</p><p><del>启动某种操作</del>（启动操作是主动的行为，不会被其他程序阻塞）</p><h4 id="进程控制块的具体作用"><a href="#进程控制块的具体作用" class="headerlink" title="进程控制块的具体作用"></a>进程控制块的具体作用</h4><p>（1）作为独立运行基本单位的标志</p><p>（2）能实现间断性运行方式</p><p>（3）提供进程管理所需要的信息</p><p>（4）提供进程调度所需要的信息</p><p>（5）实现与其他进程的同步与通信</p><h4 id="简述处理机三级调度分别完成什么工作"><a href="#简述处理机三级调度分别完成什么工作" class="headerlink" title="简述处理机三级调度分别完成什么工作"></a>简述处理机三级调度分别完成什么工作</h4><p>（1）高级调度：即作业调度，用于决定把外存上处于后备队列中的哪些作业调入内存，并为它们创建进程，分配必要的资源，然后，再将新创建的进程排在就绪队列上，准备执行。</p><p>（2）中级调度：实际上就是存储器管理中的对换功能，完成内存和外存信息的交换调度</p><p>（3）低级调度：即进程调度，它决定就绪队列中的哪个进程将获得处理机，然后由分派程序执行把处理机分配给该进程的操作</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷题打卡</title>
      <link href="/posts/fbfa1a12.html"/>
      <url>/posts/fbfa1a12.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="坚持刷题打卡！！！"><a href="#坚持刷题打卡！！！" class="headerlink" title="坚持刷题打卡！！！"></a>坚持刷题打卡！！！</h3><ul><li><input checked="" disabled="" type="checkbox"> Day1——Ac 12道</li><li><input checked="" disabled="" type="checkbox"> Day2——Ac 1道（今晚事有点多）好消息，过校选了，压线，6月8号重庆市大学生程序设计大赛</li><li><input checked="" disabled="" type="checkbox"> Day3——Ac 4道（太困了，精力不足，今晚早点睡）</li><li><input checked="" disabled="" type="checkbox"> Day4——Ac 0道（表达式求值有点懵逼，还是太困了，明早起来补，还得准备星期天的软考）</li><li><input checked="" disabled="" type="checkbox"> Day5——Ac 4道</li><li><input checked="" disabled="" type="checkbox"> Day6——Ac 0道（软考结束，肝操作系统了）</li><li><input checked="" disabled="" type="checkbox"> Day7——报告</li><li><input checked="" disabled="" type="checkbox"> Day8——报告</li><li><input checked="" disabled="" type="checkbox"> Day9——报告</li></ul><p>…………………………………..</p><p>没记录了，无数的报告，结局是肝了20多天的报告。。。天天写到凌晨3点（真服了）</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>sublime配置C++编译环境</title>
      <link href="/posts/142149a.html"/>
      <url>/posts/142149a.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="sublime配置C-C-编译环境"><a href="#sublime配置C-C-编译环境" class="headerlink" title="sublime配置C&#x2F;C++编译环境"></a>sublime配置C&#x2F;C++编译环境</h2><ul><li><p>先下载sublime（这是废话）</p></li><li><p>配置C&#x2F;C++编译环境</p><ul><li>进入DevC++文件夹目录</li><li>复制上方地址</li><li>右击我的电脑-&gt;点击属性-&gt;点击高级系统设置-&gt;环境配置-&gt;系统变量中点击path-&gt;新建将刚才的地址粘贴于此</li><li>win+r   输入 <code>g++ -v</code>出现版本即说明搭建成功</li></ul></li><li><p>配置编译文件</p><ul><li>运行sublime，点击工具-&gt;编译系统-&gt;新编译系统，会出现以sublime-build为后缀的文件，复制代码（文后附），粘贴覆盖原有即可，然后保存，分别命名为C和C++(.sublime-build)（什么？没有权限保存？试试管理员运行模式）</li></ul><p>C语言</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;working_dir&quot;: &quot;$file_path&quot;,</span><br><span class="line">    &quot;cmd&quot;: &quot;gcc -Wall \&quot;$file_name\&quot; -o \&quot;$file_base_name\&quot;&quot;,</span><br><span class="line">    &quot;file_regex&quot;: &quot;^(..[^:]*):([0-9]+):?([0-9]+)?:? (.*)$&quot;,</span><br><span class="line">    &quot;selector&quot;: &quot;source.c&quot;,</span><br><span class="line"></span><br><span class="line">    &quot;variants&quot;: </span><br><span class="line">    [</span><br><span class="line">        &#123;   </span><br><span class="line">        &quot;name&quot;: &quot;Run&quot;,</span><br><span class="line">            &quot;shell_cmd&quot;: &quot;gcc -Wall \&quot;$file\&quot; -o \&quot;$file_base_name\&quot; &amp;&amp; start cmd /c \&quot;\&quot;$&#123;file_path&#125;/$&#123;file_base_name&#125;\&quot; &amp; pause\&quot;&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C++语言</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;encoding&quot;: &quot;utf-8&quot;,</span><br><span class="line">    &quot;working_dir&quot;: &quot;$file_path&quot;,</span><br><span class="line">    &quot;shell_cmd&quot;: &quot;g++ -Wall -std=c++11 \&quot;$file_name\&quot; -o \&quot;$file_base_name\&quot;&quot;,</span><br><span class="line">    &quot;file_regex&quot;: &quot;^(..[^:]*):([0-9]+):?([0-9]+)?:? (.*)$&quot;,</span><br><span class="line">    &quot;selector&quot;: &quot;source.c++&quot;,</span><br><span class="line"></span><br><span class="line">    &quot;variants&quot;: </span><br><span class="line">    [</span><br><span class="line">        &#123;   </span><br><span class="line">        &quot;name&quot;: &quot;Run&quot;,</span><br><span class="line">            &quot;shell_cmd&quot;: &quot;g++ -Wall -std=c++11 \&quot;$file\&quot; -o \&quot;$file_base_name\&quot; &amp;&amp; start cmd /c \&quot;\&quot;$&#123;file_path&#125;/$&#123;file_base_name&#125;\&quot; &amp; pause\&quot;&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>FastOlympicCoding插件下载</p><ul><li>ctrl+shift+p    输入FastOlympicCoding下载</li><li>ctrl+b弹出终端运行，按esc键即可关闭结果运行框，再按<code>i</code>键，恢复insert状态</li><li>ctrl+alt+b弹出FastOlympicCoding右边运行框</li><li>alt+shift+1关闭右边的运行框分页窗口</li></ul></li></ul><p>献上参考博客：</p><p><a href="https://blog.csdn.net/gl486546/article/details/78208634?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-78208634-blog-107137805.235%5Ev43%5Epc_blog_bottom_relevance_base4&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-78208634-blog-107137805.235%5Ev43%5Epc_blog_bottom_relevance_base4&utm_relevant_index=2">sublime配置编译C&#x2F;C++_sublime 指定c++编译版本-CSDN博客</a></p><p><a href="https://blog.csdn.net/zhaqonianzhu/article/details/127897253#">sublime text 关闭编译结果框_sublime的下面的框框怎么关-CSDN博客</a></p><p><a href="https://blog.csdn.net/weixin_57202646/article/details/123517113">关于sublime text 如何使用fastolympiccoding插件实现高效刷题（循环测试）-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>想到什么说什么</title>
      <link href="/posts/5fd6e59a.html"/>
      <url>/posts/5fd6e59a.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>明天省赛答辩祝好运^_^</p><blockquote><p>后续：g了，花的时间很长省三结束o(╥﹏╥)o</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 随心所欲 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>word相关操作</title>
      <link href="/posts/7395b0a5.html"/>
      <url>/posts/7395b0a5.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Word"><a href="#Word" class="headerlink" title="Word:"></a>Word:</h2><h3 id="解决图不完全显示问题"><a href="#解决图不完全显示问题" class="headerlink" title="解决图不完全显示问题"></a>解决图不完全显示问题</h3><img src="https://pencil1024.oss-cn-chengdu.aliyuncs.com/imgs/202407161118940.png" alt="图的不完全显示效果图" style="zoom: 80%;" /><blockquote><p>如何解决上述的问题：</p></blockquote><img src="https://pencil1024.oss-cn-chengdu.aliyuncs.com/imgs/202407161119765.png" alt="图的不完全显示" style="zoom:80%;" /><blockquote><p> 右击 -&gt; 将固定值22磅改成单倍行距</p></blockquote><img src="https://pencil1024.oss-cn-chengdu.aliyuncs.com/imgs/202407161119103.png" alt="图的不完全显示" style="zoom:80%;" /><h3 id="在写论文的时候，通常会把数学公式居中，-1-、-2-等序号描述右对齐，该如何操作？"><a href="#在写论文的时候，通常会把数学公式居中，-1-、-2-等序号描述右对齐，该如何操作？" class="headerlink" title="在写论文的时候，通常会把数学公式居中，(1)、(2)等序号描述右对齐，该如何操作？"></a>在写论文的时候，通常会把数学公式居中，(1)、(2)等序号描述右对齐，该如何操作？</h3><ol><li><p>鼠标光标移到数学公式那一行，如果出现从MathType粘贴过来的图显示不完全，那么鼠标右击那一行的空白处，点击段落，将间距设置为多倍行间距即可</p></li><li><p>在调行间距的那个界面点击左下角的制表位，如图设置即可</p><img src="https://pencil1024.oss-cn-chengdu.aliyuncs.com/imgs/202407161125718.png" alt="数学公式居中" style="zoom:80%;" /></li><li><p>点击确定之后，在数学公式的最前面输一个tap和数学公式的最末尾输入一个tap，那么就可以看到数学公式居中对齐和数字编号右对齐了</p></li></ol><h3 id="项目符号和文本之间的空格间隙太大"><a href="#项目符号和文本之间的空格间隙太大" class="headerlink" title="项目符号和文本之间的空格间隙太大"></a>项目符号和文本之间的空格间隙太大</h3><p>如图：</p><img src="https://pencil1024.oss-cn-chengdu.aliyuncs.com/imgs/202407161121269.png" alt="制表符操作" style="zoom:80%;" /><p><strong>操作步骤</strong>：</p><p>1、点击鼠标右键，点击“调整列表缩进”。</p><img src="https://pencil1024.oss-cn-chengdu.aliyuncs.com/imgs/202407161122148.png" alt="制表符操作" style="zoom:80%;" /><p>2、把”制表符“改为“不特别标注”</p><img src="https://pencil1024.oss-cn-chengdu.aliyuncs.com/imgs/202407161122728.png" alt="制表符操作" style="zoom:80%;" /><p>3.成功</p><img src="https://pencil1024.oss-cn-chengdu.aliyuncs.com/imgs/202407161122581.png" alt="制表符操作" style="zoom:80%;" /><h3 id="英文链接不单独换行显示"><a href="#英文链接不单独换行显示" class="headerlink" title="英文链接不单独换行显示"></a>英文链接不单独换行显示</h3><img src="https://pencil1024.oss-cn-chengdu.aliyuncs.com/imgs/202410111204942.png" alt="英文链接不单独换行显示" style="zoom:80%;" /><p>解决方法：</p><p>选中英文链接部分，右击选择段落，选择中文板式下面的允许西文在单词中间换行(w)</p><img src="https://pencil1024.oss-cn-chengdu.aliyuncs.com/imgs/202410111212329.png" alt="英文链接不单独换行显示" style="zoom:80%;" /><p><strong>参考blog：</strong></p><p><a href="https://blog.csdn.net/hehuazheyue/article/details/96898719">Word 中公式居中，编号靠右-CSDN博客</a></p><p><a href="https://blog.csdn.net/qq_45100200/article/details/130481576">Word项目符号后面空格太大的调整办法（参考文献项目编号）_word项目符号后怎么很大空白-CSDN博客</a></p><p><a href="https://blog.csdn.net/qq_36292543/article/details/115842925">word中输入网址总是整体自动换行_文档中网址格式一直单独一行显示-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> office软件操作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> word </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo添加音乐播放器</title>
      <link href="/posts/6bacc03b.html"/>
      <url>/posts/6bacc03b.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="使用-Hexo-Tag-Aplayer-插件"><a href="#使用-Hexo-Tag-Aplayer-插件" class="headerlink" title="使用 Hexo-Tag-Aplayer 插件"></a>使用 <a href="https://so.csdn.net/so/search?q=Hexo&spm=1001.2101.3001.7020">Hexo</a>-Tag-Aplayer 插件</h3><p>首先执行安装命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save hexo-tag-aplayer</span><br></pre></td></tr></table></figure><p>如果出现报错：</p><p>1、清除npm缓存</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm cache clean --force</span><br></pre></td></tr></table></figure><p>2、禁用SSL：虽然不推荐，但您可以暂时禁用SSL验证来解决这个问题。但请注意，这会降低安全性。您可以通过设置npm的 strict-ssl 选项为 false 来实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config set strict-ssl false</span><br></pre></td></tr></table></figure><p>参考这篇文章：<a href="https://blog.csdn.net/weixin_58068682/article/details/116612364?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-5-116612364-blog-88092728.235%5Ev43%5Epc_blog_bottom_relevance_base4&spm=1001.2101.3001.4242.4&utm_relevant_index=8">Hexo博客技巧：为博客插入音乐_hexo添加音乐-CSDN博客</a></p><h4 id="关闭-asset-inject"><a href="#关闭-asset-inject" class="headerlink" title="关闭 asset_inject"></a>关闭 asset_inject</h4><p>在<code>主题配置文件</code>：</p><p>此步骤适用于安装了<code>hexo-tag-aplayer</code>插件的人</p><p>由于需要全局都插入aplayer和meting资源，为了防止插入重复的资源，需要把asset_inject设为false</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">aplayer:</span><br><span class="line">  meting: true</span><br><span class="line">  asset_inject: false</span><br></pre></td></tr></table></figure><h4 id="开启主题的AplayerInject"><a href="#开启主题的AplayerInject" class="headerlink" title="开启主题的AplayerInject"></a>开启主题的AplayerInject</h4><p>在主题的配置文件中，<code>enable</code>设为<code>true</code>和<code>per_page</code>设为<code>true</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Inject the css and script (aplayer/meting)</span><br><span class="line">aplayerInject:</span><br><span class="line">  enable: true</span><br><span class="line">  per_page: true</span><br></pre></td></tr></table></figure><h4 id="把Aplayer代码插入到主题配置文件"><a href="#把Aplayer代码插入到主题配置文件" class="headerlink" title="把Aplayer代码插入到主题配置文件"></a>把Aplayer代码插入到主题配置文件</h4><p>其中data-server为音乐平台，例如netease就是网易云，还有<code>tencent</code>, <code>kugou</code>, <code>xiami</code>, <code>baidu</code>等；</p><p>id即为你选择的音乐平台网页版点击我的喜欢页面，地址栏上方的id</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">inject:</span><br><span class="line">  head:</span><br><span class="line">  bottom:</span><br><span class="line">    - &lt;div class=&quot;aplayer no-destroy&quot; data-id=&quot;7868042847&quot; data-server=&quot;tencent&quot; data-type=&quot;playlist&quot; data-fixed=&quot;true&quot; data-mini=&quot;true&quot; data-listFolded=&quot;false&quot; data-order=&quot;random&quot; data-preload=&quot;none&quot; data-autoplay=&quot;true&quot; muted&gt;&lt;/div&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>跳转页面，音乐会重新加载？</p><p>1、记得添加<code>class=&quot;aplayer no-destroy&quot;</code></p><p>2、将主题配置文件中的pjax设置为true</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pjax: </span><br><span class="line">  enable: true</span><br><span class="line">  exclude:</span><br><span class="line">    - /music/</span><br><span class="line">    - /no-pjax/</span><br></pre></td></tr></table></figure><p>ok，执行以上操作你应该可以在左下角看到一个音乐播放器</p>]]></content>
      
      
      <categories>
          
          <category> hexo魔改 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hello world</title>
      <link href="/posts/d4a1185.html"/>
      <url>/posts/d4a1185.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>本站建立已有小几个月，但都是隔三差五的发布一些文章，添加一些小功能，改改bug<br>这篇文章没有其他意思，hello world是大多数语言输出的第一句话，我仅想以此来表达我将开始持续更新博客<br>不积跬步无以至千里，不积小流无以成江河，希望自己能够坚持！</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构（二）</title>
      <link href="/posts/266a3580.html"/>
      <url>/posts/266a3580.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul><li>Trie树</li><li>并查集</li><li>手写堆</li></ul><blockquote><p>Trie树</p></blockquote><p><strong>高效的存储和查找字符串集合的数据结构</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> son[N][<span class="number">26</span>], cnt[N], idx;</span><br><span class="line"><span class="type">char</span> str[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> str[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;str[i];i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u=str[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(!son[p][u])son[p][u]= ++idx;</span><br><span class="line">        p=son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cnt[p]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">char</span> str[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;str[i];i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u=str[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(!son[p][u])<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        p=son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> cnt[p];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>,op,str);</span><br><span class="line">       <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">&#x27;I&#x27;</span>)<span class="built_in">insert</span>(str);</span><br><span class="line">        <span class="keyword">else</span><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">query</span>(str));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>并查集</p></blockquote><p>并查集：</p><p>1、将两个元素合并</p><p>2、询问两个元素是否在一个集合当中</p><p><em>基本原理</em>：每个集合用一棵树来表示。树根的编号就是整个集合的编号。每个节点存储它的父节点，p[x]表示x的父节点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span><span class="comment">//返回x的祖宗节点 + 路径压缩</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x]!=x)p[x]=<span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)p[i]=i;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> op[<span class="number">2</span>];<span class="comment">//不用 char op; 的原因是避免scanf会读入空格和其他字符</span></span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d%d&quot;</span>,op,&amp;a,&amp;b);</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">&#x27;M&#x27;</span>)p[<span class="built_in">find</span>(a)]=<span class="built_in">find</span>(b);<span class="comment">//a的祖宗节点的父节点连接b的祖宗节点，保证a和b在一个集合</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(a)==<span class="built_in">find</span>(b))<span class="built_in">put</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span><span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>连通块中点的数量</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> p[N], size[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span><span class="comment">//返回x的祖宗节点 + 路径压缩</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x]!=x)p[x]=<span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">    p[i]=i;</span><br><span class="line">    size[i]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> op[<span class="number">5</span>];<span class="comment">//不用 char op; 的原因是避免scanf会读入空格和其他字符</span></span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,op);</span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">find</span>(a)==<span class="built_in">find</span>(b))<span class="keyword">continue</span>;<span class="comment">//特判，如果a在b的集合里面就直接下一次循环 </span></span><br><span class="line">       size[<span class="built_in">find</span>(b)]+=size[<span class="built_in">find</span>(a)];</span><br><span class="line">p[<span class="built_in">find</span>(a)]=<span class="built_in">find</span>(b); </span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op[<span class="number">1</span>]==<span class="string">&#x27;1&#x27;</span>)<span class="comment">//Q1 </span></span><br><span class="line">        &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(a)==<span class="built_in">find</span>(b))<span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span><span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,size[<span class="built_in">find</span>(a)]);</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>堆</p></blockquote><ol><li>插入一个数heap[++size]&#x3D;x;up(size);</li><li>求集合当中的最小值                 heap[1];</li><li>删除最小值                                heap[1]&#x3D;heap[size];size–;down(1);</li><li>删除任意一个元素                     heap[k]&#x3D;heap[size];size–;down(k);up(k);</li><li>修改任意一个元素                     heap[k]&#x3D;x;down(k);up(k);</li></ol><p><em><strong>堆的结构</strong></em>：</p><p>堆是一个完全二叉树</p><p><em>堆排序：</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> h[N],size;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t=u;</span><br><span class="line">    <span class="keyword">if</span>(u*<span class="number">2</span>&lt;=size &amp;&amp; h[u*<span class="number">2</span>]&lt;h[t])t=u*<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(u*<span class="number">2</span>+<span class="number">1</span>&lt;=size &amp;&amp; h[u*<span class="number">2</span>+<span class="number">1</span>]&lt;h[t])t=u*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(u!=t)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">swap</span>(h[u],h[t]);</span><br><span class="line">        <span class="built_in">down</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;h[i]);</span><br><span class="line">    size=n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n/<span class="number">2</span>;i;i--)<span class="built_in">down</span>(i);<span class="comment">//转化为堆(为什么这样就可以，规律)</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, h[<span class="number">1</span>]);<span class="comment">//堆顶元素即为最小值</span></span><br><span class="line">        h[<span class="number">1</span>]=h[size];</span><br><span class="line">        size--;</span><br><span class="line">       <span class="built_in">down</span>(<span class="number">1</span>);<span class="comment">//重新生成堆</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>模拟堆</p></blockquote><p>int strcmp(const char* str1, const char* str2);</p><p><code>strcmp()</code>函数的比较规则如下：</p><ul><li>如果<code>str1</code>和<code>str2</code>相等，返回值为0。</li><li>如果<code>str1</code>小于<code>str2</code>，返回值为负数。</li><li>如果<code>str1</code>大于<code>str2</code>，返回值为正数。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> h[N], ph[N], hp[N], size;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heap_swap</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">swap</span>(ph[hp[a]],ph[hp[b]]);</span><br><span class="line">    <span class="built_in">swap</span>(hp[a],hp[b]);</span><br><span class="line">    <span class="built_in">swap</span>(h[a],h[b]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t=u;</span><br><span class="line">    <span class="keyword">if</span>(u*<span class="number">2</span>&lt;=size &amp;&amp; h[u*<span class="number">2</span>]&lt;h[t])t=u*<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(u*<span class="number">2</span>+<span class="number">1</span>&lt;=size &amp;&amp; h[u*<span class="number">2</span>+<span class="number">1</span>]&lt;h[t])t=u*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(u!=t)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">heap_swap</span>(u,t);</span><br><span class="line">        <span class="built_in">down</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(u/<span class="number">2</span> &amp;&amp; h[u/<span class="number">2</span>]&gt;h[u])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">heap_swap</span>(u/<span class="number">2</span>,u);</span><br><span class="line">        u/=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> op[<span class="number">10</span>];</span><br><span class="line">        <span class="type">int</span> k,x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,op);</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(op,<span class="string">&quot;I&quot;</span>)) <span class="comment">// </span></span><br><span class="line">        &#123;<span class="comment">//插入操作,从底部插入</span></span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">            size++;</span><br><span class="line">            m++;</span><br><span class="line">            ph[m]=size, hp[size]=m;<span class="comment">//***</span></span><br><span class="line">            h[size]=x;</span><br><span class="line">            <span class="built_in">up</span>(size);            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(op,<span class="string">&quot;PM&quot;</span>))<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,h[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(op,<span class="string">&quot;DM&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">heap_swap</span>(<span class="number">1</span>,size);</span><br><span class="line">            size--;</span><br><span class="line">            <span class="built_in">down</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(op,<span class="string">&quot;D&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;k);</span><br><span class="line">            k=ph[k];<span class="comment">//第k个插入的数</span></span><br><span class="line">            <span class="built_in">heap_swap</span>(k,size);</span><br><span class="line">            size--;</span><br><span class="line">            <span class="built_in">down</span>(k),<span class="built_in">up</span>(k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;k,&amp;x);</span><br><span class="line">            k=ph[k];</span><br><span class="line">            h[k]=x;</span><br><span class="line">            <span class="built_in">down</span>(k),<span class="built_in">up</span>(k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构（一）</title>
      <link href="/posts/167cd958.html"/>
      <url>/posts/167cd958.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul><li>链表与邻接表</li><li>栈与队列</li><li>kmp</li></ul><p>用数组来模拟</p><p>好处：速度快（快很多）</p><blockquote><p>单链表</p></blockquote>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> head,e[N],ne[N],idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">head=<span class="number">-1</span>;</span><br><span class="line">    idx=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将x插到头结点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_to_head</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=x, ne[idx]=head, head=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将x插入到下标为k的点后面</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=x, ne[idx]=ne[k], ne[k]=idx++;</span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//将下标为k的点的后面的一个点移除</span></span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">remove</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ne[k]=ne[ne[k]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="type">int</span> m;</span><br><span class="line">    cin&gt;&gt;m;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> k,x;</span><br><span class="line">        <span class="type">char</span> op;</span><br><span class="line">        cin&gt;&gt;op;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="string">&#x27;H&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;x;</span><br><span class="line">            <span class="built_in">add_to_head</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op==<span class="string">&#x27;D&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;k;</span><br><span class="line">            <span class="comment">//特判 </span></span><br><span class="line">            <span class="keyword">if</span>(k==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="comment">//如果 k为0 那么移除头结点 </span></span><br><span class="line">            head=ne[head];</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">            <span class="built_in">remove</span>(k<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;k&gt;&gt;x;</span><br><span class="line">            <span class="built_in">add</span>(k<span class="number">-1</span>,x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head; i!=<span class="number">-1</span>; i=ne[i])      cout&lt;&lt;e[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">   cout&lt;&lt;endl;</span><br><span class="line">       </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>双链表</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> e[N],l[N],r[N],idx;</span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    r[<span class="number">0</span>]=<span class="number">1</span>, l[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">   idx=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在下标为k的点的右边插入x</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=x;</span><br><span class="line">    r[idx]=r[k];</span><br><span class="line">    l[idx]=k;</span><br><span class="line">    l[r[k]]=idx;</span><br><span class="line">    r[k]=idx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在k左边插入一个点，就调用add(l[k],x)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//删除第k个点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    r[l[k]]=r[k];</span><br><span class="line">    l[r[k]]=l[k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>栈与队列</p></blockquote><p>栈——先进后出   队列——先进先出</p><ul><li>数组模拟栈</li></ul> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> naemspace std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N =<span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> stk[N], tt;</span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line">stk[++tt]=x;</span><br><span class="line"></span><br><span class="line"><span class="comment">//弹出</span></span><br><span class="line">tt--;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断栈是否为空</span></span><br><span class="line"><span class="keyword">if</span>(tt&gt;<span class="number">0</span>)<span class="keyword">not</span> empty</span><br><span class="line"><span class="keyword">else</span>empty</span><br><span class="line">    </span><br><span class="line"><span class="comment">//栈顶</span></span><br><span class="line">stk[tt];</span><br></pre></td></tr></table></figure><ul><li>数组模拟队列</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> naemspace std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N =<span class="number">100010</span>;</span><br><span class="line"><span class="comment">//在队尾插入元素，在队头弹出元素</span></span><br><span class="line"><span class="type">int</span> q[N], hh, tt=<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line">q[++tt]=x;</span><br><span class="line"></span><br><span class="line"><span class="comment">//弹出</span></span><br><span class="line">hh++;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断队列是否为空</span></span><br><span class="line"><span class="keyword">if</span>(hh&lt;=tt)<span class="keyword">not</span> empty</span><br><span class="line"><span class="keyword">else</span>empty</span><br><span class="line"></span><br><span class="line"><span class="comment">//取出队头元素</span></span><br><span class="line">q[hh]</span><br><span class="line"><span class="comment">//尾</span></span><br><span class="line">q[tt]</span><br></pre></td></tr></table></figure><blockquote><p>单调栈</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> stk[N], tt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>),cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;cin&gt;&gt;x;</span><br><span class="line">        <span class="keyword">while</span>(tt &amp;&amp; stk[i] &gt;=x)tt--;</span><br><span class="line">        <span class="keyword">if</span>(tt)cout&lt;&lt;stk[tt]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">else</span>cout&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        </span><br><span class="line">        stk[++tt]=x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>单调队列</p></blockquote><p>滑动窗口</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"><span class="type">int</span> n, k;</span><br><span class="line"><span class="type">int</span> a[N], q[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//最小</span></span><br><span class="line">    <span class="type">int</span> hh=<span class="number">0</span>, tt=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//判断队头是否已经滑出窗口</span></span><br><span class="line">        <span class="keyword">if</span>(hh&lt;=tt &amp;&amp; i-k+<span class="number">1</span>&gt;q[hh])hh++;</span><br><span class="line">        <span class="keyword">while</span>(hh&lt;=tt &amp;&amp; a[q[tt]]&gt;=a[i])tt--;</span><br><span class="line">        q[++tt]=i;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=k<span class="number">-1</span>)<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[q[hh]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//最大</span></span><br><span class="line">    hh=<span class="number">0</span>, tt=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//判断队头是否已经滑出窗口</span></span><br><span class="line">        <span class="keyword">if</span>(hh&lt;=tt &amp;&amp; i-k+<span class="number">1</span>&gt;q[hh])hh++;</span><br><span class="line">        <span class="keyword">while</span>(hh&lt;=tt &amp;&amp; a[q[tt]]&lt;=a[i])tt--;</span><br><span class="line">        q[++tt]=i;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=k<span class="number">-1</span>)<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[q[hh]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>KMP</p></blockquote><p>如何获取一个char数组的长度，用strlen()，但用它之前要确保在数组末尾添加null（’\0’）终止符</p><p>示例Code</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> MAX_SIZE = <span class="number">10</span>;</span><br><span class="line">    <span class="type">char</span> x[MAX_SIZE + <span class="number">1</span>]; <span class="comment">// 增加一个额外的位置，用于存储null终止符</span></span><br><span class="line">    std::cin &gt;&gt; x + <span class="number">1</span>; <span class="comment">// 将输入存储到x+1位置上</span></span><br><span class="line">    x[MAX_SIZE] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">// 确保最后一个字符为null终止符</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">strlen</span>(x + <span class="number">1</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>KMP</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>, M = <span class="number">1000010</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">char</span> p[N], s[M];</span><br><span class="line"><span class="type">int</span> ne[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;p+<span class="number">1</span>&gt;&gt;m&gt;&gt;s+<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//求next数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>,j=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(j &amp;&amp; p[i]!=p[j+<span class="number">1</span>])j=ne[j];</span><br><span class="line">        <span class="keyword">if</span>(p[i]==p[j+<span class="number">1</span>])j++;</span><br><span class="line"> ne[i]=j;       </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//kmp匹配过程</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">while</span>(j &amp;&amp; s[i]!=p[j+<span class="number">1</span>])j=ne[j];</span><br><span class="line">        <span class="keyword">if</span>(s[i]==p[j+<span class="number">1</span>])j++;</span><br><span class="line">        <span class="keyword">if</span>(j==n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i-n);</span><br><span class="line">            j=ne[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最小生成树</title>
      <link href="/posts/9acb5cb3.html"/>
      <url>/posts/9acb5cb3.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><p>最小生成树是针对于无向图的，有向图没有这一概念，且这里边权值可以为负的</p><p>一般：稠密图——邻接矩阵稀疏图——邻接表</p><ul><li><p>普利姆算法（Prim）</p><ul><li><p>朴素版Prim   O(n^2)          &#x3D;&#x3D;邻接矩阵&#x3D;&#x3D;</p><p>​用于稠密图</p></li><li><p>堆优化版Prim       O(mlogn) </p><p>​用于稀疏图</p></li></ul></li><li><p>克鲁斯卡尔算法（Kruskal）       O(mlogn)</p><p>​   用于稀疏图</p></li></ul><h3 id="Prim"><a href="#Prim" class="headerlink" title="Prim()"></a>Prim()</h3><blockquote><p>输出最小生成树的权重之和</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>, INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> g[N][N];</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dist));</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;<span class="comment">//最小生成树中所有边的长度之和</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            <span class="keyword">if</span>(!st[j] &amp;&amp; (t==<span class="number">-1</span> || dist[t]&gt;dist[j]))</span><br><span class="line">                t=j;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i&amp;&amp;dist[t]==INF)<span class="keyword">return</span> INF;</span><br><span class="line">        <span class="keyword">if</span>(i)res+=dist[t];</span><br><span class="line">        <span class="comment">//更新</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)dist[j]=<span class="built_in">min</span>(dist[j],g[t][j]);</span><br><span class="line">        </span><br><span class="line">        st[t]=<span class="literal">true</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="built_in">memset</span>(g,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(g));</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b,c;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">        g[a][b]=g[b][a]=<span class="built_in">min</span>(g[a][b],c);<span class="comment">//可能会有重边所以取最小值</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> t=<span class="built_in">prim</span>();</span><br><span class="line">    <span class="keyword">if</span>(t==INF)cout&lt;&lt;<span class="string">&quot;impossible&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span>cout&lt;&lt;t&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Kruskal"><a href="#Kruskal" class="headerlink" title="Kruskal()"></a>Kruskal()</h3><blockquote><ol><li>所有边按权重从小到大排序O(mlogm)</li><li>枚举每条边a,b  权重为c<ul><li>if  a,b 不连通将这条边加入集合中</li></ul></li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">200010</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> p[N];<span class="comment">//并查集</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a,b,w;</span><br><span class="line">    </span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> Edge &amp;W)<span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> w&lt;W.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;edges[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x]!=x)p[x]=<span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b,w;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b&gt;&gt;w;</span><br><span class="line">        edges[i]=&#123;a,b,w&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sort</span>(edges,edges+m);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)p[i]=i;<span class="comment">//初始化</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>,cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a=edges[i].a, b=edges[i].b, w=edges[i].w;</span><br><span class="line">        a=<span class="built_in">find</span>(a), b=<span class="built_in">find</span>(b);</span><br><span class="line">        <span class="keyword">if</span>(a!=b)</span><br><span class="line">        &#123;</span><br><span class="line">            p[a]=b;</span><br><span class="line">            res+=w;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(cnt&lt;n<span class="number">-1</span>)  cout&lt;&lt;<span class="string">&quot;impossible&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 最小生成树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最短路问题</title>
      <link href="/posts/6bbbc5e9.html"/>
      <url>/posts/6bbbc5e9.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="常见最短路"><a href="#常见最短路" class="headerlink" title="常见最短路"></a>常见最短路</h2><p>在图论中，源点—起点汇点—终点</p><ul><li><p>单源最短路</p><ul><li><p>所有边权都是正数</p><ul><li><p>朴素Dijkstra算法        O(n^2)&#x3D;&#x3D;邻接矩阵&#x3D;&#x3D;</p><p>与m（边）无关   适用于稠密图（用邻接矩阵来存）</p></li><li><p>堆优化版的Dijkstra算法     O(mlogn)      </p><p>适用于稀疏图（用邻接表来存）</p></li></ul></li><li><p>存在负权边</p><ul><li>Bellman-Ford O(nm)</li><li>SPFA             一般：O(m)，最坏O(nm)          &#x3D;&#x3D;邻接表&#x3D;&#x3D;     （稀疏图）</li></ul></li></ul></li><li><p>多源汇最短路</p><ul><li>Floyd算法 O(n^3)</li></ul></li></ul><h3 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra()"></a>Dijkstra()</h3><blockquote><p>Dijkstra算法求最短路（第一个点到终点）</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//朴素的Dijkstra</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> g[N][N];<span class="comment">//g[i][j]为i-&gt;j的边的权重</span></span><br><span class="line"><span class="type">int</span> dist[N];<span class="comment">//点到起点的最短距离</span></span><br><span class="line"><span class="type">bool</span> st[N]; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dist);<span class="comment">//先将距离初始化为正无穷</span></span><br><span class="line">    dist[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line"><span class="keyword">if</span>(!st[j] &amp;&amp; (t==<span class="number">-1</span> || dist[t]&gt;dist[j]))</span><br><span class="line">                t=j;</span><br><span class="line">        <span class="comment">//if(t==n)break;可加上</span></span><br><span class="line">        </span><br><span class="line">        st[t]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            dist[j]=<span class="built_in">min</span>(dist[j],dist[t]+g[t][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dist[n]==<span class="number">0x3f3f3f3f</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">   <span class="built_in">memset</span>(g,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> g);<span class="comment">//初始化边为无穷大</span></span><br><span class="line">   <span class="keyword">while</span>(m--)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="type">int</span> a, b, c;</span><br><span class="line">       cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">       g[a][b]=<span class="built_in">min</span>(g[a][b],c);<span class="comment">//有重边，取最小的一条边</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="type">int</span> t=<span class="built_in">dijkstra</span>();</span><br><span class="line">    </span><br><span class="line">   cout&lt;&lt;t&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//朴素版Dijkstra()</span></span><br></pre></td></tr></table></figure><blockquote><p>用dijkstra算法求&#x3D;&#x3D;任意两点&#x3D;&#x3D;的最短路</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用dijkstra算法求任意两点的最短路</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">550</span>;</span><br><span class="line"><span class="type">int</span> n,m; </span><br><span class="line"><span class="type">int</span> g[N][N];</span><br><span class="line"><span class="type">int</span> dist[N], w[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">(<span class="type">int</span> start,<span class="type">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(dist,<span class="number">0x3f3f3f3f</span>,<span class="built_in">sizeof</span>(dist));</span><br><span class="line"><span class="built_in">memset</span>(st, <span class="literal">false</span>, <span class="built_in">sizeof</span>(st));<span class="comment">//每一次有每一次的标记点 </span></span><br><span class="line">dist[start]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> t=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!st[j] &amp;&amp; (t==<span class="number">-1</span> || dist[t]&gt;dist[j]))</span><br><span class="line">&#123;</span><br><span class="line">t=j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">st[t]=<span class="literal">true</span>; </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">&#123;</span><br><span class="line">dist[j]=<span class="built_in">min</span>(dist[j],dist[t]+g[t][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> dist[end];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">0</span>&amp;&amp;m==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="built_in">memset</span>(g,<span class="number">0x3f3f3f3f</span>,<span class="built_in">sizeof</span>(g));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cin&gt;&gt;w[i];</span><br><span class="line"><span class="keyword">while</span>(m--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a,b,c;</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line"><span class="keyword">if</span>(a==<span class="number">1</span>)&#123;</span><br><span class="line">g[b][c]=<span class="built_in">abs</span>(w[b]-w[c]);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">g[b][c]=g[c][b]=<span class="built_in">abs</span>(w[b]-w[c]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> start,end;</span><br><span class="line">cin&gt;&gt;start&gt;&gt;end;</span><br><span class="line">cout&lt;&lt;<span class="built_in">dijkstra</span>(start,end)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure><h3 id="Bellman-Ford"><a href="#Bellman-Ford" class="headerlink" title="Bellman_Ford()"></a>Bellman_Ford()</h3><blockquote><p>Bellman_Ford算法求最短路（对通过的边数有要求就用）</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>, M = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n, m, k;<span class="comment">//k是限制的边数</span></span><br><span class="line"><span class="type">int</span> dist[N], backcup[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b, w;</span><br><span class="line">&#125;edges[M];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bellman_ford</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dist));<span class="comment">//初始化</span></span><br><span class="line">    dist[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(backcup,dist,<span class="built_in">sizeof</span>(dist));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)<span class="comment">//**m是要存储的边的数量，而这里恰好是m条</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a=edges[j].a, b=edges[j].b, w=edges[j].w;</span><br><span class="line">            dist[b]=<span class="built_in">min</span>(dist[b], backcup[a]+w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dist[n]&gt;<span class="number">0x3f3f3f3f</span>/<span class="number">2</span>)<span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//(注意这里如果最短距离是-1，而返回值有是-1就错了，所以要看清题注意特征值)</span></span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b,w;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b&gt;&gt;w;</span><br><span class="line">        edges[i]=&#123;a,b,w&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> t=<span class="built_in">bellman_ford</span>();</span><br><span class="line">    <span class="keyword">if</span>(t==<span class="number">-1</span>)cout&lt;&lt;<span class="string">&quot;impossible&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span>cout&lt;&lt;t&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-----------------------------------------------分割线---------------------------------------------------</span><br><span class="line">    </span><br><span class="line"><span class="comment">//一道及其恶心的题(要注意bellman_ford返回的值可能就是最短路所以要找到一个特征值)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>, M = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n, m, cnt;<span class="comment">//*****cnt计数 </span></span><br><span class="line"><span class="type">int</span> dist[N], backcup[N], dot[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b, w;</span><br><span class="line">&#125;edges[M];</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">bellman_ford</span><span class="params">(<span class="type">int</span> start,<span class="type">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">0x3f3f3f3f</span>,<span class="built_in">sizeof</span>(dist));<span class="comment">//初始化</span></span><br><span class="line">    dist[start]=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1200</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(backcup,dist,<span class="built_in">sizeof</span>(dist));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;cnt;j++)<span class="comment">//*****&#x27;&lt;cnt&#x27;</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a=edges[j].a, b=edges[j].b, w=edges[j].w;</span><br><span class="line">            dist[b]=<span class="built_in">min</span>(dist[b], backcup[a]+w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    if(dist[end]&lt;50000)return dist[end]; </span></span><br><span class="line"><span class="comment">//    elsereturn -1;</span></span><br><span class="line"><span class="comment">//-----始终过不了-----(反其道而行之) 如上 </span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(dist[end]&gt;<span class="number">0x3f3f3f3f</span>/<span class="number">2</span>)<span class="keyword">return</span> <span class="number">9999</span>;<span class="comment">//没有最短距离</span></span><br><span class="line">    <span class="keyword">return</span> dist[end];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="comment">//初始化 </span></span><br><span class="line">cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">0</span>&amp;&amp;m==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cin&gt;&gt;dot[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a,b,c;</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line"><span class="type">int</span> tmp=dot[c]-dot[b];</span><br><span class="line"><span class="keyword">if</span>(a==<span class="number">1</span>)&#123;</span><br><span class="line">edges[cnt++]=&#123;b,c,tmp&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">edges[cnt++]=&#123;b,c,tmp&#125;, edges[cnt++]=&#123;c,b,tmp*<span class="number">-1</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> start, end;</span><br><span class="line">cin&gt;&gt;start&gt;&gt;end;</span><br><span class="line"><span class="type">int</span> t=<span class="built_in">bellman_ford</span>(start,end);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(t==<span class="number">9999</span>)cout&lt;&lt;<span class="string">&quot;INF&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">else</span>cout&lt;&lt;t&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Spfa"><a href="#Spfa" class="headerlink" title="Spfa()"></a>Spfa()</h3><blockquote><p>用Spfa算法求解带负权边的问题（全正的大部分也能做）</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> h[N],w[N],e[N],ne[N],idx;</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="type">int</span> st[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b, w[idx]=c, ne[idx]=h[a], h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dist));</span><br><span class="line">    dist[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    st[<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();<span class="comment">//移除队首元素</span></span><br><span class="line">        st[t]=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=h[t];i!=<span class="number">-1</span>;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j=e[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[j]&gt;dist[t]+w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j]=dist[t]+w[i];</span><br><span class="line">                <span class="keyword">if</span>(!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                    st[j]=<span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(dist[n]==<span class="number">0x3f3f3f3f</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span>dist[n]; </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="built_in">sizeof</span>(h));</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b ,c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        <span class="built_in">add</span>(a,b,c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="type">int</span> t=<span class="built_in">spfa</span>();</span><br><span class="line">    <span class="keyword">if</span>(t==<span class="number">-1</span>)cout&lt;&lt;<span class="string">&quot;impossible&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span>cout&lt;&lt;t&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>用spfa判断有无负权环</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> h[N],w[N],e[N],ne[N],idx;</span><br><span class="line"><span class="type">int</span> dist[N], cnt[N];</span><br><span class="line"><span class="type">int</span> st[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b, w[idx]=c, ne[idx]=h[a], h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">st[i]=<span class="literal">true</span>;</span><br><span class="line">q.<span class="built_in">push</span>(i);</span><br><span class="line">&#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();<span class="comment">//移除队首元素</span></span><br><span class="line">        st[t]=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=h[t];i!=<span class="number">-1</span>;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j=e[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[j]&gt;dist[t]+w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j]=dist[t]+w[i];</span><br><span class="line">                cnt[j]=cnt[t]+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(cnt[j]&gt;=n)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                    st[j]=<span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="built_in">sizeof</span>(h));</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b ,c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        <span class="built_in">add</span>(a,b,c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">spfa</span>())cout&lt;&lt;<span class="string">&quot;yes&quot;</span>&lt;&lt;endl;<span class="comment">//说明有负环 </span></span><br><span class="line"><span class="keyword">else</span>cout&lt;&lt;<span class="string">&quot;no&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 最短路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客搭建</title>
      <link href="/posts/b8f4bd70.html"/>
      <url>/posts/b8f4bd70.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="利用hexo-github搭建个人博客"><a href="#利用hexo-github搭建个人博客" class="headerlink" title="利用hexo+github搭建个人博客"></a>利用hexo+github搭建个人博客</h2><p>可以利用hexo+github或hexo+gitee搭建个人博客</p><p>因为gitee创建仓库用gitee pages要高举身份证拍照，为了避免麻烦，我以hexo+github为例</p><p>github始终打不开怎么办，下载steam++开加速即可打开</p><h3 id="发布文章的步骤"><a href="#发布文章的步骤" class="headerlink" title="发布文章的步骤"></a>发布文章的步骤</h3><ul><li>hexo new ‘xxx’# 在&#x2F;source&#x2F;_posts&#x2F;路径下生成.md文件  <code>注：</code>不能直接创.md文件要用命令来生成</li><li>编辑.md文章</li><li>hexo c &#x3D;&#x3D; hexo clean      # 清除缓存  </li><li>hexo g &#x3D;&#x3D; hexo generate   # 生成静态文件</li><li>hexo d &#x3D;&#x3D; hexo deploy     # 部署到github中，更新网页端的内容</li><li>hexo s &#x3D;&#x3D; hexo server     # 通过启动本地服务器，预览文章效果</li><li>hexo n &#x3D;&#x3D; hexo new</li></ul><blockquote><p>一键部署到远程github上</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure><p><em><strong>对hexo server的解释：</strong></em></p><p>对已发布的文章进行修改后，需要重新运行 <code>hexo server</code> 命令来生成最新的静态页面，并在浏览器中刷新以查看更改的效果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><h3 id="搭建过程中遇见的一些问题"><a href="#搭建过程中遇见的一些问题" class="headerlink" title="搭建过程中遇见的一些问题"></a>搭建过程中遇见的一些问题</h3><ul><li><p>下载Node.js后，使用npm，如果出现’npm’ 不是内部或外部命令，也不是可运行的程序</p></li><li><p>如果遇到输入hexo server之后弹出 <a href="http://localhost:4000/%E7%82%B9%E5%87%BB%E6%89%93%E4%B8%8D%E5%BC%80%E7%9A%84%E6%83%85%E5%86%B5">http://localhost:4000/点击打不开的情况</a></p><p>输入 <code>npm install hexo-server --save</code></p><p>或者打开控制面板 —  程序和功能  —  打开或关闭Windows功能  —-  勾选上Internet Informent Services  —–点击确定即可</p></li><li><p>ssh -T <a href="mailto:&#103;&#105;&#x74;&#64;&#x67;&#105;&#x74;&#x68;&#x75;&#x62;&#x2e;&#99;&#x6f;&#x6d;">&#103;&#105;&#x74;&#64;&#x67;&#105;&#x74;&#x68;&#x75;&#x62;&#x2e;&#99;&#x6f;&#x6d;</a>       <code>这是ssh默认在C盘下的命令</code></p><p>ssh -i “E:\blog\ssh\id_rsa” -T <a href="mailto:&#103;&#105;&#x74;&#x40;&#x67;&#105;&#116;&#104;&#117;&#x62;&#46;&#x63;&#111;&#x6d;">&#103;&#105;&#x74;&#x40;&#x67;&#105;&#116;&#104;&#117;&#x62;&#46;&#x63;&#111;&#x6d;</a>   对密钥有<code>指定路径</code>的访问方式</p></li></ul><p>为解决如图问题，查阅大量资料，了解到：这是由于github的22端口被防火墙拒了导致ssh连接被拒绝</p><h4 id="解决方法一："><a href="#解决方法一：" class="headerlink" title="解决方法一："></a><strong>解决方法一：</strong></h4><p>既然ssh协议连接github有问题，何不换一种方式呢？采用https协议连接github。</p><p>查看当前git的远程仓库版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure><p>运行后效果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">origin  git@github.com:unlimitbladeworks/Data-Struts-Learning.git (fetch)</span><br><span class="line">origin  git@github.com:unlimitbladeworks/Data-Struts-Learning.git (push)</span><br></pre></td></tr></table></figure><p><strong>采用https协议连接gihub</strong></p><p>移除掉远程仓库的配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote rm origin</span><br></pre></td></tr></table></figure><p>重新添加新的远程仓库，以https的形式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin https://github.com/Pencil1024/Pencil1024.github.io.git</span><br></pre></td></tr></table></figure><p>运行效果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">origin  https://github.com/Pencil1024/Pencil1024.github.io.git (fetch)</span><br><span class="line">origin  https://github.com/Pencil1024/Pencil1024.github.io.git (push)</span><br></pre></td></tr></table></figure><h4 id="解决方法二（推荐）："><a href="#解决方法二（推荐）：" class="headerlink" title="解决方法二（推荐）："></a><strong>解决方法二（推荐）：</strong></h4><p>原因分析：</p><blockquote><p>问题大多是因为git进行push或者hexo d的时候改变了一些.deploy_git文件下的内容。</p></blockquote><p>1.删除 <code>.deploy_git</code> 文件夹;<br>2.输入 <code>git config --global core.autocrlf false</code><br>3.然后，依次执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><h3 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h3><ul><li><p>客户端与服务端</p><ul><li><p>客户端：向服务器发送请求的一方</p></li><li><p>服务端：收到客户端的请求做出回应的一方</p></li></ul></li><li><p>ssh（Secure Shell 是一种网络协议，用于在不安全的网络中以安全的方式进行远程登录和执行命令）</p><ul><li>远程登录：通过 SSH，可以在本地计算机上使用命令行界面（如终端）连接到远程计算机并执行命令。远程登录允许您在不直接物理接触远程计算机的情况下进行管理、配置和维护</li><li>安全传输：SSH 提供了加密和数据完整性验证的功能。所有通过 SSH 连接传输的数据都是加密的，这使得它们在网络上难以被窃听和篡改</li><li>文件传输：除了远程登录，SSH 还支持通过 SCP（Secure Copy Protocol）或 SFTP（SSH File Transfer Protocol）在本地计算机和远程计算机之间安全地传输文件。</li><li>远程执行命令：使用 SSH，您可以远程执行命令并获取执行结果。通过这种方式，您可以在远程计算机上执行各种操作，而无需直接访问该计算机。</li></ul></li><li><p>git（Git是一种分布式版本控制系统，它可以有效地跟踪和管理文件的变更）</p><ul><li>版本控制：Git可以跟踪文件的每一次修改，记录文件的变更历史。您可以随时回退到之前的版本，比较不同版本之间的差异，并恢复丢失或错误的更改。</li><li>分支管理：Git允许您创建多个分支，每个分支可以独立进行开发工作。这样可以在不影响主要代码的情况下进行实验、修复错误或并行开发不同的功能。分支可以合并到主分支或其他分支，以整合不同的工作成果。</li><li>协同开发：Git使多人协同开发变得更加简单。每个开发者可以在自己的本地仓库中进行工作，并将自己的更改推送到共享的远程仓库中。通过合并（merge）或重播（rebase）不同的分支，多个开发者的工作可以整合在一起。</li><li>远程仓库：Git支持与远程仓库进行交互，如GitHub、GitLab、Bitbucket等。您可以将本地仓库的更改推送到远程仓库，或者从远程仓库获取最新的更新。</li></ul></li></ul><h4 id="献上搭建过程中参考的优质博客："><a href="#献上搭建过程中参考的优质博客：" class="headerlink" title="献上搭建过程中参考的优质博客："></a><em>献上搭建过程中参考的优质博客：</em></h4><p><a href="https://blog.csdn.net/mjh1667002013/article/details/129290903">【Hexo】Hexo搭建Butterfly主题并快速美化_hexo主题butterfly配置-CSDN博客</a></p><p><a href="https://blog.csdn.net/antma/article/details/86104068">node.js 安装详细步骤教程_nodejs如何装-CSDN博客</a></p><p><a href="https://blog.csdn.net/qq_38952352/article/details/127656385">git安装教程-CSDN博客</a></p><p><a href="https://blog.csdn.net/weixin_44198965/article/details/99686507">git官网下载太慢解决方法-CSDN博客</a></p><p><a href="https://blog.csdn.net/m0_51269961/article/details/122575897?ops_request_misc=%7B%22request_id%22:%22170550476416800197044790%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=170550476416800197044790&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-122575897-null-null.142%5Ev99%5Epc_search_result_base9&utm_term=%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA&spm=1018.2226.3001.4187">快速搭建个人博客——保姆级教程-CSDN博客</a></p><p><a href="https://blog.csdn.net/qq_28919533/article/details/124338891">hexo发生error：spawn failed错误的解决方法_error: spawn failed-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> hexo搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
