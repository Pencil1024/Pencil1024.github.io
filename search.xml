<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>加减乘除高精度</title>
      <link href="/posts/cedaecd5.html"/>
      <url>/posts/cedaecd5.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="高精度加法"><a href="#高精度加法" class="headerlink" title="高精度加法"></a>高精度加法</h2><blockquote><p><a href="https://www.acwing.com/problem/content/793/">791. 高精度加法 - AcWing题库</a></p></blockquote><p>给定两个正整数（不含前导 00），计算它们的和。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>共两行，每行包含一个整数。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>共一行，包含所求的和。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤整数长度≤1000001≤整数长度≤100000</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">12</span><br><span class="line">23</span><br></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">35</span><br></pre></td></tr></table></figure><p>思路：模拟加法的过程，从末尾开始，逐步进位相加取模</p><p>ps：<strong>需要注意</strong>if(i&gt;&#x3D;a.size()) t1&#x3D;0;        if(i&gt;&#x3D;b.size()) t2&#x3D;0;这两步，<strong>因为’’-‘0’不为0</strong></p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">string a,b,x;</span><br><span class="line"><span class="type">int</span> t1, t2;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    <span class="built_in">reverse</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>()), <span class="built_in">reverse</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">end</span>());   <span class="comment">//逆序</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> t=<span class="number">0</span>;    <span class="comment">//存进位</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;a.<span class="built_in">size</span>() || i&lt;b.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        t1=a[i]-<span class="string">&#x27;0&#x27;</span>, t2=b[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=a.<span class="built_in">size</span>()) t1=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=b.<span class="built_in">size</span>()) t2=<span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> mo=(t1+t2+t)%<span class="number">10</span>;    </span><br><span class="line">        x+=<span class="built_in">to_string</span>(mo);</span><br><span class="line">        t=(t1+t2+t)/<span class="number">10</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(t==<span class="number">1</span>)    x+=<span class="string">&quot;1&quot;</span>; <span class="comment">//如果最后还有一次进位</span></span><br><span class="line">    </span><br><span class="line">    <span class="built_in">reverse</span>(x.<span class="built_in">begin</span>(),x.<span class="built_in">end</span>()); <span class="comment">//逆序即为结果</span></span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;x&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="高精度减法"><a href="#高精度减法" class="headerlink" title="高精度减法"></a>高精度减法</h2><blockquote><p><a href="https://www.acwing.com/problem/content/794/">792. 高精度减法 - AcWing题库</a></p></blockquote><p>给定两个正整数（不含前导 00），计算它们的差，计算结果可能为负数。</p><h4 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式"></a>输入格式</h4><p>共两行，每行包含一个整数。</p><h4 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式"></a>输出格式</h4><p>共一行，包含所求的差。</p><h4 id="数据范围-1"><a href="#数据范围-1" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤整数长度≤1051≤整数长度≤105</p><h4 id="输入样例：-1"><a href="#输入样例：-1" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">32</span><br><span class="line">11</span><br></pre></td></tr></table></figure><h4 id="输出样例：-1"><a href="#输出样例：-1" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">21</span><br></pre></td></tr></table></figure><p>思路：先实现cmp()比数的大小，小减大要添“-”，在末尾模拟减法操作</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">string a,b;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">cmp</span><span class="params">(string a,string b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.<span class="built_in">size</span>()!=b.<span class="built_in">size</span>())  <span class="keyword">return</span> a.<span class="built_in">size</span>()&gt;b.<span class="built_in">size</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;a.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]!=b[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> a[i]&gt;b[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(string a,string b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">reverse</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>());</span><br><span class="line">    <span class="built_in">reverse</span>(b.<span class="built_in">begin</span>(),b.<span class="built_in">end</span>());</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> t=<span class="number">0</span>,t1,t2;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;a.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;b.<span class="built_in">size</span>())  t2=b[i]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">else</span>    t2=<span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        t1=a[i]-<span class="string">&#x27;0&#x27;</span>-t;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(t1&lt;t2)</span><br><span class="line">        &#123;</span><br><span class="line">            t=<span class="number">1</span>;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(t1+<span class="number">10</span>-t2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            t=<span class="number">0</span>;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(t1-t2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//去前导零</span></span><br><span class="line">    <span class="keyword">while</span>(ans.<span class="built_in">size</span>()&gt;<span class="number">1</span> &amp;&amp; ans.<span class="built_in">back</span>()==<span class="number">0</span>)  ans.<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// a比b大</span></span><br><span class="line">    <span class="keyword">if</span>(a==b)    <span class="built_in">puts</span>(<span class="string">&quot;0&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">cmp</span>(a,b))    <span class="built_in">solve</span>(a,b);</span><br><span class="line">    <span class="keyword">else</span>    <span class="comment">// a比b小</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;-&quot;</span>;</span><br><span class="line">        <span class="built_in">solve</span>(b,a);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=ans.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)    cout&lt;&lt;ans[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="高精度乘法"><a href="#高精度乘法" class="headerlink" title="高精度乘法"></a>高精度乘法</h2><blockquote><p><a href="https://www.acwing.com/problem/content/795/">793. 高精度乘法 - AcWing题库</a></p></blockquote><p>给定两个非负整数（不含前导 00） <em>A</em>A 和 <em>B</em>B，请你计算 <em>A</em>×<em>B</em>A×B 的值。</p><h4 id="输入格式-2"><a href="#输入格式-2" class="headerlink" title="输入格式"></a>输入格式</h4><p>共两行，第一行包含整数 <em>A</em>A，第二行包含整数 <em>B</em>B。</p><h4 id="输出格式-2"><a href="#输出格式-2" class="headerlink" title="输出格式"></a>输出格式</h4><p>共一行，包含 <em>A</em>×<em>B</em>A×B 的值。</p><h4 id="数据范围-2"><a href="#数据范围-2" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤<em>A</em>的长度≤1000001≤A的长度≤100000,<br>0≤<em>B</em>≤100000≤B≤10000</p><h4 id="输入样例：-2"><a href="#输入样例：-2" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure><h4 id="输出样例：-2"><a href="#输出样例：-2" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6</span><br></pre></td></tr></table></figure><p>操作：记住 *<em>if(i&lt;A.size())  t+&#x3D;A[i]<em>b;</em></em></p><p>ps：注意条件判断是   <strong>(i&lt;A.size() || t)</strong></p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">string a;</span><br><span class="line"><span class="type">int</span> b;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; A, ans;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;A.<span class="built_in">size</span>() || t;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;A.<span class="built_in">size</span>())  t+=A[i]*b;</span><br><span class="line">        ans.<span class="built_in">push_back</span>(t%<span class="number">10</span>);</span><br><span class="line">        t/=<span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(ans.<span class="built_in">size</span>()&gt;<span class="number">1</span> &amp;&amp; ans.<span class="built_in">back</span>()==<span class="number">0</span>)  ans.<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=a.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)  A.<span class="built_in">push_back</span>(a[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=ans.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)    cout&lt;&lt;ans[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="高精度除法"><a href="#高精度除法" class="headerlink" title="高精度除法"></a>高精度除法</h2><blockquote><p><a href="https://www.acwing.com/problem/content/796/">794. 高精度除法 - AcWing题库</a></p></blockquote><p>给定两个非负整数（不含前导 00） <em>A</em>，<em>B</em>A，B，请你计算 <em>A</em>&#x2F;<em>B</em>A&#x2F;B 的商和余数。</p><h4 id="输入格式-3"><a href="#输入格式-3" class="headerlink" title="输入格式"></a>输入格式</h4><p>共两行，第一行包含整数 <em>A</em>A，第二行包含整数 <em>B</em>B。</p><h4 id="输出格式-3"><a href="#输出格式-3" class="headerlink" title="输出格式"></a>输出格式</h4><p>共两行，第一行输出所求的商，第二行输出所求余数。</p><h4 id="数据范围-3"><a href="#数据范围-3" class="headerlink" title="数据范围"></a>数据范围</h4><p>1≤<em>A</em>的长度≤1000001≤A的长度≤100000,<br>1≤<em>B</em>≤100001≤B≤10000,<br><em>B</em>B 一定不为 00</p><h4 id="输入样例：-3"><a href="#输入样例：-3" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">7</span><br><span class="line">2</span><br></pre></td></tr></table></figure><h4 id="输出样例：-3"><a href="#输出样例：-3" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">1</span><br></pre></td></tr></table></figure><p>思路：核心记住  <strong>t&#x3D;t*10+A[i];</strong></p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line">string a;</span><br><span class="line"><span class="type">int</span> b,t;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; A,C;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;A.<span class="built_in">size</span>();i++)</span><br><span class="line">    &#123;</span><br><span class="line">        t=t*<span class="number">10</span>+A[i];</span><br><span class="line">        C.<span class="built_in">push_back</span>(t/b);</span><br><span class="line">        t%=b;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">reverse</span>(C.<span class="built_in">begin</span>(),C.<span class="built_in">end</span>()); <span class="comment">//去前导零100 / 100 会得到001 逆序删去前导零</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(C.<span class="built_in">size</span>()&gt;<span class="number">1</span> &amp;&amp; C.<span class="built_in">back</span>()==<span class="number">0</span>)    C.<span class="built_in">pop_back</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;a.<span class="built_in">size</span>();i++)     A.<span class="built_in">push_back</span>(a[i]-<span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">solve</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=C.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)  cout&lt;&lt;C[i];</span><br><span class="line">    </span><br><span class="line">    cout&lt;&lt;endl&lt;&lt;t&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多元统计分析及R语言建模</title>
      <link href="/posts/7aae9fe2.html"/>
      <url>/posts/7aae9fe2.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="22级期末考试题型"><a href="#22级期末考试题型" class="headerlink" title="22级期末考试题型"></a>22级期末考试题型</h3><hr><h4 id="一、选择题（10小题，20分）"><a href="#一、选择题（10小题，20分）" class="headerlink" title="一、选择题（10小题，20分）"></a>一、选择题（10小题，20分）</h4><h4 id="二、简答题（4小题，20分）"><a href="#二、简答题（4小题，20分）" class="headerlink" title="二、简答题（4小题，20分）"></a>二、简答题（4小题，20分）</h4><p>描述某个方法的核心步骤以及R程序、某个方法有何用途</p><h4 id="三、计算题（2小题，10分）"><a href="#三、计算题（2小题，10分）" class="headerlink" title="三、计算题（2小题，10分）"></a>三、计算题（2小题，10分）</h4><p>计算量简单</p><h4 id="四、案例分析题（4小题，40分）"><a href="#四、案例分析题（4小题，40分）" class="headerlink" title="四、案例分析题（4小题，40分）"></a>四、案例分析题（4小题，40分）</h4><p>对代码及运行结果解读，这个函数是什么功能？每个参数的解读</p><p>分别对应四章内容</p><h4 id="五、综合题（1题，10分）"><a href="#五、综合题（1题，10分）" class="headerlink" title="五、综合题（1题，10分）"></a>五、综合题（1题，10分）</h4><h3 id="期末复习"><a href="#期末复习" class="headerlink" title="期末复习"></a>期末复习</h3><hr><ul><li><p>在R语言中a[1]就代表着输出第一个元素</p></li><li><p>a &lt;- c(0,1,2)   a[c(1,3)]就代表着访问第一个和第三个元素</p></li><li><p>散点图数目与数据维度平方成正比</p></li><li><p>方差分析又称F检验 (F test)，用于推断多个总体均值有无显著差异</p></li><li><p><strong>F统计量中</strong> F&#x3D;组间方差（离差平方和&#x2F;自由度）&#x2F;组内方差，F值大说明变量之间存在关系</p></li><li><p>在统计学中，两个分类变量的列联表中的期望频数可以通过以下公式计算：</p><ul><li>(行合计)*(列合计)&#x2F;总样本量</li></ul></li><li><p>卡方独立性检验看p值</p></li><li><p>研究者通常会对因子载荷矩阵进行旋转，如正交旋转（varimax）或斜交旋转（oblimin），这样可以使得<strong>载荷在某个因子上集中</strong>，而在其他因子上接近零，从而使得因子的解释更加清晰和易于理解。</p></li><li><p>单因素方差分析（ANOVA）主要用来比较三个或者更多个样本组的总体均值是否存在显著差异。其基本假设是各组数据来自正态分布，且具有相同的方差。方差分析的核心在于分析组间差异是否显著大于组内差异。</p></li><li><p><strong>当 p 值小于 0.05 时，意味着我们拒绝零假设（null hypothesis）。</strong>在单因素方差分析中，零假设是指所有组的总体均值相等。因此，拒绝这一假设意味着至少有两组的总体均值存在显著差异，但并不意味着所有组的总体均值都不相等。</p></li><li><p>factor()函数用于<strong>创建因子变量</strong>，非数值型变量（类别变量和顺序变量）在R语言中称为因子，因子型变量内的所有为非重复值</p></li><li><p><code>glm()</code> 函数是R语言中用于拟合广义线性模型（Generalized Linear Models, GLMs）的函数。广义线性模型是线性模型的一种扩展，适用于不满足正态分布假设的数据，比如二项分布（逻辑回归）、泊松分布（泊松回归）</p></li><li><p>考虑到“Survived”是一个二分类变量，我们可以使用<strong>逻辑回归</strong>（Logistic Regression）来建立模型。<strong>逻辑回归</strong>适用于预测二元结果（是&#x2F;否，生还&#x2F;未生还）。</p></li><li><p>逻辑回归是一种用于处理二元结果的统计方法，通常用于预测某事件发生的概率。在R语言中，逻辑回归可以使用<code>glm</code>函数来实现，其中<code>family = binomial</code>表示二项分布。</p></li><li><p>泊松逻辑回归通常用于处理计数数据，比如事件发生的次数。</p></li><li><p>协方差矩阵的用途：</p><ul><li>刻画数据整体离散型</li><li>定义统计距离</li></ul></li><li><p><strong>rossTable( )—gmodels包</strong></p><ul><li><p>计算（行、列、单元格）的百分比</p></li><li><p>指定小数位数</p></li><li><p>进行卡方、Fisher和McNemar独立性检验</p></li><li><p>计算期望和（皮尔逊、标准化、调整的标准化）残差</p></li><li><p>将缺失值作为一种有效值</p></li><li><p>进行行和列标题的标注</p></li><li><p>生成SAS或SPSS风格的输出</p></li></ul></li><li><p><strong>chisq.test( )</strong></p><ul><li>检验列联表行列变量间是否存在显著性差异，或者用于检验变量之间是否独立</li></ul></li><li><p><strong>setwd()</strong></p><ul><li>查看文件属性，找出路径</li></ul></li></ul><h2 id="判别分析"><a href="#判别分析" class="headerlink" title="判别分析"></a>判别分析</h2><p>寻找一个投影方向，把两个群体分得最开的一种方法</p><p>样本均值投影的标准化距离最大</p><p>√ Fisher ‘s LDA对分布没有要求，但要求不同群体有相同协方差矩阵。</p><p>√Fisher ‘s LDA为线性判别方法，还有很多（非线性）判别函数的构造方式。</p><p>Fisher分类实际是在比较新观测对象yo与y1、y2间的马氏距离</p><h3 id="主成分分析"><a href="#主成分分析" class="headerlink" title="主成分分析"></a>主成分分析</h3><p>Standard deviation：标准差，其平方为方差&#x3D;特征值<br>Proportoin of Variance：方差贡献率<br>Cumulative Proportion：累积方差贡献率</p><ul><li>PCA &#x3D; prcomp(data_num , center &#x3D; T , scale. &#x3D; T)<ul><li>中心化和归一化所有数值变量，从而平等地考虑各个数值变量的影响</li></ul></li></ul><h4 id="主成分分析函数princomp-的用法："><a href="#主成分分析函数princomp-的用法：" class="headerlink" title="主成分分析函数princomp()的用法："></a>主成分分析函数princomp()的用法：</h4><p>princomp(x,cor&#x3D;FALSE,scores&#x3D;TRUE,…)</p><table><thead><tr><th>x</th><th>数据矩阵或数据框</th></tr></thead><tbody><tr><td>cor</td><td>是否用相关阵，默认为协差阵</td></tr><tr><td>scores</td><td>是否输出成分得分</td></tr></tbody></table><h2 id="各大分析方法的基本步骤"><a href="#各大分析方法的基本步骤" class="headerlink" title="各大分析方法的基本步骤"></a>各大分析方法的基本步骤</h2><h3 id="回归分析的基本步骤："><a href="#回归分析的基本步骤：" class="headerlink" title="回归分析的基本步骤："></a>回归分析的基本步骤：</h3><p>1、确定自变量和因变量</p><p>2、从样本数据出发确定变量之间的数学关系式,并对回归方程的各个参数进行估计</p><p>3、对回归方程进行各种统计检验</p><p>4、利用回归方程进行预测</p><h3 id="基本思想："><a href="#基本思想：" class="headerlink" title="基本思想："></a>基本思想：</h3><p>采集样本信息-&gt;回归分析（散点图）-&gt;回归方程-&gt;回归方程的显著性检验-&gt;对现实进行预测与控制</p><h3 id="自变量筛选："><a href="#自变量筛选：" class="headerlink" title="自变量筛选："></a>自变量筛选：</h3><img src="https://pencil1024.oss-cn-chengdu.aliyuncs.com/imgs/202407161440209.png" style="zoom:50%;" /><hr><img src="https://pencil1024.oss-cn-chengdu.aliyuncs.com/imgs/202407161442482.png" style="zoom:50%;" /><hr><img src="https://pencil1024.oss-cn-chengdu.aliyuncs.com/imgs/202407161442256.png" style="zoom:50%;" /><h2 id="Logistic"><a href="#Logistic" class="headerlink" title="Logistic"></a>Logistic</h2><p><code>family = binomial</code> 指定了使用二项逻辑回归模型来拟合数据</p><h3 id="D-W检验："><a href="#D-W检验：" class="headerlink" title="D-W检验："></a>D-W检验：</h3><p>一种检验序列自相关的方法</p><h3 id="多重共线性检验："><a href="#多重共线性检验：" class="headerlink" title="多重共线性检验："></a>多重共线性检验：</h3><p>VIF&gt;5，多重共线</p><p>​     hp    wt </p><p>1.766625 1.766625   </p><p><strong>分析：方差膨胀因子较小，无多重共线性。</strong>      </p><hr><p>期末考试题型大多都是作业上的（难受至极，因为通宵复习了一晚上的ppt……选择&gt;&gt;努力）</p><p>我来简单的复盘一下：</p><ul><li><p>一个 r*c 列联表，进行卡方独立性检验时检验统计量的自由度为？</p></li><li><p>单因素方差分析中，当 p 值小于 0.05 时，可认为？</p></li><li><p>Q 型聚类统计量是（ ），R 型聚类统计量是（ ）</p></li><li><p>请简述对线性回归系数进行标准化有何用处？</p></li><li><p>聚类分析的三步核心步骤与核心代码</p></li><li><p>主成分分析中主成分如何选择</p></li><li><p>箱型图的解释</p></li><li><p>SSA、SSB、SST…相关的计算</p></li><li><p>计算欧式距离与什么距离（忘了）</p></li><li><p>Fisher判别分析给出混淆矩阵分析（请记得算出判对率和判错率）</p></li><li><p>相关分析（记得从上到下，从左往右的分析）</p></li><li><p>最后一道是给出很多数据的的excel文件，请选择部分数据进行研究，给出多元统计分析方法和核心代码</p></li></ul><p>剩下的就记不到了。。祝各位好运！</p>]]></content>
      
      
      <categories>
          
          <category> 课程学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> R语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>马原期末复习</title>
      <link href="/posts/2a87fde6.html"/>
      <url>/posts/2a87fde6.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h2><h3 id="物质与意识的关系"><a href="#物质与意识的关系" class="headerlink" title="物质与意识的关系"></a><strong>物质与意识的关系</strong></h3><p>​基于辩证唯物主义的物质与意识的辩证关系理论，物质是意识产生的基础和前提，意识是物质世界在人脑中的反映，并且对物质具有能动的反作用。<br>1、首先，人工智能作为物质存在，是人类智能的延伸和扩展。它的产生和发展依赖于物质技术的进步，如计算机硬件、传感器、网络通信等。人工智能的智能活动是人类智能的物化，是对人脑组织结构与思维运行机制的模仿。(本质是物质)<br>2、其次，人工智能的发展受到人类社会实践活动的制约和指导。人类通过科学文化实践，创造和发展了人工智能技术。同时，人类也通过法律、伦理和社会规范等形式对人工智能的发展进行调控和引导,确保其符合人类社会的价值观和利益。(受物质实践的制约)<br>3、再次，人工智能作为一种新的物质力量，对人类社会和意识产生了深远的影响。它不仅改变了人类生产和生活方式，还拓展了人类认知的广度和思维的深度。同时，人工智能也对人类的意识形态、价值观和社会结构产生了挑战和冲击。(作为新的物质力量对人类社会的影响)<br>4、最后，尽管人工智能可以模拟和扩展人脑的某些活动，但是也不能达到人类智能的层级，不能真正具有人的意识，不能取代或超越人类智能。(但是超越不了人类意识)<br><strong>原因为：</strong><br>1、人工智能缺乏人类意识的核心要素，包括情感、信念和意志。人工智能的决策过程通常基于预设算法和数据分析，而非人类的情感驱动和道德考量。(不具备知情意)<br>2、人工智能虽然可以在一定程度上模拟人类的社交行为,但它不具备真正的社会属性。它不能像人类一样具有自我意识、自主性和社会责任感。(不具备社会属性)<br>3、人类的自然语言承载着文化和情感，是意识的现实形式。人工智能虽然可以处理和生成语言，但它难以真正理解语言背后的深层含义和情感色彩。(不能理解自然语言)<br>4、人工智能无法触及人类意识中那些无法量化为数字信号的部分，如潜意识和直觉，这些元素超出了人工智能当前的处理范围。(人脑中很多东西不能化约数字)<br>​综上所述，在人工智能飞速发展的条件下，我们应当坚持物质与意识的辩证关系理论，认识到人工智能作为物质存在和意识延伸的双重性质。同时，根据斯蒂芬 霍金的观点，人工智能的发展可能带来潜在的威胁，我们也应当关注人工智能对人类社会和意识的影响和挑战，积极应对和引导其发展，确保人工智能技术的发展符合人类社会的整体利益和长远发展。</p><h2 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h2><h3 id="实践与认识的辩证关系"><a href="#实践与认识的辩证关系" class="headerlink" title="实践与认识的辩证关系"></a><strong>实践与认识的辩证关系</strong></h3><p>一、实践决定认识</p><p>1、实践是认识的来源。认识只能在实践的基础上产生，正如毛泽东所说“要想知道梨子的味道，就得亲口尝一尝”，“不入虎穴焉得虎子”等，均说明了实践是认识的来源，而且是唯一来源。</p><p>2、实践是认识发展的动力。①农民种田推动了农学的产生，建筑业的需求推动了数学、建筑学等学科的发展，在实践中科技不断进步。②实践为认识发展提供必要的条件。比如显微镜的发明、我国最大的球面射电望远镜FAST的出现等促进了认识的发展，生产力进步。③实践锻炼和提高了主体的认识能力。</p><p>3、实践是认识的目的。我国发展科技创新目的就是增进民生福祉</p><p>4、实践是检验认识真理性的唯一标准。就像伽利略质疑亚里士多德提出两个铁球同时着地，只有通过实践才能检验。</p><p>二、认识对实践的指导作用</p><p>认识对实践反作用具有两重性：</p><p>1、正确的认识对实践起着积极的促进作用</p><p>2、错误的认识则对实践起消极的阻碍作用，甚至导致实践的失败</p><h3 id="真理与价值的辩证统一关系"><a href="#真理与价值的辩证统一关系" class="headerlink" title="真理与价值的辩证统一关系"></a><strong>真理与价值的辩证统一关系</strong></h3><p>1、人们的实践活动总是受着真理尺度和价值尺度的制约。在实践中，真理既是制约实践的客观尺度，又是实践追求的价值目标之一;而价值则是实践追求的根本目标，又是制约实践的主体尺度，真理和价值在实践基础上是辩证统一的</p><p>2、任何成功的实践必然是以真理和价值的辩证统一为前提，是合规律性和合目的性的统一</p><p>3、真理与价值是紧密联系、不可分割的辩证统一 关系，价值的形成和实现以坚持真理为前提，而真理又必然是具有价值的。</p><p>4、新时代中国特色社会主义的伟大实践，充分体现了真理尺度与价值尺 度的辩证统一。</p><p>5、真理和价值在实践和认识活动中是相互制约、相互引导、相互促进的。中国共产党人的理想信念，建立在马克思主义科学真理的基础之上，建立在马克思主义揭示的人类社会发展规律的基础之上，建立在为最广大人民谋利益的崇高价值的基础之上。</p><h2 id="第三章"><a href="#第三章" class="headerlink" title="第三章"></a>第三章</h2><h3 id="人民群众是历史创造者的原理"><a href="#人民群众是历史创造者的原理" class="headerlink" title="人民群众是历史创造者的原理"></a>人民群众是历史创造者的原理</h3><p>1、人民群众是社会历史的主体，是历史的创造者；</p><p>2、在社会历史发展过程中，人民群众起着决定性的作用；</p><p>3、人民群众是社会物质财富的创造者；</p><p>4、人民群众是社会精神财富的创造者；</p><p>5、人民群众是社会变革的决定力量；</p><p>6、人民群众创造历史的活动要受到一定社会历史条件的制约</p><h3 id="社会意识对社会存在的反作用原理"><a href="#社会意识对社会存在的反作用原理" class="headerlink" title="社会意识对社会存在的反作用原理"></a>社会意识对社会存在的反作用原理</h3><p>社会存在和社会意识是辩证统一的。</p><p>社会存在决定社会意识；社会意识是社会存在的反映</p><p>社会意识具有相对独立性：</p><p>1、社会意识与社会存在发展具有不完全同步性和不平衡性。进步的 社会意识可以</p><p>在一定程度上预见、推断未来，指导人们的实践活动；落后 于社会存在的社会意识</p><p>则阻碍社会的发展。</p><p>2、社会意识内部各种形式之间存在相互影响且各自具有历史继承 性。社会生活的</p><p>内在联系及其统一性，决定了社会意识诸形式之间也必然 是相互影响、相互作用</p><p>的。</p><p>3、社会意识对社会存在具有能动的反作用，这是社会意识相对独立 性的突出表</p><p>现。任何社会意识都不会凭空出现，只能是适应一定社会物质 生活发展的要求而产</p><p>生的，因而它必然具有满足这些要求的功能和价值, 在一定条件下会转化为物质力</p><p>量并作用于社会存在，影响历史的发展。先 进的社会意识反映了社会发展的趋势和</p><p>要求，对社会发展起着积极的促进 作用；落后的社会意识不符合社会发展的趋势和</p><p>要求，对社会发展起着消 极的阻碍作用。</p><p><strong>脱贫攻坚精神（精神文化）在社会发展中的作用</strong></p><p>为实现全体人民共同富裕提供精神力量；推进乡村振兴；有利于国家的长治久安；有利于巩固党的执政；有利于全面建设小康社会。 </p><p>1、文化为社会发展提供思想指引。</p><p>2、文化为社会发展提供精神动力。</p><p>3、文化为社会发展提供凝聚力量。</p><h2 id="第四章"><a href="#第四章" class="headerlink" title="第四章"></a>第四章</h2><h3 id="剩余价值量的计算"><a href="#剩余价值量的计算" class="headerlink" title="剩余价值量的计算"></a><strong>剩余价值量的计算</strong></h3><p><a href="https://www.bilibili.com/video/BV1q34y1H78x/?spm_id_from=333.337.search-card.all.click&vd_source=c1c4128300770265cb4dc28a7adf6788">十分钟通透政经计算题（剩余价值率、有机构成）_哔哩哔哩_bilibili</a></p><h3 id="剩余价值理论的认识"><a href="#剩余价值理论的认识" class="headerlink" title="剩余价值理论的认识"></a>剩余价值理论的认识</h3><p>剩余价值既不是由全部资本创造的，也不是由不变资本创造的, 而是由可变资本雇佣的劳动者创造的。就应该用剩余价值 和雇佣劳动者的可变资本相比，而不应该把它去同全部资本相比，用公式表示m’&#x3D;m&#x2F;v (m’ 为剩余价值率，m为剩余价值，v为可变资本)资本家提高对工人剥削程度的方法是多种多样的，其中最基本的为绝对剩余价值的生产和相对剩余价值的生产。资本主义生产的唯一动机和直接目的就是追求剩余价值，但客观上也会促进生产力的发展和社会进步。把剩余价值转化为资本就是资本积累，资本积累不但是社会财富占有两极分化的重要原因，而且是资本主义社会失业现象产生的根源（追求更高利益，提高技术和效率，减少成本）。 影响资本周转快慢关键的因素有两个：一是资本周转的时间，二是生产资本的固定资本和流动资本构成。要加快资本周转速度，获得更多剩余价值，就要缩短资本周转时间，加快流动资本的周转速度。在资本主义制度下，工人的工资是劳动力的价值或价格，这是资本主义工资的本质。剩余价值率是剩余价值与可变资本的比率，反映的是资本家对工人的剥削程度；利润率则是剩余价值与全部预付资本的比率，反映的是 预付总资本的增殖程度，掩盖了资本家对工人的剥削。剩余价值理论深刻 揭露了资本主义生产关系的剥削本质，阐明了资产阶级与无产阶级之间阶级斗争的经济根源，指出了无产阶级革命的历史必然性。剩余价值理论是 马克思经济学说的核心内容和基石，是无产阶级反对资产阶级、揭示资本 主义制度剥削本质的锐利武器。由于唯物史观和剩余价值理论的发现，社 会主义由空想变为科学。</p><hr><p>好消息，上面精心准备的都没考！！！</p><p>22级马原的期末考了大致如下：</p><p>一、谈谈如何理解马克思主义物质观及其现代意义（没考物质与意识）</p><p>二、真理与价值的辩证统一关系（没考实践与认识的关系）</p><p>三、请结合人民群众是历史创造者的原理，谈谈对“江山就是人民，人民就是江山”的理解。（没考社会意识与社会存在的关系）</p><p>四、这不用说了先（1）20分的计算题，然后（2）20分的500字的八股文，默写对剩余价值理论的认识</p>]]></content>
      
      
      <categories>
          
          <category> 课程学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 马原 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式计算系统</title>
      <link href="/posts/56a171cd.html"/>
      <url>/posts/56a171cd.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="Hadoop"><a href="#Hadoop" class="headerlink" title="Hadoop"></a>Hadoop</h2><h3 id="HDFS的存储思想"><a href="#HDFS的存储思想" class="headerlink" title="HDFS的存储思想"></a>HDFS的存储思想</h3><ul><li>文件分块存储：将大文件分成块，块的大小设置为128mb，这些文件块可以分布到集群中不同的节点上，令多个节点对逻辑层面的大文件在物理层面进行分布式存储</li><li>分块冗余存储：HDFS将大文件切分成块，每个小块同时进行冗余备份</li><li>简化文件读写：一次写入，多次读取，可避免读写冲突</li></ul><h3 id="NameNode是如何备份的"><a href="#NameNode是如何备份的" class="headerlink" title="NameNode是如何备份的"></a>NameNode是如何备份的</h3><ul><li><p>edits、fsimage</p></li><li><p>Secondary NameNode来做定期的元数据的合并，让edits文件的部分合并到fsimage中去，保证内存比较小</p></li><li><p>HA高可用</p></li></ul><h3 id="文件的读写"><a href="#文件的读写" class="headerlink" title="文件的读写"></a>文件的读写</h3><p>block的拆分是在客户端中进行的</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><p>hadoop fs || hdfs dfs</p><h2 id="MapReduce（批处理）"><a href="#MapReduce（批处理）" class="headerlink" title="MapReduce（批处理）"></a>MapReduce（批处理）</h2><img src="https://pencil1024.oss-cn-chengdu.aliyuncs.com/imgs/202407161150799.png" alt="MapReduce" style="zoom: 50%;" /><ul><li><p>Map(&lt;k,v&gt;键值对) -&gt; Reduce中间有Shuffle阶段如何将相同的k值合并到同一个reduce就用<strong>哈希取模</strong>将k值进行数字编码然后模上个数</p></li><li><p>每个block块会启动一个Map任务</p></li><li><p>每个reduce任务会输出一个结果文件，存放在一个数据目录下</p></li><li><p><strong>combine方法</strong>是一种“局部”的reduce操作，<strong>好处：</strong>不仅能降低Map和Reduce任务消耗的存储空间，还能够有利于降低Shuffle过程中传输的数据量</p></li><li><p>关系表自然连接</p><ul><li>map和reduce</li><li>如果一张表非常大一张表非常小怎么处理：通过MapReduce提供的<strong>分布式缓存机制</strong>对较小的关系表进行广播来解决，可以避免Shuffle过程，为整个关系表的连接带来了性能的提升</li></ul></li></ul><h2 id="Spark（批处理）"><a href="#Spark（批处理）" class="headerlink" title="Spark（批处理）"></a>Spark（批处理）</h2><ul><li>Spark基于<strong>RDD（弹性分布式数据集）</strong>进行计算</li><li>RDD是<strong>只读</strong>的，对原RDD进行修改之后要用新的RDD来保存</li><li>RDD的操作算子（<strong>创建</strong>操作算子、<strong>转换</strong>操作算子、<strong>行动</strong>操作算子）</li></ul><img src="https://pencil1024.oss-cn-chengdu.aliyuncs.com/imgs/202407161150423.png" alt="Spark" style="zoom:50%;" /><ul><li>主从结构</li></ul><img src="https://pencil1024.oss-cn-chengdu.aliyuncs.com/imgs/202407161150193.png" alt="Spark" style="zoom:50%;" /><ul><li>Spark可分为Standalone和Yarn两种模式</li><li>Standalone集群管理器包含Master和Worker</li><li>Yarn集群管理器包含ResourceManager和NodeManager</li><li>集群管理器负责集群资源管理，而驱动器负责作业管理</li><li>RDD之间存在依赖关系，窄依赖是<strong>一对一</strong>，宽依赖是<strong>多对一</strong></li><li>RDD的<strong>持久化</strong>：<ul><li>原因：因为计算过程会不断产生新的RDD，因此系统无法将所有的RDD均存储于内存中，内存是有限的，所以要持久化</li><li>调用RDD的<strong>persist(Storagelevel)方法</strong>或<strong>cache()方法</strong>实现持久化</li></ul></li><li>在Lineage较长尤其存在<strong>宽依赖</strong>时，需要在适当的时机设置<strong>数据检查点</strong><ul><li>检查点机制将RDD写入可靠的外部分布式文件系统，例如HDFS。如果用户指定某些RDD需要设置检查点，则系统将在作业结束之后启动一个独立的作业进行写检查点操作</li><li>检查点机制作用：防止因<strong>RDD Lineage</strong>过长而导致恢复过程中重计算的开销过大</li></ul></li><li>关系表自然连接中，Spark提供<strong>广播变量机制</strong>，将较小的关系表作为广播变量进行广播</li></ul><h2 id="Yarn（资源管理系统）"><a href="#Yarn（资源管理系统）" class="headerlink" title="Yarn（资源管理系统）"></a>Yarn（资源管理系统）</h2><ul><li><p><strong>FIFO（先进先出调度器）</strong></p><ul><li>调度策略：将所有任务放入一个队列，先进队列的先获得资源，排在后面的任务只有等待</li><li>缺点：资源利用率低，无法交叉运行任务，一个应用独占所有资源而其他应用需要不断等待，以及灵活性差，如紧急任务无法插队，耗时长的任务拖慢耗时短的任务</li></ul></li><li><p><strong>capacity（容量调度器）</strong></p><ul><li>调度策略：集群资源由多个队列分享，每个队列都要预设资源分配的比例，空闲资源优先分配给“实际资源&#x2F;预算资源”比值最低的队列，队列内部采用FIFO调度策略</li><li>特点：<ul><li>层次化的队列设计:子队列可使用父队列资源</li><li>容量保证:每个队列都要预设资源占比，防止资源独占，</li><li>弹性分配:空闲资源可以分配给任何队列，当多个队列争用时，会按比例进行平衡</li><li>支持动态管理:可以动态调整队列的容量、权限等参数，也可动态增加、暂停队列</li><li>访问控制:用户只能向自己的队列中提交任务，不能访问其他队列</li><li>多租户:多用户共享集群资源</li></ul></li></ul></li><li><p><strong>Fair（公平调度器）</strong></p><ul><li>调度策略:多队列公平共享集群资源，通过平分的方式，动态分配资源，无需预先设定资源分配比例，队列内部可配置调度策略:FIFO、Fair（默认）</li><li>特点：<ul><li>资源抢占：终止其他队列的任务，使其让出所占资源，然后将资源分配给占用资源量少于最小资源量限制的队列</li><li>队列权重：当队列中有任务等待，并且集群中有空闲资源时，每个队列可以根据权重获得不同比例的空闲资源</li></ul></li></ul></li></ul><h2 id="Storm（流计算系统）"><a href="#Storm（流计算系统）" class="headerlink" title="Storm（流计算系统）"></a>Storm（流计算系统）</h2><ul><li>数据模型：将流数据看作一个无界的、连续的<strong>元组序列</strong></li><li>Storm使用<strong>拓扑抽象</strong>描述计算过程，拓扑是由<strong>Spout</strong>和<strong>Bolt</strong>组成的网格</li><li>Bolt中可执行过滤、聚合、查询数据库等操作对元组进行转换，并将处理后的元组作为新的流数据发送给其他Bolt</li><li>Storm以Executor作为工作线程而在Task中仅实现任务代码</li><li>Storm的<strong>ACK机制</strong>用于确保消息处理的可靠性，保证每个消息都会被至少处理一次</li><li>词频统计中的ShuffleGrouping和FieldsGrouping</li></ul><h2 id="Spark-Streaming（实时流计算系统）"><a href="#Spark-Streaming（实时流计算系统）" class="headerlink" title="Spark Streaming（实时流计算系统）"></a>Spark Streaming（实时流计算系统）</h2><ul><li>Spark Streaming采用<strong>微批</strong>处理方式，将连续的流数据进行切片（按时间间隔离散化），生成一系列小块数据</li><li>增量式是避免重复计算</li><li><strong>数据检查点</strong>旨在加快<strong>执行器</strong>发生故障后的恢复过程</li><li><strong>元数据检查点</strong>旨在保证驱动器能够从故障中恢复到正常状态</li></ul><h2 id="Flink（批流融合系统）"><a href="#Flink（批流融合系统）" class="headerlink" title="Flink（批流融合系统）"></a>Flink（批流融合系统）</h2><ul><li>Flink程序使用DataStream类表示<strong>无界</strong>数据，其为一个可以包含重复项的<strong>不可变</strong>数据集合</li><li><strong>DataSet</strong>和<strong>DataStream</strong>的区别<ul><li>相同：记录是不可变的</li><li>不同：DataSet是<strong>有界</strong>的，而DataStream是<strong>无界</strong>的</li></ul></li><li>在Standalone模式下，除客户端外，Flink系统仅具有<strong>JobManager</strong>和<strong>TaskManager</strong></li><li>在Standalone模式下，当用户使用客户端提交Flink应用程序时，可以选择<strong>Attached方式</strong>或者<strong>Detached方式</strong><ul><li>Attached提交方式下客户端与<strong>JobManager</strong>保持连接，可以获取关于应用程序执行的信息</li><li>Dettached提交方式下客户端与<strong>JobManager</strong>断开连接，无法获取关于应用程序执行的信息</li></ul></li><li>Flink使用<strong>Chaining机制</strong>进行优化，将部分算子合并为一个”大“的算子，可以避免数据在不同<strong>TaskManager</strong>之间的非必要传输</li><li>状态管理<ul><li>原因：在个别节点发生故障的情况下自定义于内存中的数据结构将会丢失，故障恢复需要将过去所有数据重新计算</li><li>状态：状态可以看作操作算子的记忆能力，可以保留已处理记录的结果，并对后续记录的处理造成影响</li><li>map是一种典型的<strong>无状态</strong>算子，sum、window为<strong>有状态</strong>算子</li></ul></li><li>非迭代计算过程的容错<ul><li>异步屏障快照算法：通过在输入数据中注入屏障并异步地保存快照，达到和在同一时刻保存所有算子状态到检查点相同的目的</li></ul></li></ul><hr><p>​sb分布式Teacher（点名yqe），平时只有签到啥都没，一次作业没布置过，平时分给85。。期末第一次做题。期末画重点把整本书都画了但是只考了一部分 。（Yarn和Storm没考）最后一周期末周安排实验课，整整上了两天上午8点到下午5点，最开始布置了50个实验，因为太多，有同学去反应砍了一些，但还是很多，巨多。没法只能通宵！肝了两整天90多页word吧（唉，早知道不花这么多时间写这些傻逼报告了，准备期末不好嘛。。选择&gt;&gt;努力）这学期活的真窝囊啊，一直连着写了20多天的报告。刚刚好马原考前一天结束了大部分报告（最后剩了一门计网的大作业报告）。最后一天开始复习，看来马原居然还是复习得最久的！（仅一天罢了）。果不其然这学期炸了，没好好复习的结果，数据结构连基数排序是啥都不知道，直接送了15分~</p><p>​扯远了，我还记得一些些，来简单复盘一下：</p><p>​考的大致如下，全是一些画流程图的，一次没做过咋画()G</p><ul><li>每个大题好像都有两个小问， 第一问是八股文，背书就行，就例如请写出HDFS上传文件的过程，什么是宽依赖什么是窄依赖等</li><li>每个大题的第二问都是类似画出流程图的，因为每个题都是个实际的问题，就例如请用MapReduce来处理、Spark来处理…等</li><li>依稀记得我们考了HDFS文件的读取操作</li><li>MapReduce操作+分析画图</li><li>Spark操作+分析画图</li><li>Spark Streaming操作+分析画图</li><li>Flink操作+分析画图</li><li>每个题好像20分？记不太清了反正（1）好像都是5分</li><li>然后（1）我记得的考了HDFS读文件操作，简述什么是宽依赖什么是窄依赖，简述Chaining机制，Flink中的状态管理是什么。我记得的只有这些了</li></ul>]]></content>
      
      
      <categories>
          
          <category> 课程学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分布式计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统简述</title>
      <link href="/posts/7a81549d.html"/>
      <url>/posts/7a81549d.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h1><h2 id="第一章操作系统引论"><a href="#第一章操作系统引论" class="headerlink" title="第一章操作系统引论"></a>第一章操作系统引论</h2><p><strong>操作系统：</strong>是<code>一组</code>控制和管理计算机硬件和软件资源，合理地组织计算工作流程，以及方便用户使用的<code>程序集合</code></p><h3 id="一、操作系统系统目的、目标"><a href="#一、操作系统系统目的、目标" class="headerlink" title="一、操作系统系统目的、目标"></a>一、操作系统系统目的、目标</h3><ul><li>使计算机系统更易于使用（方便性）</li><li>以一种效率的方式使用资源（有效性）</li><li>采用模块化结构，已与增、删、改（可扩充性）</li><li>要求统一开放环境，能通过网络集成化并正确、有效地协同工作，实现应用程序的移植（开放性）</li></ul><h3 id="二、计算机系统组成"><a href="#二、计算机系统组成" class="headerlink" title="二、计算机系统组成"></a>二、计算机系统组成</h3><p><img src="https://pencil1024.oss-cn-chengdu.aliyuncs.com/imgs/202407161340062.png" alt="image-20240527103841941"></p><p><strong>操作系统的的地位：</strong>紧贴系统硬件之上，所有其他软件之下（是其他软件的共同环境）</p><h3 id="三、操作系统的作用"><a href="#三、操作系统的作用" class="headerlink" title="三、操作系统的作用"></a>三、操作系统的作用</h3><ul><li>Os作为用于与计算机硬件系统之间的接口</li><li>Os作为计算机系统资源的管理者</li><li>Os作为扩充机器</li></ul><h3 id="四、操作系统的基本特征"><a href="#四、操作系统的基本特征" class="headerlink" title="四、操作系统的基本特征"></a>四、操作系统的基本特征</h3><ul><li>并发</li><li>共享</li><li>虚拟</li><li>异步性</li></ul><p><strong>并发：</strong>指在计算机系统中同时存在着多道运行的程序（进程）宏观上：多道程序同时在执行；微观上：任何时刻只有一道程序在执行，即微观上多道程序在CPU上轮流（交替）执行（单机）</p><p><strong>并行：</strong>与并发相似，指多道程序在同一时刻执行，但需多个硬件支持。</p><blockquote><p>并发是操作系统最重要的特征，其它特征均以并发为前提。                </p></blockquote><p><strong>共享：</strong>指系统中的资源不再为某道程序所独占，而是供多道程序共同使用。</p><p>资源共享方式：互斥共享式、同时访问式</p><p><strong>虚拟：</strong>把一个<code>物理实体</code>映射为若干个对应的<code>逻辑实体</code>——分时或分空间</p><blockquote><p>虚拟是操作系统管理系统资源的重要手段，可提高资源利用率</p></blockquote><p>如：虚拟处理机、虚拟存储器、虚拟设备</p><p><strong>异步性：</strong>也称不确定性，指进程在执行中，其执行时间、顺序、向前推进的速度和完成的时间等都是不可预知的。</p><h3 id="五、操作系统的功能"><a href="#五、操作系统的功能" class="headerlink" title="五、操作系统的功能"></a>五、操作系统的功能</h3><ul><li>处理机管理</li><li>存储器管理</li><li>设备管理</li><li>文件管理</li><li>用户接口</li></ul><h4 id="（1）处理机管理的功能"><a href="#（1）处理机管理的功能" class="headerlink" title="（1）处理机管理的功能"></a>（1）处理机管理的功能</h4><ul><li><p>处理机管理的主要任务</p><ul><li><p>是对处理机进行<code>分配</code></p></li><li><p>对处理机<code>运行进行有效的控制和管理</code></p></li></ul></li></ul><p>​注：处理机的分配和运行以进程为基本单位，因此对处理机的管理可归结于对进程的管理</p><ul><li>处理机管理的功能<ul><li>进程管理</li><li>进程同步</li><li>进程通信</li><li>调度</li></ul></li></ul><h4 id="（2）存储器管理的功能"><a href="#（2）存储器管理的功能" class="headerlink" title="（2）存储器管理的功能"></a>（2）存储器管理的功能</h4><ul><li>主要任务<ul><li>为多道程序的运行提供良好的环境</li><li>方便用户使用存储器</li><li>提高存储器的利用率</li><li>从逻辑上扩充内存</li></ul></li><li>功能<ul><li>内存分配</li><li>内存保护</li><li>地址映射</li><li>内存扩充</li></ul></li></ul><h4 id="（3）设备管理的功能"><a href="#（3）设备管理的功能" class="headerlink" title="（3）设备管理的功能"></a>（3）设备管理的功能</h4><ul><li>主要任务<ul><li>完成用户提出的I&#x2F;O请求</li><li>为用户分配I&#x2F;O设备</li><li>提高I&#x2F;O设备的利用率及速度</li><li>方便用户使用I&#x2F;O设备</li></ul></li><li>功能<ul><li>缓冲管理</li><li>设备分配</li><li>设备处理</li><li>虚拟设备</li></ul></li></ul><h4 id="（4）文件管理的功能"><a href="#（4）文件管理的功能" class="headerlink" title="（4）文件管理的功能"></a>（4）文件管理的功能</h4><ul><li>主要任务<ul><li>对用户文件和系统文件进行管理</li><li>方便用户使用文件</li><li>保证文件的安全性</li></ul></li><li>功能<ul><li>文件存储空间的管理</li><li>目录管理</li><li>文件的读、写管理</li><li>文件的共享与保护</li></ul></li></ul><h4 id="（5）用户接口管理的功能"><a href="#（5）用户接口管理的功能" class="headerlink" title="（5）用户接口管理的功能"></a>（5）用户接口管理的功能</h4><ul><li>主要任务<ul><li>方便用户使用操作系统</li></ul></li><li>功能<ul><li>命令接口</li><li>程序接口（系统调用）</li><li>图形接口</li></ul></li></ul><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h2 id="第二章进程管理"><a href="#第二章进程管理" class="headerlink" title="第二章进程管理"></a>第二章进程管理</h2><h3 id="一、进程（process）的概念"><a href="#一、进程（process）的概念" class="headerlink" title="一、进程（process）的概念"></a>一、进程（process）的概念</h3><h4 id="1、进程的定义"><a href="#1、进程的定义" class="headerlink" title="1、进程的定义"></a>1、进程的定义</h4><p>（1）进程是程序的一次执行</p><p>（2）进程是一个程序及其数据在处理机上顺序执行时所发生的活动</p><p>（3）进程是程序在一个数据集合上的运行过程，<strong>它是系统进行资源分配和调度的一个独立单位</strong></p><h4 id="2、进程与程序的区别"><a href="#2、进程与程序的区别" class="headerlink" title="2、进程与程序的区别"></a>2、进程与程序的区别</h4><p>（1）程序是指令的有序集合，其本身没有任何运行的含义，它是一个<strong>静态</strong>的概念。而进程是程序在处理机上的一次执行过程，它是一个<strong>动态</strong>概念。</p><p>（2）程序的<strong>存在是永久</strong>的。而<strong>进程则是有生命期</strong>的，它因创建而产生，因调度而执行，因得不到资源而暂停，因撤消而消亡。</p><p>（3）程序仅是<strong>指令的有序集合</strong>。而进程则由<strong>程序段、相关数据段和进程控制块（PCB）</strong>组成。</p><p>（4）<strong>进程与程序之间不是一一对应</strong>。</p><h4 id="3、进程的特征"><a href="#3、进程的特征" class="headerlink" title="3、进程的特征"></a>3、进程的特征</h4><p>（1）<strong>结构特征</strong>：为了描述和记录进程的运动变化过程，并使之能正确运行，每个进程都应配置了一个进程PCB。所以，从结构上看，每个进程（进程实体）都是由<strong>程序段、相关数据段及进程控制块（PCB）</strong>组成。</p><p>（2）<strong>动态性</strong>：进程的实质是<strong>程序在处理机上的一次执行过程</strong>，因此是动态性的。所以动态性是进程的最基本的特征。同时动态性还表现在 <strong>进程则是有生命期</strong>的，它因创建而产生，因调度而执行，因得不到资源而暂停，因撤消而消亡。</p><p>（3）<strong>并发性</strong>：指多个进程实体同时存在于内存中，能在一段时间内同时运行。引入进程的目的就是为了使进程能并发执行，以提高资源利用率，所以并发性是进程的重要特征，也是OS的重要特征。</p><p>（4）<strong>独立性</strong>：指进程是一个能独立运行的基本单位，也是系统进行资源分配和调度的独立单位。</p><p>（5）<strong>异步性</strong>：指进程以各自独立的、不可预知的速度向前推进。</p><h3 id="二、进程的状态"><a href="#二、进程的状态" class="headerlink" title="二、进程的状态"></a>二、进程的状态</h3><h4 id="1、三种基本状态"><a href="#1、三种基本状态" class="headerlink" title="1、三种基本状态"></a>1、三种基本状态</h4><ul><li><strong>就绪态</strong>：进程已获得了除<code>处理机</code>以外的所有资源，等待分配处理机执行的等待状态。</li><li><strong>执行态</strong>：当一个进程获得必要的资源并正在处理机上执行的状态。</li><li><strong>阻塞态</strong>：正在执行的进程由于发生某事件而暂时无法执行下去，此时进程所处的状态。</li></ul><p>进程在运行期间并非固定处于某个状态，而是不断从一个状态转换到另一个状态。</p><h4 id="2、状态转换"><a href="#2、状态转换" class="headerlink" title="2、状态转换"></a>2、状态转换</h4><p><img src="https://pencil1024.oss-cn-chengdu.aliyuncs.com/imgs/202407161342258.png"></p><h4 id="3、进程的挂起-静止状态"><a href="#3、进程的挂起-静止状态" class="headerlink" title="3、进程的挂起&#x2F;静止状态"></a>3、进程的挂起&#x2F;静止状态</h4><p>程序在运行期间，由于某种需要，往往要将进程暂停执行，使其静止下来，以满足其需要。这种静止状态就称为进程的挂起状态。</p><h4 id="4、引起挂起状态的原因"><a href="#4、引起挂起状态的原因" class="headerlink" title="4、引起挂起状态的原因"></a>4、引起挂起状态的原因</h4><ul><li><p><strong>终端用户的需要</strong>：终端用户在自己程序运行中发现问题要求使正在执行的进程暂停执行而使进程处于挂起状态。</p></li><li><p><strong>父进程的需要：</strong>父进程为了考查和修改某个子进程，或者协调各子进程间的活动，需要将该子进程挂起。</p></li><li><p><strong>操作系统的需要：</strong>操作系统为了检查运行中的资源使用情况或进行记 帐，而将某些进程挂起。</p></li><li><p><strong>对换的需要：</strong>为了提高内存的利用率，而将内存中某些进程挂起，以调进其它程序运行。</p></li><li><p><strong>负荷调节的需要：</strong>由于工作负荷较重，而将一些不重要的进程挂起，以保证系统能正常运行（实时操作系统）</p></li></ul><h4 id="5、具有挂起状态的进程状态"><a href="#5、具有挂起状态的进程状态" class="headerlink" title="5、具有挂起状态的进程状态"></a>5、具有挂起状态的进程状态</h4><p><img src="https://pencil1024.oss-cn-chengdu.aliyuncs.com/imgs/202407161340067.png" alt="image-20240527114851073"></p><h3 id="三、进程控制块（Process-Control-Block-PCB）"><a href="#三、进程控制块（Process-Control-Block-PCB）" class="headerlink" title="三、进程控制块（Process Control Block PCB）"></a>三、进程控制块（Process Control Block PCB）</h3><h4 id="1、进程控制块的概念"><a href="#1、进程控制块的概念" class="headerlink" title="1、进程控制块的概念"></a>1、进程控制块的概念</h4><p>是操作系统为了管理和控制进程的运行而为每一个进程定义的一个<code>数据结构</code>，它记录了系统管理进程所需的全部信息。系统根据PCB而感知进程的存在，PCB是进程存在的<code>唯一</code>标志。</p><h4 id="2、作用"><a href="#2、作用" class="headerlink" title="2、作用"></a>2、作用</h4><p>（1）是OS对并发执行的进程进行控制和管理的根据。</p><p>（2）也是系统用来感知进程存在的根据，即PCB是进程存在的唯一标志。</p><h4 id="3、进程控制块PCB中的信息"><a href="#3、进程控制块PCB中的信息" class="headerlink" title="3、进程控制块PCB中的信息"></a>3、进程控制块PCB中的信息</h4><p>根据操作系统的要求不同，PCB所包含信息有些不同，但通常包含以下信息：</p><p>（1）<strong>进程标志符</strong>：由系统创建进程时分配给进程的唯一标识号，通常为一整数，称为进程号，用于区分不同的进程。其所属用户通常也为一整数，称为用户号。</p><p>（2）<strong>处理机状态（断点信息）</strong>：即处理机中各种寄存器（通用寄存器、PC、PSW等）的内容</p><p>（3）<strong>进程调度</strong>：记录了进程调度的相关信息（状态、优先级、事件等）。</p><p>（4）<strong>进程控制</strong>：记录了系统对进程控制的信息（程序和数据的地址、同步机制、资源清单、链接指针）</p><h4 id="4、进程控制块PCB的组织方式"><a href="#4、进程控制块PCB的组织方式" class="headerlink" title="4、进程控制块PCB的组织方式"></a>4、进程控制块PCB的组织方式</h4><p>（1）链接方式</p><p>（2）索引方式</p><hr><p>未完待续…….（因为期末变成大作业了，开摆！）</p><h3 id="专有名词解释"><a href="#专有名词解释" class="headerlink" title="专有名词解释"></a>专有名词解释</h3><h5 id="1-批处理"><a href="#1-批处理" class="headerlink" title="[1]批处理"></a><strong>[1]批处理</strong></h5><p>程序或作业在计算机上执行过程中不必人工干预的任务处理方式</p><h5 id="2-优先级调度"><a href="#2-优先级调度" class="headerlink" title="[2]优先级调度"></a><strong>[2]优先级调度</strong></h5><p>一种进程调度策略，根据进程优先级选择下一个要占用处理器的就绪进程</p><h5 id="3-死锁"><a href="#3-死锁" class="headerlink" title="[3]死锁"></a><strong>[3]死锁</strong></h5><p>多个事物竞争共享的数据对象而处于永远等待的状态</p><h5 id="4-系统资源"><a href="#4-系统资源" class="headerlink" title="[4]系统资源"></a><strong>[4]系统资源</strong></h5><p>一个计算机系统能被单独分配给计算任务的软件和硬件的总称，例如运算处理部件、存储器、输入&#x2F;输出设备、程序库、数据库等</p><h5 id="5-信号量"><a href="#5-信号量" class="headerlink" title="[5]信号量"></a><strong>[5]信号量</strong></h5><p>一种取值为整数的变量，表示可用的临界资源数目或等待资源的进程数，进程调用PV原语改变该变量的值，用来实现进程间同步或互斥</p><h5 id="6-控制块"><a href="#6-控制块" class="headerlink" title="[6]控制块"></a><strong>[6]控制块</strong></h5><p>唯一标识操作系统内核对象并保存其属性的专用数据结构、用于管理控制该内核对象，如进程控制块、文件控制块等</p><h3 id="知识点"><a href="#知识点" class="headerlink" title="知识点"></a>知识点</h3><h4 id="并发和并行的区别"><a href="#并发和并行的区别" class="headerlink" title="并发和并行的区别"></a>并发和并行的区别</h4><p><strong>并发：</strong>指一个处理器同时处理多个任务（在宏观上具有多个进程同时执行的效果，但在微观上并不是同时执行的，只是把时间分成若干段，使多个进程快速交替的执行）</p><p><strong>并行：</strong>指在同一时刻，有多条指令在多个处理器上同时执行（无论从微观还是从宏观来看，二者都是一起执行的）</p><h4 id="创建一个新的进程时的步骤是"><a href="#创建一个新的进程时的步骤是" class="headerlink" title="创建一个新的进程时的步骤是"></a>创建一个新的进程时的步骤是</h4><p>（1）需要申请一个空白PCB</p><p>（2）为新进程分配资源</p><p>（3）初始化PCB</p><p>（4）将新进程插入就绪队列</p><p>选择实时调度算法的重要准则是<strong>截止时间的保证</strong></p><h4 id="死锁的四个必要条件"><a href="#死锁的四个必要条件" class="headerlink" title="死锁的四个必要条件"></a>死锁的四个必要条件</h4><p>（1）互斥条件（资源互斥是资源使用的固有特性是无法改变、破坏的）</p><p>（2）请求和保持条件</p><p>（3）非剥夺条件</p><p>（4）循环等待条件（资源有序分配策略可以限制循环等待条件的发生）</p><p>死锁的避免是根据<strong>防止系统进入不安全状态</strong>采取措施实现的、</p><p>银行家算法是一种最具有代表性的避免死锁的算法</p><p>银行家算法是需要（每个本身有点+空闲的）都大于等于需求的eg（2,2,2）&gt;(1,1,1)可以，但是(7,2,3)和（1,5,3）则不行，因为2不大于5</p><h4 id="同步应遵循的原则有："><a href="#同步应遵循的原则有：" class="headerlink" title="同步应遵循的原则有："></a>同步应遵循的原则有：</h4><p>1、空闲让进</p><p>2、忙则等待</p><p>3、有限等待</p><p>4、让权等待</p><h4 id="那信号量上面值n代表什么意思呢？"><a href="#那信号量上面值n代表什么意思呢？" class="headerlink" title="那信号量上面值n代表什么意思呢？"></a>那信号量上面值n代表什么意思呢？</h4><p>n&gt;0：当前有可用资源，可用资源数量为n<br>n&#x3D;0：资源都被占用，可用资源数量为0<br>n&lt;0：资源都被占用，并且还有n个进程正在排队</p><p>信号量的<strong>初值</strong>可以是：</p><p>1、大于0的数</p><p>2、等于0</p><p><del>3、小于0的数</del>（<strong>初值不能为负</strong>）</p><h4 id="进程的挂起状态可以分为："><a href="#进程的挂起状态可以分为：" class="headerlink" title="进程的挂起状态可以分为："></a>进程的挂起状态可以分为：</h4><p>1、挂起就绪</p><p>2、挂起阻塞</p><h4 id="进程控制的作用："><a href="#进程控制的作用：" class="headerlink" title="进程控制的作用："></a>进程控制的作用：</h4><p>1、创建新进程</p><p>2、终止已完成进程</p><p>3、终止由于某事件而无法运行下去的进程</p><p>4、负责进程的各状态间的转换</p><h4 id="引起阻塞的事件"><a href="#引起阻塞的事件" class="headerlink" title="引起阻塞的事件"></a>引起阻塞的事件</h4><p>1、请求系统服务</p><p>2、数据尚未到达</p><p>3、无新工作可做</p><p><del>启动某种操作</del>（启动操作是主动的行为，不会被其他程序阻塞）</p><h4 id="进程控制块的具体作用"><a href="#进程控制块的具体作用" class="headerlink" title="进程控制块的具体作用"></a>进程控制块的具体作用</h4><p>（1）作为独立运行基本单位的标志</p><p>（2）能实现间断性运行方式</p><p>（3）提供进程管理所需要的信息</p><p>（4）提供进程调度所需要的信息</p><p>（5）实现与其他进程的同步与通信</p><h4 id="简述处理机三级调度分别完成什么工作"><a href="#简述处理机三级调度分别完成什么工作" class="headerlink" title="简述处理机三级调度分别完成什么工作"></a>简述处理机三级调度分别完成什么工作</h4><p>（1）高级调度：即作业调度，用于决定把外存上处于后备队列中的哪些作业调入内存，并为它们创建进程，分配必要的资源，然后，再将新创建的进程排在就绪队列上，准备执行。</p><p>（2）中级调度：实际上就是存储器管理中的对换功能，完成内存和外存信息的交换调度</p><p>（3）低级调度：即进程调度，它决定就绪队列中的哪个进程将获得处理机，然后由分派程序执行把处理机分配给该进程的操作</p>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>刷题打卡</title>
      <link href="/posts/fbfa1a12.html"/>
      <url>/posts/fbfa1a12.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="坚持刷题打卡！！！"><a href="#坚持刷题打卡！！！" class="headerlink" title="坚持刷题打卡！！！"></a>坚持刷题打卡！！！</h3><ul><li><input checked="" disabled="" type="checkbox"> Day1——Ac 12道</li><li><input checked="" disabled="" type="checkbox"> Day2——Ac 1道（今晚事有点多）好消息，过校选了，压线，6月8号重庆市大学生程序设计大赛</li><li><input checked="" disabled="" type="checkbox"> Day3——Ac 4道（太困了，精力不足，今晚早点睡）</li><li><input checked="" disabled="" type="checkbox"> Day4——Ac 0道（表达式求值有点懵逼，还是太困了，明早起来补，还得准备星期天的软考）</li><li><input checked="" disabled="" type="checkbox"> Day5——Ac 4道</li><li><input checked="" disabled="" type="checkbox"> Day6——Ac 0道（软考结束，肝操作系统了）</li><li><input checked="" disabled="" type="checkbox"> Day7——报告</li><li><input checked="" disabled="" type="checkbox"> Day8——报告</li><li><input checked="" disabled="" type="checkbox"> Day9——报告</li></ul><p>…………………………………..</p><p>没记录了，无数的报告，结局是肝了20多天的报告。。。天天写到凌晨3点（真服了）</p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>sublime配置C++编译环境</title>
      <link href="/posts/142149a.html"/>
      <url>/posts/142149a.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="sublime配置C-C-编译环境"><a href="#sublime配置C-C-编译环境" class="headerlink" title="sublime配置C&#x2F;C++编译环境"></a>sublime配置C&#x2F;C++编译环境</h2><ul><li><p>先下载sublime（这是废话）</p></li><li><p>配置C&#x2F;C++编译环境</p><ul><li>进入DevC++文件夹目录<img src="https://img2.imgtp.com/2024/04/19/HLRap4yQ.png" alt="image-20240419181911763"></li><li>复制上方地址</li><li>右击我的电脑-&gt;点击属性-&gt;点击高级系统设置-&gt;环境配置-&gt;系统变量中点击path-&gt;新建将刚才的地址粘贴于此</li><li>win+r   输入 <code>g++ -v</code>出现版本即说明搭建成功</li></ul></li><li><p>配置编译文件</p><ul><li>运行sublime，点击工具-&gt;编译系统-&gt;新编译系统，会出现以sublime-build为后缀的文件，复制代码（文后附），粘贴覆盖原有即可，然后保存，分别命名为C和C++(.sublime-build)（什么？没有权限保存？试试管理员运行模式）</li></ul><p>C语言</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;working_dir&quot;: &quot;$file_path&quot;,</span><br><span class="line">    &quot;cmd&quot;: &quot;gcc -Wall \&quot;$file_name\&quot; -o \&quot;$file_base_name\&quot;&quot;,</span><br><span class="line">    &quot;file_regex&quot;: &quot;^(..[^:]*):([0-9]+):?([0-9]+)?:? (.*)$&quot;,</span><br><span class="line">    &quot;selector&quot;: &quot;source.c&quot;,</span><br><span class="line"></span><br><span class="line">    &quot;variants&quot;: </span><br><span class="line">    [</span><br><span class="line">        &#123;   </span><br><span class="line">        &quot;name&quot;: &quot;Run&quot;,</span><br><span class="line">            &quot;shell_cmd&quot;: &quot;gcc -Wall \&quot;$file\&quot; -o \&quot;$file_base_name\&quot; &amp;&amp; start cmd /c \&quot;\&quot;$&#123;file_path&#125;/$&#123;file_base_name&#125;\&quot; &amp; pause\&quot;&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>C++语言</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;encoding&quot;: &quot;utf-8&quot;,</span><br><span class="line">    &quot;working_dir&quot;: &quot;$file_path&quot;,</span><br><span class="line">    &quot;shell_cmd&quot;: &quot;g++ -Wall -std=c++11 \&quot;$file_name\&quot; -o \&quot;$file_base_name\&quot;&quot;,</span><br><span class="line">    &quot;file_regex&quot;: &quot;^(..[^:]*):([0-9]+):?([0-9]+)?:? (.*)$&quot;,</span><br><span class="line">    &quot;selector&quot;: &quot;source.c++&quot;,</span><br><span class="line"></span><br><span class="line">    &quot;variants&quot;: </span><br><span class="line">    [</span><br><span class="line">        &#123;   </span><br><span class="line">        &quot;name&quot;: &quot;Run&quot;,</span><br><span class="line">            &quot;shell_cmd&quot;: &quot;g++ -Wall -std=c++11 \&quot;$file\&quot; -o \&quot;$file_base_name\&quot; &amp;&amp; start cmd /c \&quot;\&quot;$&#123;file_path&#125;/$&#123;file_base_name&#125;\&quot; &amp; pause\&quot;&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>FastOlympicCoding插件下载</p><ul><li>ctrl+shift+p    输入FastOlympicCoding下载</li><li>ctrl+b弹出终端运行，按esc键即可关闭结果运行框，再按<code>i</code>键，恢复insert状态</li><li>ctrl+alt+b弹出FastOlympicCoding右边运行框</li><li>alt+shift+1关闭右边的运行框分页窗口</li></ul></li></ul><p>献上参考博客：</p><p><a href="https://blog.csdn.net/gl486546/article/details/78208634?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-78208634-blog-107137805.235%5Ev43%5Epc_blog_bottom_relevance_base4&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~CTRLIST~Rate-1-78208634-blog-107137805.235%5Ev43%5Epc_blog_bottom_relevance_base4&utm_relevant_index=2">sublime配置编译C&#x2F;C++_sublime 指定c++编译版本-CSDN博客</a></p><p><a href="https://blog.csdn.net/zhaqonianzhu/article/details/127897253#">sublime text 关闭编译结果框_sublime的下面的框框怎么关-CSDN博客</a></p><p><a href="https://blog.csdn.net/weixin_57202646/article/details/123517113">关于sublime text 如何使用fastolympiccoding插件实现高效刷题（循环测试）-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> 环境配置 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>想到什么说什么</title>
      <link href="/posts/5fd6e59a.html"/>
      <url>/posts/5fd6e59a.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>明天省赛答辩祝好运^_^</p><blockquote><p>后续：g了，花的时间很长省三结束o(╥﹏╥)o</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 随心所欲 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>word相关操作</title>
      <link href="/posts/7395b0a5.html"/>
      <url>/posts/7395b0a5.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h1 id="Word"><a href="#Word" class="headerlink" title="Word:"></a>Word:</h1><h3 id="解决图不完全显示问题"><a href="#解决图不完全显示问题" class="headerlink" title="解决图不完全显示问题"></a>解决图不完全显示问题</h3><img src="https://pencil1024.oss-cn-chengdu.aliyuncs.com/imgs/202407161118940.png" alt="图的不完全显示效果图" style="zoom: 80%;" /><blockquote><p>如何解决上述的问题：</p></blockquote><img src="https://pencil1024.oss-cn-chengdu.aliyuncs.com/imgs/202407161119765.png" alt="图的不完全显示" style="zoom:80%;" /><blockquote><p> 右击 -&gt; 将固定值22磅改成单倍行距</p></blockquote><img src="https://pencil1024.oss-cn-chengdu.aliyuncs.com/imgs/202407161119103.png" alt="图的不完全显示" style="zoom:80%;" /><h3 id="在写论文的时候，通常会把数学公式居中，-1-、-2-等序号描述右对齐，该如何操作？"><a href="#在写论文的时候，通常会把数学公式居中，-1-、-2-等序号描述右对齐，该如何操作？" class="headerlink" title="在写论文的时候，通常会把数学公式居中，(1)、(2)等序号描述右对齐，该如何操作？"></a>在写论文的时候，通常会把数学公式居中，(1)、(2)等序号描述右对齐，该如何操作？</h3><ol><li><p>鼠标光标移到数学公式那一行，如果出现从MathType粘贴过来的图显示不完全，那么鼠标右击那一行的空白处，点击段落，将间距设置为多倍行间距即可</p></li><li><p>在调行间距的那个界面点击左下角的制表位，如图设置即可</p><img src="https://pencil1024.oss-cn-chengdu.aliyuncs.com/imgs/202407161125718.png" alt="数学公式居中" style="zoom:80%;" /></li><li><p>点击确定之后，在数学公式的最前面输一个tap和数学公式的最末尾输入一个tap，那么就可以看到数学公式居中对齐和数字编号右对齐了</p></li></ol><h3 id="项目符号和文本之间的空格间隙太大"><a href="#项目符号和文本之间的空格间隙太大" class="headerlink" title="项目符号和文本之间的空格间隙太大"></a>项目符号和文本之间的空格间隙太大</h3><p>如图：</p><img src="https://pencil1024.oss-cn-chengdu.aliyuncs.com/imgs/202407161121269.png" alt="制表符操作" style="zoom:80%;" /><p><strong>操作步骤</strong>：</p><p>1、点击鼠标右键，点击“调整列表缩进”。</p><img src="https://pencil1024.oss-cn-chengdu.aliyuncs.com/imgs/202407161122148.png" alt="制表符操作" style="zoom:80%;" /><p>2、把”制表符“改为“不特别标注”</p><img src="https://pencil1024.oss-cn-chengdu.aliyuncs.com/imgs/202407161122728.png" alt="制表符操作" style="zoom:80%;" /><p>3.成功</p><img src="https://pencil1024.oss-cn-chengdu.aliyuncs.com/imgs/202407161122581.png" alt="制表符操作" style="zoom:80%;" /><p><strong>参考blog：</strong></p><p><a href="https://blog.csdn.net/hehuazheyue/article/details/96898719">Word 中公式居中，编号靠右-CSDN博客</a></p><p><a href="https://blog.csdn.net/qq_45100200/article/details/130481576">Word项目符号后面空格太大的调整办法（参考文献项目编号）_word项目符号后怎么很大空白-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> office软件操作 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> word </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo添加音乐播放器</title>
      <link href="/posts/6bacc03b.html"/>
      <url>/posts/6bacc03b.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h3 id="使用-Hexo-Tag-Aplayer-插件"><a href="#使用-Hexo-Tag-Aplayer-插件" class="headerlink" title="使用 Hexo-Tag-Aplayer 插件"></a>使用 <a href="https://so.csdn.net/so/search?q=Hexo&spm=1001.2101.3001.7020">Hexo</a>-Tag-Aplayer 插件</h3><p>首先执行安装命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save hexo-tag-aplayer</span><br></pre></td></tr></table></figure><p>如果出现报错：</p><p>1、清除npm缓存</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm cache clean --force</span><br></pre></td></tr></table></figure><p>2、禁用SSL：虽然不推荐，但您可以暂时禁用SSL验证来解决这个问题。但请注意，这会降低安全性。您可以通过设置npm的 strict-ssl 选项为 false 来实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm config set strict-ssl false</span><br></pre></td></tr></table></figure><p>参考这篇文章：<a href="https://blog.csdn.net/weixin_58068682/article/details/116612364?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-5-116612364-blog-88092728.235%5Ev43%5Epc_blog_bottom_relevance_base4&spm=1001.2101.3001.4242.4&utm_relevant_index=8">Hexo博客技巧：为博客插入音乐_hexo添加音乐-CSDN博客</a></p><h4 id="关闭-asset-inject"><a href="#关闭-asset-inject" class="headerlink" title="关闭 asset_inject"></a>关闭 asset_inject</h4><p>在<code>主题配置文件</code>：</p><p>此步骤适用于安装了<code>hexo-tag-aplayer</code>插件的人</p><p>由于需要全局都插入aplayer和meting资源，为了防止插入重复的资源，需要把asset_inject设为false</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">aplayer:</span><br><span class="line">  meting: true</span><br><span class="line">  asset_inject: false</span><br></pre></td></tr></table></figure><h4 id="开启主题的AplayerInject"><a href="#开启主题的AplayerInject" class="headerlink" title="开启主题的AplayerInject"></a>开启主题的AplayerInject</h4><p>在主题的配置文件中，<code>enable</code>设为<code>true</code>和<code>per_page</code>设为<code>true</code>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Inject the css and script (aplayer/meting)</span><br><span class="line">aplayerInject:</span><br><span class="line">  enable: true</span><br><span class="line">  per_page: true</span><br></pre></td></tr></table></figure><h4 id="把Aplayer代码插入到主题配置文件"><a href="#把Aplayer代码插入到主题配置文件" class="headerlink" title="把Aplayer代码插入到主题配置文件"></a>把Aplayer代码插入到主题配置文件</h4><p>其中data-server为音乐平台，例如netease就是网易云，还有<code>tencent</code>, <code>kugou</code>, <code>xiami</code>, <code>baidu</code>等；</p><p>id即为你选择的音乐平台网页版点击我的喜欢页面，地址栏上方的id</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">inject:</span><br><span class="line">  head:</span><br><span class="line">  bottom:</span><br><span class="line">    - &lt;div class=&quot;aplayer no-destroy&quot; data-id=&quot;7868042847&quot; data-server=&quot;tencent&quot; data-type=&quot;playlist&quot; data-fixed=&quot;true&quot; data-mini=&quot;true&quot; data-listFolded=&quot;false&quot; data-order=&quot;random&quot; data-preload=&quot;none&quot; data-autoplay=&quot;true&quot; muted&gt;&lt;/div&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>跳转页面，音乐会重新加载？</p><p>1、记得添加<code>class=&quot;aplayer no-destroy&quot;</code></p><p>2、将主题配置文件中的pjax设置为true</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pjax: </span><br><span class="line">  enable: true</span><br><span class="line">  exclude:</span><br><span class="line">    - /music/</span><br><span class="line">    - /no-pjax/</span><br></pre></td></tr></table></figure><p>ok，执行以上操作你应该可以在左下角看到一个音乐播放器</p>]]></content>
      
      
      <categories>
          
          <category> hexo魔改 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hello world</title>
      <link href="/posts/d4a1185.html"/>
      <url>/posts/d4a1185.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><blockquote><p>本站建立已有小几个月，但都是隔三差五的发布一些文章，添加一些小功能，改改bug<br>这篇文章没有其他意思，hello world是大多数语言输出的第一句话，我仅想以此来表达我将开始持续更新博客<br>不积跬步无以至千里，不积小流无以成江河，希望自己能够坚持！</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>数据结构（二）</title>
      <link href="/posts/266a3580.html"/>
      <url>/posts/266a3580.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul><li>Trie树</li><li>并查集</li><li>手写堆</li></ul><blockquote><p>Trie树</p></blockquote><p><strong>高效的存储和查找字符串集合的数据结构</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> son[N][<span class="number">26</span>], cnt[N], idx;</span><br><span class="line"><span class="type">char</span> str[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">char</span> str[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;str[i];i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u=str[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(!son[p][u])son[p][u]= ++idx;</span><br><span class="line">        p=son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cnt[p]++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">query</span><span class="params">(<span class="type">char</span> str[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> p=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;str[i];i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u=str[i]-<span class="string">&#x27;a&#x27;</span>;</span><br><span class="line">        <span class="keyword">if</span>(!son[p][u])<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        p=son[p][u];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> cnt[p];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> op[<span class="number">2</span>];</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%s&quot;</span>,op,str);</span><br><span class="line">       <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">&#x27;I&#x27;</span>)<span class="built_in">insert</span>(str);</span><br><span class="line">        <span class="keyword">else</span><span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,<span class="built_in">query</span>(str));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>并查集</p></blockquote><p>并查集：</p><p>1、将两个元素合并</p><p>2、询问两个元素是否在一个集合当中</p><p><em>基本原理</em>：每个集合用一棵树来表示。树根的编号就是整个集合的编号。每个节点存储它的父节点，p[x]表示x的父节点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> p[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span><span class="comment">//返回x的祖宗节点 + 路径压缩</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x]!=x)p[x]=<span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)p[i]=i;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> op[<span class="number">2</span>];<span class="comment">//不用 char op; 的原因是避免scanf会读入空格和其他字符</span></span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s%d%d&quot;</span>,op,&amp;a,&amp;b);</span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">&#x27;M&#x27;</span>)p[<span class="built_in">find</span>(a)]=<span class="built_in">find</span>(b);<span class="comment">//a的祖宗节点的父节点连接b的祖宗节点，保证a和b在一个集合</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(a)==<span class="built_in">find</span>(b))<span class="built_in">put</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span><span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>连通块中点的数量</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> p[N], size[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span><span class="comment">//返回x的祖宗节点 + 路径压缩</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x]!=x)p[x]=<span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">    p[i]=i;</span><br><span class="line">    size[i]=<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> op[<span class="number">5</span>];<span class="comment">//不用 char op; 的原因是避免scanf会读入空格和其他字符</span></span><br><span class="line">        <span class="type">int</span> a,b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,op);</span><br><span class="line">        </span><br><span class="line"><span class="keyword">if</span>(op[<span class="number">0</span>]==<span class="string">&#x27;C&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">find</span>(a)==<span class="built_in">find</span>(b))<span class="keyword">continue</span>;<span class="comment">//特判，如果a在b的集合里面就直接下一次循环 </span></span><br><span class="line">       size[<span class="built_in">find</span>(b)]+=size[<span class="built_in">find</span>(a)];</span><br><span class="line">p[<span class="built_in">find</span>(a)]=<span class="built_in">find</span>(b); </span><br><span class="line">&#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(op[<span class="number">1</span>]==<span class="string">&#x27;1&#x27;</span>)<span class="comment">//Q1 </span></span><br><span class="line">        &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;a,&amp;b);</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">find</span>(a)==<span class="built_in">find</span>(b))<span class="built_in">puts</span>(<span class="string">&quot;Yes&quot;</span>);</span><br><span class="line">            <span class="keyword">else</span><span class="built_in">puts</span>(<span class="string">&quot;No&quot;</span>); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;a);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,size[<span class="built_in">find</span>(a)]);</span><br><span class="line">&#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>堆</p></blockquote><ol><li>插入一个数heap[++size]&#x3D;x;up(size);</li><li>求集合当中的最小值                 heap[1];</li><li>删除最小值                                heap[1]&#x3D;heap[size];size–;down(1);</li><li>删除任意一个元素                     heap[k]&#x3D;heap[size];size–;down(k);up(k);</li><li>修改任意一个元素                     heap[k]&#x3D;x;down(k);up(k);</li></ol><p><em><strong>堆的结构</strong></em>：</p><p>堆是一个完全二叉树</p><p><em>堆排序：</em></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> h[N],size;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t=u;</span><br><span class="line">    <span class="keyword">if</span>(u*<span class="number">2</span>&lt;=size &amp;&amp; h[u*<span class="number">2</span>]&lt;h[t])t=u*<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(u*<span class="number">2</span>+<span class="number">1</span>&lt;=size &amp;&amp; h[u*<span class="number">2</span>+<span class="number">1</span>]&lt;h[t])t=u*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(u!=t)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">swap</span>(h[u],h[t]);</span><br><span class="line">        <span class="built_in">down</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;n,&amp;m);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;h[i]);</span><br><span class="line">    size=n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=n/<span class="number">2</span>;i;i--)<span class="built_in">down</span>(i);<span class="comment">//转化为堆(为什么这样就可以，规律)</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>, h[<span class="number">1</span>]);<span class="comment">//堆顶元素即为最小值</span></span><br><span class="line">        h[<span class="number">1</span>]=h[size];</span><br><span class="line">        size--;</span><br><span class="line">       <span class="built_in">down</span>(<span class="number">1</span>);<span class="comment">//重新生成堆</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>模拟堆</p></blockquote><p>int strcmp(const char* str1, const char* str2);</p><p><code>strcmp()</code>函数的比较规则如下：</p><ul><li>如果<code>str1</code>和<code>str2</code>相等，返回值为0。</li><li>如果<code>str1</code>小于<code>str2</code>，返回值为负数。</li><li>如果<code>str1</code>大于<code>str2</code>，返回值为正数。</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> h[N], ph[N], hp[N], size;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">heap_swap</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">swap</span>(ph[hp[a]],ph[hp[b]]);</span><br><span class="line">    <span class="built_in">swap</span>(hp[a],hp[b]);</span><br><span class="line">    <span class="built_in">swap</span>(h[a],h[b]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">down</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> t=u;</span><br><span class="line">    <span class="keyword">if</span>(u*<span class="number">2</span>&lt;=size &amp;&amp; h[u*<span class="number">2</span>]&lt;h[t])t=u*<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span>(u*<span class="number">2</span>+<span class="number">1</span>&lt;=size &amp;&amp; h[u*<span class="number">2</span>+<span class="number">1</span>]&lt;h[t])t=u*<span class="number">2</span>+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(u!=t)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">heap_swap</span>(u,t);</span><br><span class="line">        <span class="built_in">down</span>(t);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">up</span><span class="params">(<span class="type">int</span> u)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>(u/<span class="number">2</span> &amp;&amp; h[u/<span class="number">2</span>]&gt;h[u])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">heap_swap</span>(u/<span class="number">2</span>,u);</span><br><span class="line">        u/=<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n,m=<span class="number">0</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;n);</span><br><span class="line">    <span class="keyword">while</span>(n--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> op[<span class="number">10</span>];</span><br><span class="line">        <span class="type">int</span> k,x;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%s&quot;</span>,op);</span><br><span class="line">        <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(op,<span class="string">&quot;I&quot;</span>)) <span class="comment">// </span></span><br><span class="line">        &#123;<span class="comment">//插入操作,从底部插入</span></span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">            size++;</span><br><span class="line">            m++;</span><br><span class="line">            ph[m]=size, hp[size]=m;<span class="comment">//***</span></span><br><span class="line">            h[size]=x;</span><br><span class="line">            <span class="built_in">up</span>(size);            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(op,<span class="string">&quot;PM&quot;</span>))<span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,h[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(op,<span class="string">&quot;DM&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">heap_swap</span>(<span class="number">1</span>,size);</span><br><span class="line">            size--;</span><br><span class="line">            <span class="built_in">down</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!<span class="built_in">strcmp</span>(op,<span class="string">&quot;D&quot;</span>))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>,&amp;k);</span><br><span class="line">            k=ph[k];<span class="comment">//第k个插入的数</span></span><br><span class="line">            <span class="built_in">heap_swap</span>(k,size);</span><br><span class="line">            size--;</span><br><span class="line">            <span class="built_in">down</span>(k),<span class="built_in">up</span>(k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>,&amp;k,&amp;x);</span><br><span class="line">            k=ph[k];</span><br><span class="line">            h[k]=x;</span><br><span class="line">            <span class="built_in">down</span>(k),<span class="built_in">up</span>(k);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构（一）</title>
      <link href="/posts/167cd958.html"/>
      <url>/posts/167cd958.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><ul><li>链表与邻接表</li><li>栈与队列</li><li>kmp</li></ul><p>用数组来模拟</p><p>好处：速度快（快很多）</p><blockquote><p>单链表</p></blockquote>  <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> head,e[N],ne[N],idx;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">head=<span class="number">-1</span>;</span><br><span class="line">    idx=<span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将x插到头结点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add_to_head</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=x, ne[idx]=head, head=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//将x插入到下标为k的点后面</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=x, ne[idx]=ne[k], ne[k]=idx++;</span><br><span class="line">&#125;  </span><br><span class="line"><span class="comment">//将下标为k的点的后面的一个点移除</span></span><br><span class="line"><span class="function"><span class="type">void</span>  <span class="title">remove</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ne[k]=ne[ne[k]];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"> <span class="type">int</span> m;</span><br><span class="line">    cin&gt;&gt;m;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> k,x;</span><br><span class="line">        <span class="type">char</span> op;</span><br><span class="line">        cin&gt;&gt;op;</span><br><span class="line">        <span class="keyword">if</span>(op==<span class="string">&#x27;H&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;x;</span><br><span class="line">            <span class="built_in">add_to_head</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op==<span class="string">&#x27;D&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;k;</span><br><span class="line">            <span class="comment">//特判 </span></span><br><span class="line">            <span class="keyword">if</span>(k==<span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="comment">//如果 k为0 那么移除头结点 </span></span><br><span class="line">            head=ne[head];</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br><span class="line">            <span class="built_in">remove</span>(k<span class="number">-1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;k&gt;&gt;x;</span><br><span class="line">            <span class="built_in">add</span>(k<span class="number">-1</span>,x);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=head; i!=<span class="number">-1</span>; i=ne[i])      cout&lt;&lt;e[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line"></span><br><span class="line">   cout&lt;&lt;endl;</span><br><span class="line">       </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>双链表</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> e[N],l[N],r[N],idx;</span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    r[<span class="number">0</span>]=<span class="number">1</span>, l[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">   idx=<span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在下标为k的点的右边插入x</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> k, <span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=x;</span><br><span class="line">    r[idx]=r[k];</span><br><span class="line">    l[idx]=k;</span><br><span class="line">    l[r[k]]=idx;</span><br><span class="line">    r[k]=idx;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//在k左边插入一个点，就调用add(l[k],x)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//删除第k个点</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">remove</span><span class="params">(<span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    r[l[k]]=r[k];</span><br><span class="line">    l[r[k]]=l[k];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>栈与队列</p></blockquote><p>栈——先进后出   队列——先进先出</p><ul><li>数组模拟栈</li></ul> <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> naemspace std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N =<span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> stk[N], tt;</span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line">stk[++tt]=x;</span><br><span class="line"></span><br><span class="line"><span class="comment">//弹出</span></span><br><span class="line">tt--;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断栈是否为空</span></span><br><span class="line"><span class="keyword">if</span>(tt&gt;<span class="number">0</span>)<span class="keyword">not</span> empty</span><br><span class="line"><span class="keyword">else</span>empty</span><br><span class="line">    </span><br><span class="line"><span class="comment">//栈顶</span></span><br><span class="line">stk[tt];</span><br></pre></td></tr></table></figure><ul><li>数组模拟队列</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> naemspace std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N =<span class="number">100010</span>;</span><br><span class="line"><span class="comment">//在队尾插入元素，在队头弹出元素</span></span><br><span class="line"><span class="type">int</span> q[N], hh, tt=<span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//插入</span></span><br><span class="line">q[++tt]=x;</span><br><span class="line"></span><br><span class="line"><span class="comment">//弹出</span></span><br><span class="line">hh++;</span><br><span class="line"></span><br><span class="line"><span class="comment">//判断队列是否为空</span></span><br><span class="line"><span class="keyword">if</span>(hh&lt;=tt)<span class="keyword">not</span> empty</span><br><span class="line"><span class="keyword">else</span>empty</span><br><span class="line"></span><br><span class="line"><span class="comment">//取出队头元素</span></span><br><span class="line">q[hh]</span><br><span class="line"><span class="comment">//尾</span></span><br><span class="line">q[tt]</span><br></pre></td></tr></table></figure><blockquote><p>单调栈</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> <span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> stk[N], tt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>),cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    </span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> x;cin&gt;&gt;x;</span><br><span class="line">        <span class="keyword">while</span>(tt &amp;&amp; stk[i] &gt;=x)tt--;</span><br><span class="line">        <span class="keyword">if</span>(tt)cout&lt;&lt;stk[tt]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="keyword">else</span>cout&lt;&lt;<span class="number">-1</span>&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        </span><br><span class="line">        stk[++tt]=x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>单调队列</p></blockquote><p>滑动窗口</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"><span class="type">int</span> n, k;</span><br><span class="line"><span class="type">int</span> a[N], q[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d%d&quot;</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)<span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;a[i]);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//最小</span></span><br><span class="line">    <span class="type">int</span> hh=<span class="number">0</span>, tt=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//判断队头是否已经滑出窗口</span></span><br><span class="line">        <span class="keyword">if</span>(hh&lt;=tt &amp;&amp; i-k+<span class="number">1</span>&gt;q[hh])hh++;</span><br><span class="line">        <span class="keyword">while</span>(hh&lt;=tt &amp;&amp; a[q[tt]]&gt;=a[i])tt--;</span><br><span class="line">        q[++tt]=i;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=k<span class="number">-1</span>)<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[q[hh]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//最大</span></span><br><span class="line">    hh=<span class="number">0</span>, tt=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//判断队头是否已经滑出窗口</span></span><br><span class="line">        <span class="keyword">if</span>(hh&lt;=tt &amp;&amp; i-k+<span class="number">1</span>&gt;q[hh])hh++;</span><br><span class="line">        <span class="keyword">while</span>(hh&lt;=tt &amp;&amp; a[q[tt]]&lt;=a[i])tt--;</span><br><span class="line">        q[++tt]=i;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=k<span class="number">-1</span>)<span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[q[hh]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;&quot;</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>KMP</p></blockquote><p>如何获取一个char数组的长度，用strlen()，但用它之前要确保在数组末尾添加null（’\0’）终止符</p><p>示例Code</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> MAX_SIZE = <span class="number">10</span>;</span><br><span class="line">    <span class="type">char</span> x[MAX_SIZE + <span class="number">1</span>]; <span class="comment">// 增加一个额外的位置，用于存储null终止符</span></span><br><span class="line">    std::cin &gt;&gt; x + <span class="number">1</span>; <span class="comment">// 将输入存储到x+1位置上</span></span><br><span class="line">    x[MAX_SIZE] = <span class="string">&#x27;\0&#x27;</span>; <span class="comment">// 确保最后一个字符为null终止符</span></span><br><span class="line">    std::cout &lt;&lt; <span class="built_in">strlen</span>(x + <span class="number">1</span>) &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>KMP</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>, M = <span class="number">1000010</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">char</span> p[N], s[M];</span><br><span class="line"><span class="type">int</span> ne[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;p+<span class="number">1</span>&gt;&gt;m&gt;&gt;s+<span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//求next数组</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>,j=<span class="number">0</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(j &amp;&amp; p[i]!=p[j+<span class="number">1</span>])j=ne[j];</span><br><span class="line">        <span class="keyword">if</span>(p[i]==p[j+<span class="number">1</span>])j++;</span><br><span class="line"> ne[i]=j;       </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//kmp匹配过程</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>,j=<span class="number">0</span>;i&lt;=m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="keyword">while</span>(j &amp;&amp; s[i]!=p[j+<span class="number">1</span>])j=ne[j];</span><br><span class="line">        <span class="keyword">if</span>(s[i]==p[j+<span class="number">1</span>])j++;</span><br><span class="line">        <span class="keyword">if</span>(j==n)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, i-n);</span><br><span class="line">            j=ne[j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最小生成树</title>
      <link href="/posts/9acb5cb3.html"/>
      <url>/posts/9acb5cb3.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="最小生成树"><a href="#最小生成树" class="headerlink" title="最小生成树"></a>最小生成树</h2><p>最小生成树是针对于无向图的，有向图没有这一概念，且这里边权值可以为负的</p><p>一般：稠密图——邻接矩阵稀疏图——邻接表</p><ul><li><p>普利姆算法（Prim）</p><ul><li><p>朴素版Prim   O(n^2)          &#x3D;&#x3D;邻接矩阵&#x3D;&#x3D;</p><p>​用于稠密图</p></li><li><p>堆优化版Prim       O(mlogn) </p><p>​用于稀疏图</p></li></ul></li><li><p>克鲁斯卡尔算法（Kruskal）       O(mlogn)</p><p>​   用于稀疏图</p></li></ul><h3 id="Prim"><a href="#Prim" class="headerlink" title="Prim()"></a>Prim()</h3><blockquote><p>输出最小生成树的权重之和</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>, INF=<span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> g[N][N];</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">prim</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dist));</span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>;<span class="comment">//最小生成树中所有边的长度之和</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">            <span class="keyword">if</span>(!st[j] &amp;&amp; (t==<span class="number">-1</span> || dist[t]&gt;dist[j]))</span><br><span class="line">                t=j;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(i&amp;&amp;dist[t]==INF)<span class="keyword">return</span> INF;</span><br><span class="line">        <span class="keyword">if</span>(i)res+=dist[t];</span><br><span class="line">        <span class="comment">//更新</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)dist[j]=<span class="built_in">min</span>(dist[j],g[t][j]);</span><br><span class="line">        </span><br><span class="line">        st[t]=<span class="literal">true</span>;  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="built_in">memset</span>(g,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(g));</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b,c;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">        g[a][b]=g[b][a]=<span class="built_in">min</span>(g[a][b],c);<span class="comment">//可能会有重边所以取最小值</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> t=<span class="built_in">prim</span>();</span><br><span class="line">    <span class="keyword">if</span>(t==INF)cout&lt;&lt;<span class="string">&quot;impossible&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span>cout&lt;&lt;t&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Kruskal"><a href="#Kruskal" class="headerlink" title="Kruskal()"></a>Kruskal()</h3><blockquote><ol><li>所有边按权重从小到大排序O(mlogm)</li><li>枚举每条边a,b  权重为c<ul><li>if  a,b 不连通将这条边加入集合中</li></ul></li></ol></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">200010</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> p[N];<span class="comment">//并查集</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a,b,w;</span><br><span class="line">    </span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt; (<span class="type">const</span> Edge &amp;W)<span class="type">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> w&lt;W.w;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;edges[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x]!=x)p[x]=<span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b,w;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b&gt;&gt;w;</span><br><span class="line">        edges[i]=&#123;a,b,w&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">sort</span>(edges,edges+m);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)p[i]=i;<span class="comment">//初始化</span></span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> res=<span class="number">0</span>,cnt=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a=edges[i].a, b=edges[i].b, w=edges[i].w;</span><br><span class="line">        a=<span class="built_in">find</span>(a), b=<span class="built_in">find</span>(b);</span><br><span class="line">        <span class="keyword">if</span>(a!=b)</span><br><span class="line">        &#123;</span><br><span class="line">            p[a]=b;</span><br><span class="line">            res+=w;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(cnt&lt;n<span class="number">-1</span>)  cout&lt;&lt;<span class="string">&quot;impossible&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 最小生成树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>最短路问题</title>
      <link href="/posts/6bbbc5e9.html"/>
      <url>/posts/6bbbc5e9.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="常见最短路"><a href="#常见最短路" class="headerlink" title="常见最短路"></a>常见最短路</h2><p>在图论中，源点—起点汇点—终点</p><ul><li><p>单源最短路</p><ul><li><p>所有边权都是正数</p><ul><li><p>朴素Dijkstra算法        O(n^2)&#x3D;&#x3D;邻接矩阵&#x3D;&#x3D;</p><p>与m（边）无关   适用于稠密图（用邻接矩阵来存）</p></li><li><p>堆优化版的Dijkstra算法     O(mlogn)      </p><p>适用于稀疏图（用邻接表来存）</p></li></ul></li><li><p>存在负权边</p><ul><li>Bellman-Ford O(nm)</li><li>SPFA             一般：O(m)，最坏O(nm)          &#x3D;&#x3D;邻接表&#x3D;&#x3D;     （稀疏图）</li></ul></li></ul></li><li><p>多源汇最短路</p><ul><li>Floyd算法 O(n^3)</li></ul></li></ul><h3 id="Dijkstra"><a href="#Dijkstra" class="headerlink" title="Dijkstra()"></a>Dijkstra()</h3><blockquote><p>Dijkstra算法求最短路（第一个点到终点）</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//朴素的Dijkstra</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>;</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">int</span> g[N][N];<span class="comment">//g[i][j]为i-&gt;j的边的权重</span></span><br><span class="line"><span class="type">int</span> dist[N];<span class="comment">//点到起点的最短距离</span></span><br><span class="line"><span class="type">bool</span> st[N]; </span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> dist);<span class="comment">//先将距离初始化为正无穷</span></span><br><span class="line">    dist[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t=<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line"><span class="keyword">if</span>(!st[j] &amp;&amp; (t==<span class="number">-1</span> || dist[t]&gt;dist[j]))</span><br><span class="line">                t=j;</span><br><span class="line">        <span class="comment">//if(t==n)break;可加上</span></span><br><span class="line">        </span><br><span class="line">        st[t]=<span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            dist[j]=<span class="built_in">min</span>(dist[j],dist[t]+g[t][j]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dist[n]==<span class="number">0x3f3f3f3f</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">   <span class="built_in">memset</span>(g,<span class="number">0x3f</span>,<span class="keyword">sizeof</span> g);<span class="comment">//初始化边为无穷大</span></span><br><span class="line">   <span class="keyword">while</span>(m--)</span><br><span class="line">   &#123;</span><br><span class="line">       <span class="type">int</span> a, b, c;</span><br><span class="line">       cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line">       g[a][b]=<span class="built_in">min</span>(g[a][b],c);<span class="comment">//有重边，取最小的一条边</span></span><br><span class="line">   &#125;</span><br><span class="line">   <span class="type">int</span> t=<span class="built_in">dijkstra</span>();</span><br><span class="line">    </span><br><span class="line">   cout&lt;&lt;t&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//朴素版Dijkstra()</span></span><br></pre></td></tr></table></figure><blockquote><p>用dijkstra算法求&#x3D;&#x3D;任意两点&#x3D;&#x3D;的最短路</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用dijkstra算法求任意两点的最短路</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">550</span>;</span><br><span class="line"><span class="type">int</span> n,m; </span><br><span class="line"><span class="type">int</span> g[N][N];</span><br><span class="line"><span class="type">int</span> dist[N], w[N];</span><br><span class="line"><span class="type">bool</span> st[N];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">dijkstra</span><span class="params">(<span class="type">int</span> start,<span class="type">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">memset</span>(dist,<span class="number">0x3f3f3f3f</span>,<span class="built_in">sizeof</span>(dist));</span><br><span class="line"><span class="built_in">memset</span>(st, <span class="literal">false</span>, <span class="built_in">sizeof</span>(st));<span class="comment">//每一次有每一次的标记点 </span></span><br><span class="line">dist[start]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> t=<span class="number">-1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!st[j] &amp;&amp; (t==<span class="number">-1</span> || dist[t]&gt;dist[j]))</span><br><span class="line">&#123;</span><br><span class="line">t=j;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">st[t]=<span class="literal">true</span>; </span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)</span><br><span class="line">&#123;</span><br><span class="line">dist[j]=<span class="built_in">min</span>(dist[j],dist[t]+g[t][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> dist[end];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">0</span>&amp;&amp;m==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line"><span class="comment">//初始化</span></span><br><span class="line"><span class="built_in">memset</span>(g,<span class="number">0x3f3f3f3f</span>,<span class="built_in">sizeof</span>(g));</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cin&gt;&gt;w[i];</span><br><span class="line"><span class="keyword">while</span>(m--)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a,b,c;</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line"><span class="keyword">if</span>(a==<span class="number">1</span>)&#123;</span><br><span class="line">g[b][c]=<span class="built_in">abs</span>(w[b]-w[c]);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">g[b][c]=g[c][b]=<span class="built_in">abs</span>(w[b]-w[c]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> start,end;</span><br><span class="line">cin&gt;&gt;start&gt;&gt;end;</span><br><span class="line">cout&lt;&lt;<span class="built_in">dijkstra</span>(start,end)&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span>  <span class="number">0</span>;</span><br><span class="line"> &#125; </span><br></pre></td></tr></table></figure><h3 id="Bellman-Ford"><a href="#Bellman-Ford" class="headerlink" title="Bellman_Ford()"></a>Bellman_Ford()</h3><blockquote><p>Bellman_Ford算法求最短路（对通过的边数有要求就用）</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>, M = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n, m, k;<span class="comment">//k是限制的边数</span></span><br><span class="line"><span class="type">int</span> dist[N], backcup[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b, w;</span><br><span class="line">&#125;edges[M];</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">bellman_ford</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dist));<span class="comment">//初始化</span></span><br><span class="line">    dist[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;k;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(backcup,dist,<span class="built_in">sizeof</span>(dist));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;m;j++)<span class="comment">//**m是要存储的边的数量，而这里恰好是m条</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a=edges[j].a, b=edges[j].b, w=edges[j].w;</span><br><span class="line">            dist[b]=<span class="built_in">min</span>(dist[b], backcup[a]+w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(dist[n]&gt;<span class="number">0x3f3f3f3f</span>/<span class="number">2</span>)<span class="keyword">return</span> <span class="number">-1</span>;<span class="comment">//(注意这里如果最短距离是-1，而返回值有是-1就错了，所以要看清题注意特征值)</span></span><br><span class="line">    <span class="keyword">return</span> dist[n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m&gt;&gt;k;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a,b,w;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b&gt;&gt;w;</span><br><span class="line">        edges[i]=&#123;a,b,w&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> t=<span class="built_in">bellman_ford</span>();</span><br><span class="line">    <span class="keyword">if</span>(t==<span class="number">-1</span>)cout&lt;&lt;<span class="string">&quot;impossible&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span>cout&lt;&lt;t&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">-----------------------------------------------分割线---------------------------------------------------</span><br><span class="line">    </span><br><span class="line"><span class="comment">//一道及其恶心的题(要注意bellman_ford返回的值可能就是最短路所以要找到一个特征值)</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">510</span>, M = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n, m, cnt;<span class="comment">//*****cnt计数 </span></span><br><span class="line"><span class="type">int</span> dist[N], backcup[N], dot[N];</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b, w;</span><br><span class="line">&#125;edges[M];</span><br><span class="line"><span class="function"><span class="type">long</span> <span class="type">long</span> <span class="title">bellman_ford</span><span class="params">(<span class="type">int</span> start,<span class="type">int</span> end)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">0x3f3f3f3f</span>,<span class="built_in">sizeof</span>(dist));<span class="comment">//初始化</span></span><br><span class="line">    dist[start]=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;<span class="number">1200</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memcpy</span>(backcup,dist,<span class="built_in">sizeof</span>(dist));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;cnt;j++)<span class="comment">//*****&#x27;&lt;cnt&#x27;</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> a=edges[j].a, b=edges[j].b, w=edges[j].w;</span><br><span class="line">            dist[b]=<span class="built_in">min</span>(dist[b], backcup[a]+w);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//    if(dist[end]&lt;50000)return dist[end]; </span></span><br><span class="line"><span class="comment">//    elsereturn -1;</span></span><br><span class="line"><span class="comment">//-----始终过不了-----(反其道而行之) 如上 </span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(dist[end]&gt;<span class="number">0x3f3f3f3f</span>/<span class="number">2</span>)<span class="keyword">return</span> <span class="number">9999</span>;<span class="comment">//没有最短距离</span></span><br><span class="line">    <span class="keyword">return</span> dist[end];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"><span class="comment">//初始化 </span></span><br><span class="line">cnt=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(n==<span class="number">0</span>&amp;&amp;m==<span class="number">0</span>)<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)cin&gt;&gt;dot[i];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;m;i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="type">int</span> a,b,c;</span><br><span class="line">cin&gt;&gt;a&gt;&gt;b&gt;&gt;c;</span><br><span class="line"><span class="type">int</span> tmp=dot[c]-dot[b];</span><br><span class="line"><span class="keyword">if</span>(a==<span class="number">1</span>)&#123;</span><br><span class="line">edges[cnt++]=&#123;b,c,tmp&#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span>&#123;</span><br><span class="line">edges[cnt++]=&#123;b,c,tmp&#125;, edges[cnt++]=&#123;c,b,tmp*<span class="number">-1</span>&#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> start, end;</span><br><span class="line">cin&gt;&gt;start&gt;&gt;end;</span><br><span class="line"><span class="type">int</span> t=<span class="built_in">bellman_ford</span>(start,end);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>(t==<span class="number">9999</span>)cout&lt;&lt;<span class="string">&quot;INF&quot;</span>&lt;&lt;endl;</span><br><span class="line"><span class="keyword">else</span>cout&lt;&lt;t&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Spfa"><a href="#Spfa" class="headerlink" title="Spfa()"></a>Spfa()</h3><blockquote><p>用Spfa算法求解带负权边的问题（全正的大部分也能做）</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> h[N],w[N],e[N],ne[N],idx;</span><br><span class="line"><span class="type">int</span> dist[N];</span><br><span class="line"><span class="type">int</span> st[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b, w[idx]=c, ne[idx]=h[a], h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dist,<span class="number">0x3f</span>,<span class="built_in">sizeof</span>(dist));</span><br><span class="line">    dist[<span class="number">1</span>]=<span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line">    st[<span class="number">1</span>]=<span class="literal">true</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();<span class="comment">//移除队首元素</span></span><br><span class="line">        st[t]=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=h[t];i!=<span class="number">-1</span>;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j=e[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[j]&gt;dist[t]+w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j]=dist[t]+w[i];</span><br><span class="line">                <span class="keyword">if</span>(!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                    st[j]=<span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(dist[n]==<span class="number">0x3f3f3f3f</span>)<span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span>dist[n]; </span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="built_in">sizeof</span>(h));</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b ,c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        <span class="built_in">add</span>(a,b,c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="type">int</span> t=<span class="built_in">spfa</span>();</span><br><span class="line">    <span class="keyword">if</span>(t==<span class="number">-1</span>)cout&lt;&lt;<span class="string">&quot;impossible&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span>cout&lt;&lt;t&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>用spfa判断有无负权环</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> N = <span class="number">100010</span>;</span><br><span class="line"><span class="type">int</span> n,m;</span><br><span class="line"><span class="type">int</span> h[N],w[N],e[N],ne[N],idx;</span><br><span class="line"><span class="type">int</span> dist[N], cnt[N];</span><br><span class="line"><span class="type">int</span> st[N];</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> a,<span class="type">int</span> b,<span class="type">int</span> c)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    e[idx]=b, w[idx]=c, ne[idx]=h[a], h[a]=idx++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">spfa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">&#123;</span><br><span class="line">st[i]=<span class="literal">true</span>;</span><br><span class="line">q.<span class="built_in">push</span>(i);</span><br><span class="line">&#125; </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span>(q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t=q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();<span class="comment">//移除队首元素</span></span><br><span class="line">        st[t]=<span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=h[t];i!=<span class="number">-1</span>;i=ne[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> j=e[i];</span><br><span class="line">            <span class="keyword">if</span>(dist[j]&gt;dist[t]+w[i])</span><br><span class="line">            &#123;</span><br><span class="line">                dist[j]=dist[t]+w[i];</span><br><span class="line">                cnt[j]=cnt[t]+<span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(cnt[j]&gt;=n)<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                </span><br><span class="line">                <span class="keyword">if</span>(!st[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    q.<span class="built_in">push</span>(j);</span><br><span class="line">                    st[j]=<span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="built_in">memset</span>(h,<span class="number">-1</span>,<span class="built_in">sizeof</span>(h));</span><br><span class="line">    <span class="keyword">while</span>(m--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b ,c;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br><span class="line">        <span class="built_in">add</span>(a,b,c);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">spfa</span>())cout&lt;&lt;<span class="string">&quot;yes&quot;</span>&lt;&lt;endl;<span class="comment">//说明有负环 </span></span><br><span class="line"><span class="keyword">else</span>cout&lt;&lt;<span class="string">&quot;no&quot;</span>&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 最短路 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hexo博客搭建</title>
      <link href="/posts/b8f4bd70.html"/>
      <url>/posts/b8f4bd70.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="利用hexo-github搭建个人博客"><a href="#利用hexo-github搭建个人博客" class="headerlink" title="利用hexo+github搭建个人博客"></a>利用hexo+github搭建个人博客</h2><p>可以利用hexo+github或hexo+gitee搭建个人博客</p><p>因为gitee创建仓库用gitee pages要高举身份证拍照，为了避免麻烦，我以hexo+github为例</p><p>github始终打不开怎么办，下载steam++开加速即可打开</p><h3 id="发布文章的步骤"><a href="#发布文章的步骤" class="headerlink" title="发布文章的步骤"></a>发布文章的步骤</h3><ul><li>hexo new ‘xxx’# 在&#x2F;source&#x2F;_posts&#x2F;路径下生成.md文件  <code>注：</code>不能直接创.md文件要用命令来生成</li><li>编辑.md文章</li><li>hexo c &#x3D;&#x3D; hexo clean      # 清除缓存  </li><li>hexo g &#x3D;&#x3D; hexo generate   # 生成静态文件</li><li>hexo d &#x3D;&#x3D; hexo deploy     # 部署到github中，更新网页端的内容</li><li>hexo s &#x3D;&#x3D; hexo server     # 通过启动本地服务器，预览文章效果</li><li>hexo n &#x3D;&#x3D; hexo new</li></ul><blockquote><p>一键部署到远程github上</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure><p><em><strong>对hexo server的解释：</strong></em></p><p>对已发布的文章进行修改后，需要重新运行 <code>hexo server</code> 命令来生成最新的静态页面，并在浏览器中刷新以查看更改的效果</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo s</span><br></pre></td></tr></table></figure><h3 id="搭建过程中遇见的一些问题"><a href="#搭建过程中遇见的一些问题" class="headerlink" title="搭建过程中遇见的一些问题"></a>搭建过程中遇见的一些问题</h3><ul><li><p>下载Node.js后，使用npm，如果出现’npm’ 不是内部或外部命令，也不是可运行的程序</p></li><li><p>如果遇到输入hexo server之后弹出 <a href="http://localhost:4000/%E7%82%B9%E5%87%BB%E6%89%93%E4%B8%8D%E5%BC%80%E7%9A%84%E6%83%85%E5%86%B5">http://localhost:4000/点击打不开的情况</a></p><p>输入 <code>npm install hexo-server --save</code></p><p>或者打开控制面板 —  程序和功能  —  打开或关闭Windows功能  —-  勾选上Internet Informent Services  —–点击确定即可</p></li><li><p>ssh -T <a href="mailto:&#103;&#105;&#x74;&#x40;&#x67;&#x69;&#x74;&#104;&#117;&#98;&#46;&#x63;&#111;&#109;">&#103;&#105;&#x74;&#x40;&#x67;&#x69;&#x74;&#104;&#117;&#98;&#46;&#x63;&#111;&#109;</a>       <code>这是ssh默认在C盘下的命令</code></p><p>ssh -i “E:\blog\ssh\id_rsa” -T <a href="mailto:&#x67;&#105;&#116;&#64;&#x67;&#x69;&#x74;&#104;&#x75;&#x62;&#x2e;&#x63;&#x6f;&#109;">&#x67;&#105;&#116;&#64;&#x67;&#x69;&#x74;&#104;&#x75;&#x62;&#x2e;&#x63;&#x6f;&#109;</a>   对密钥有<code>指定路径</code>的访问方式</p></li></ul><p>为解决如图问题，查阅大量资料，了解到：这是由于github的22端口被防火墙拒了导致ssh连接被拒绝</p><h4 id="解决方法一："><a href="#解决方法一：" class="headerlink" title="解决方法一："></a><strong>解决方法一：</strong></h4><p>既然ssh协议连接github有问题，何不换一种方式呢？采用https协议连接github。</p><p>查看当前git的远程仓库版本</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br></pre></td></tr></table></figure><p>运行后效果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">origin  git@github.com:unlimitbladeworks/Data-Struts-Learning.git (fetch)</span><br><span class="line">origin  git@github.com:unlimitbladeworks/Data-Struts-Learning.git (push)</span><br></pre></td></tr></table></figure><p><strong>采用https协议连接gihub</strong></p><p>移除掉远程仓库的配置</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote rm origin</span><br></pre></td></tr></table></figure><p>重新添加新的远程仓库，以https的形式</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin https://github.com/Pencil1024/Pencil1024.github.io.git</span><br></pre></td></tr></table></figure><p>运行效果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">origin  https://github.com/Pencil1024/Pencil1024.github.io.git (fetch)</span><br><span class="line">origin  https://github.com/Pencil1024/Pencil1024.github.io.git (push)</span><br></pre></td></tr></table></figure><h4 id="解决方法二（推荐）："><a href="#解决方法二（推荐）：" class="headerlink" title="解决方法二（推荐）："></a><strong>解决方法二（推荐）：</strong></h4><p>原因分析：</p><blockquote><p>问题大多是因为git进行push或者hexo d的时候改变了一些.deploy_git文件下的内容。</p></blockquote><p>1.删除 <code>.deploy_git</code> 文件夹;<br>2.输入 <code>git config --global core.autocrlf false</code><br>3.然后，依次执行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean</span><br><span class="line">hexo g</span><br><span class="line">hexo d</span><br></pre></td></tr></table></figure><h3 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a>一些概念</h3><ul><li><p>客户端与服务端</p><ul><li><p>客户端：向服务器发送请求的一方</p></li><li><p>服务端：收到客户端的请求做出回应的一方</p></li></ul></li><li><p>ssh（Secure Shell 是一种网络协议，用于在不安全的网络中以安全的方式进行远程登录和执行命令）</p><ul><li>远程登录：通过 SSH，可以在本地计算机上使用命令行界面（如终端）连接到远程计算机并执行命令。远程登录允许您在不直接物理接触远程计算机的情况下进行管理、配置和维护</li><li>安全传输：SSH 提供了加密和数据完整性验证的功能。所有通过 SSH 连接传输的数据都是加密的，这使得它们在网络上难以被窃听和篡改</li><li>文件传输：除了远程登录，SSH 还支持通过 SCP（Secure Copy Protocol）或 SFTP（SSH File Transfer Protocol）在本地计算机和远程计算机之间安全地传输文件。</li><li>远程执行命令：使用 SSH，您可以远程执行命令并获取执行结果。通过这种方式，您可以在远程计算机上执行各种操作，而无需直接访问该计算机。</li></ul></li><li><p>git（Git是一种分布式版本控制系统，它可以有效地跟踪和管理文件的变更）</p><ul><li>版本控制：Git可以跟踪文件的每一次修改，记录文件的变更历史。您可以随时回退到之前的版本，比较不同版本之间的差异，并恢复丢失或错误的更改。</li><li>分支管理：Git允许您创建多个分支，每个分支可以独立进行开发工作。这样可以在不影响主要代码的情况下进行实验、修复错误或并行开发不同的功能。分支可以合并到主分支或其他分支，以整合不同的工作成果。</li><li>协同开发：Git使多人协同开发变得更加简单。每个开发者可以在自己的本地仓库中进行工作，并将自己的更改推送到共享的远程仓库中。通过合并（merge）或重播（rebase）不同的分支，多个开发者的工作可以整合在一起。</li><li>远程仓库：Git支持与远程仓库进行交互，如GitHub、GitLab、Bitbucket等。您可以将本地仓库的更改推送到远程仓库，或者从远程仓库获取最新的更新。</li></ul></li></ul><h4 id="献上搭建过程中参考的优质博客："><a href="#献上搭建过程中参考的优质博客：" class="headerlink" title="献上搭建过程中参考的优质博客："></a><em>献上搭建过程中参考的优质博客：</em></h4><p><a href="https://blog.csdn.net/mjh1667002013/article/details/129290903">【Hexo】Hexo搭建Butterfly主题并快速美化_hexo主题butterfly配置-CSDN博客</a></p><p><a href="https://blog.csdn.net/antma/article/details/86104068">node.js 安装详细步骤教程_nodejs如何装-CSDN博客</a></p><p><a href="https://blog.csdn.net/qq_38952352/article/details/127656385">git安装教程-CSDN博客</a></p><p><a href="https://blog.csdn.net/weixin_44198965/article/details/99686507">git官网下载太慢解决方法-CSDN博客</a></p><p><a href="https://blog.csdn.net/m0_51269961/article/details/122575897?ops_request_misc=%7B%22request_id%22:%22170550476416800197044790%22,%22scm%22:%2220140713.130102334..%22%7D&request_id=170550476416800197044790&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_positive~default-1-122575897-null-null.142%5Ev99%5Epc_search_result_base9&utm_term=%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA&spm=1018.2226.3001.4187">快速搭建个人博客——保姆级教程-CSDN博客</a></p><p><a href="https://blog.csdn.net/qq_28919533/article/details/124338891">hexo发生error：spawn failed错误的解决方法_error: spawn failed-CSDN博客</a></p>]]></content>
      
      
      <categories>
          
          <category> hexo搭建 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
